<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Fleck.jl</title><meta name="title" content="Reference · Fleck.jl"/><meta property="og:title" content="Reference · Fleck.jl"/><meta property="twitter:title" content="Reference · Fleck.jl"/><meta name="description" content="Documentation for Fleck.jl."/><meta property="og:description" content="Documentation for Fleck.jl."/><meta property="twitter:description" content="Documentation for Fleck.jl."/><meta property="og:url" content="https://adolgert.github.io/Fleck.jl/reference/"/><meta property="twitter:url" content="https://adolgert.github.io/Fleck.jl/reference/"/><link rel="canonical" href="https://adolgert.github.io/Fleck.jl/reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Fleck.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../guide/">Bag of Clocks</a></li><li><a class="tocitem" href="../mainloop/">Sample Main Loop</a></li><li><a class="tocitem" href="../distributions/">How Fleck Decides What Happens Next</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../objects/">Structure</a></li><li><a class="tocitem" href="../commonrandom/">Common Random Numbers</a></li><li><a class="tocitem" href="../background/">Background</a></li><li><a class="tocitem" href="../distrib/">Notation for Distributions</a></li><li><a class="tocitem" href="../develop/">Develop</a></li><li><a class="tocitem" href="../samplers/">Understanding Samplers</a></li><li><a class="tocitem" href="../vas/">Vector Addition Systems</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../constant_birth/">Birth-death Process</a></li><li><a class="tocitem" href="../sir/">SIR Model</a></li></ul></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Interface"><span>Interface</span></a></li><li><a class="tocitem" href="#Samplers"><span>Samplers</span></a></li><li><a class="tocitem" href="#Algorithms"><span>Algorithms</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/adolgert/Fleck.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/adolgert/Fleck.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><ul><li><a href="#Interface">Interface</a></li><li><a href="#Samplers">Samplers</a></li><li><a href="#Algorithms">Algorithms</a></li></ul><h2 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h2><p>These are methods which are defined for any samplers subtyping <code>&lt;:SSA</code>, the abstract sampler type.</p><h3 id="Use-a-Sampler"><a class="docs-heading-anchor" href="#Use-a-Sampler">Use a Sampler</a><a id="Use-a-Sampler-1"></a><a class="docs-heading-anchor-permalink" href="#Use-a-Sampler" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.enable!" href="#Fleck.enable!"><code>Fleck.enable!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">enable!(sampler, clock, distribution, enablingtime, currenttime, RNG)</code></pre><p>Tell the sampler to start a clock.</p><ul><li><code>sampler::SSA{KeyType,TimeType}</code> - The sampler to tell.</li><li><code>clock::KeyType</code> - The ID of the clock. Can be a string, integer, tuple, etc.</li><li><code>distribution::Distributions.UnivariateDistribution</code></li><li><code>enablingtime::TimeType</code> - The zero time for the clock&#39;s distribution, in absolute time. Usually equal to <code>when</code>.</li><li><code>when::TimeType</code> - The current time of the simulation.</li><li><code>rng::AbstractRNG</code> - A random number generator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/interface.jl#L9-L21">source</a></section><section><div><pre><code class="language-julia hljs">enable!(dc::DirectCall, clock::T, distribution::Exponential, when, rng)</code></pre><p>Tell the <code>DirectCall</code> sampler to enable this clock. The <code>clock</code> argument is an identifier for the clock. The distribution is a univariate distribution in time. In Julia, distributions are always relative to time <code>t=0</code>, but ours start at some absolute enabling time, <span>$t_e$</span>, so we provide that here. The <code>when</code> argument is the time at which this clock is enabled, which may be later than when it was first enabled. The <code>rng</code> is a random number generator.</p><p>If a particular clock had one rate before an event and it has another rate after the event, call <code>enable!</code> to update the rate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/direct.jl#L51-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.disable!" href="#Fleck.disable!"><code>Fleck.disable!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">disable!(sampler, clock, when)</code></pre><p>Tell the sampler to forget a clock. We include the current simulation time because some Next Reaction methods use this to optimize sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/interface.jl#L42-L47">source</a></section><section><div><pre><code class="language-julia hljs">disable!(dc::DirectCall, clock::T, when)</code></pre><p>Tell the <code>DirectCall</code> sampler to disable this clock. The <code>clock</code> argument is an identifier for the clock. The <code>when</code> argument is the time at which this clock is enabled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/direct.jl#L75-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.next" href="#Fleck.next"><code>Fleck.next</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">next(sampler, when, rng)</code></pre><p>Ask the sampler for what happens next, in the form of <code>(when, which)::Tuple{TimeType,KeyType}</code>. <code>rng</code> is a random number generator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/interface.jl#L50-L55">source</a></section><section><div><pre><code class="language-julia hljs">next(dc::DirectCall, when::TimeType, rng::AbstractRNG)</code></pre><p>Ask the sampler what clock will be the next to fire and at what time. This does not change the sampler. You can call this multiple times and get multiple answers. Each answer is a tuple of <code>(when, which clock)</code>. If there is no clock to fire, then the response will be <code>(Inf, nothing)</code>. That&#39;s a good sign the simulation is done.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/direct.jl#L87-L95">source</a></section><section><div><pre><code class="language-julia hljs">next(multiple_direct, when, rng)</code></pre><p>Selects the next transition to fire and when it fires.</p><p>There are two main algorithms for this selection. This implementation handles the case when there are a lot of clocks or when some clocks have much smaller hazards. It first draws a random number to choose which subset of hazards will be used, and then it asks that subset to draw a random number to choose which particular hazard is used. When there are many hazards, it is possible that a random number generator will <em>never</em> choose a particular value because there is no guarantee that a random number generator covers every combination of bits. Using more draws decreases the likelihood of this problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/multiple_direct.jl#L67-L81">source</a></section><section><div><p>For the first reaction sampler, you can call next() multiple times and get different, valid, answers. That isn&#39;t the case here. When you call next() on a CombinedNextReaction sampler, it returns the key associated with the clock that fires and marks that clock as fired. Calling next() again would return a nonsensical value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/combinednr.jl#L156-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.reset!" href="#Fleck.reset!"><code>Fleck.reset!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reset!(sampler)</code></pre><p>After a sampler is used for a simulation run, it has internal state. This function resets that internal state to the initial value in preparation for another sample run.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/interface.jl#L32-L38">source</a></section><section><div><pre><code class="language-julia hljs">reset!(recorder::CommonRandomRecorder)</code></pre><p>The common random recorder records the state of the random number generator for each clock, but the same clock can be enabled multiple times in one simulation, so it records the generator state for each (clock, index of the enabling of that clock). The <code>reset!</code> function says we are starting a new simulation run, so all clocks haven&#39;t been seen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/common_random.jl#L63-L71">source</a></section></article><h3 id="Query-a-Sampler"><a class="docs-heading-anchor" href="#Query-a-Sampler">Query a Sampler</a><a id="Query-a-Sampler-1"></a><a class="docs-heading-anchor-permalink" href="#Query-a-Sampler" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getindex(sampler, clock::KeyType)</code></pre><p>Return stored state for a particular clock. If the clock does not exist, a <code>KeyError</code> will be thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/interface.jl#L58-L63">source</a></section><section><div><pre><code class="language-julia hljs">getindex(sampler::FirstReaction{K,T}, clock::K)</code></pre><p>For the <code>FirstReaction</code> sampler, returns the distribution object associated to the clock.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/firstreaction.jl#L61-L65">source</a></section><section><div><pre><code class="language-julia hljs">getindex(sampler::FirstToFire{K,T}, clock::K)</code></pre><p>For the <code>FirstToFire</code> sampler, returns the stored firing time associated to the clock.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/firsttofire.jl#L73-L77">source</a></section><section><div><pre><code class="language-julia hljs">getindex(sampler::DirectCall{K,T}, clock::K)</code></pre><p>For the <code>DirectCall</code> sampler, returns the rate parameter associated to the clock.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/direct.jl#L107-L111">source</a></section><section><div><pre><code class="language-julia hljs">getindex(sampler::CombinedNextReaction{K,T}, clock::K)</code></pre><p>For the <code>CombinedNextReaction</code> sampler, returns the stored firing time associated to the clock.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/combinednr.jl#L346-L350">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.keys" href="#Base.keys"><code>Base.keys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">keys(sampler)</code></pre><p>Return all stored clocks as a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/interface.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.keytype" href="#Base.keytype"><code>Base.keytype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">keytype(sampler)</code></pre><p>Return the type of clock keys.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/interface.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">length(sampler)::Int64</code></pre><p>Return the number of stored clocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/interface.jl#L73-L77">source</a></section></article><h2 id="Samplers"><a class="docs-heading-anchor" href="#Samplers">Samplers</a><a id="Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Samplers" title="Permalink"></a></h2><p>The choice of sampler determines specific algorithms that are used to sample, update, and disable clocks. Helpers also exist that are useful for logging, utilizing common random numbers, and hierarchical sampling.</p><h3 id="Sampler-Supertype"><a class="docs-heading-anchor" href="#Sampler-Supertype">Sampler Supertype</a><a id="Sampler-Supertype-1"></a><a class="docs-heading-anchor-permalink" href="#Sampler-Supertype" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.SSA" href="#Fleck.SSA"><code>Fleck.SSA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SSA{KeyType,TimeType}</code></pre><p>This abstract type represents a stochastic simulation algorithm (SSA). It is parametrized by the clock ID, or key, and the type used for the time, which is typically a Float64. The type of the key can be anything you would use as a dictionary key. This excludes mutable values but includes a wide range of identifiers useful for simulation. For instance, it could be a <code>String</code>, but it could be a <code>Tuple{Int64,Int64,Int64}</code>, so that it indexes into a complicated simulation state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/sampler.jl#L5-L15">source</a></section></article><h3 id="Sampler-Types"><a class="docs-heading-anchor" href="#Sampler-Types">Sampler Types</a><a id="Sampler-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Sampler-Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.FirstReaction" href="#Fleck.FirstReaction"><code>Fleck.FirstReaction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FirstReaction{KeyType,TimeType}()</code></pre><p>This is the classic first reaction method for general distributions.  Every time you sample, this goes to each distribution and asks when it would fire. Then it takes the soonest and throws out the rest of the sampled times until the next sample. It can also be very fast when there are only a few clocks to sample.</p><p>One interesting property of this sampler is that you can call <code>next()</code> multiple times in order to get a distribution of next firing clocks and their times to fire.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/firstreaction.jl#L8-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.FirstToFire" href="#Fleck.FirstToFire"><code>Fleck.FirstToFire</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FirstToFire{KeyType,TimeType}()</code></pre><p>This sampler is often the fastest for non-exponential distributions. When a clock is first enabled, this sampler asks the clock when it would fire and saves that time in a sorted heap of future times. Then it works through the heap, one by one. When a clock is disabled, its future firing time is removed from the list. There is no memory of previous firing times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/firsttofire.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.DirectCall" href="#Fleck.DirectCall"><code>Fleck.DirectCall</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DirectCall{KeyType,TimeType,TreeType}()</code></pre><p>DirectCall is responsible for sampling among Exponential distributions. It samples using the Direct method. In this case, there is no optimization to that Direct method, so we call it DirectCall because it recalculates everything every time you call it.</p><p>The algorithm for the Direct Method relies heavily on what data structure it uses to maintain a list of hazard rates, such that it can know the sum of those hazards and index into them using a random value. This struct has a default constructor that chooses a data structure for you, but there are several options.</p><p><strong>Example</strong></p><p>If we know that our simulation will only use a small number of different clock keys, then it would make sense to use a data structure that disables clocks by zeroing them out, instead of removing them from the list. This will greatly reduce memory churn. We can do that by changing the underlying data structure.</p><pre><code class="language-julia hljs">prefix_tree = BinaryTreePrefixSearch{T}()
keyed_prefix_tree = KeyedKeepPrefixSearch{K,typeof(prefix_tree)}(prefix_tree)
sampler_noremove = DirectCall{K,T,typeof(keyed_prefix_tree)}(keyed_prefix_tree)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/direct.jl#L7-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.CombinedNextReaction" href="#Fleck.CombinedNextReaction"><code>Fleck.CombinedNextReaction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CombinedNextReaction{KeyType,TimeType}()</code></pre><p>This combines Next Reaction Method and Modified Next Reaction Method. The Next Reaction Method is from Gibson and Bruck in their 2000 paper called <a href="https://doi.org/10.1021/jp993732q">&quot;Efficient Exact Stochastic Simulation of Chemical Systems with Many Species and Many Channels&quot;</a>.  The Modified Next Reaction Method is from David F. Anderson&#39;s 2007 paper,  <a href="https://doi.org/10.1063/1.2799998">&quot;A modified Next Reaction Method for simulating chemical systems with time dependent propensities and delays&quot;</a>.  Both methods reuse draws of random numbers. The former works by accumulating  survival of a distribution in a linear space and the latter works by accumulating  survival of a distribution in a log space.</p><p>Each enabled clock specifies a univariate distribution from the <code>Distributions</code> package. Every distribution is more precise being sampled in the manner of the Next Reaction method (linear space) or the manner of the Modified Next Reaction method (log space). This sampler chooses which space to use depending on the type of the <code>UnivariateDistribution</code> and based on performance timings that are done during package testing. Defaults are set for those distributions included in the <code>Distributions.jl</code> package. If you want to add a distribution, then define:</p><pre><code class="language-julia hljs">sampling_space(::MyDistribution) = LogSampling</code></pre><p>If you want to override a choice in the library, then create a sub-type of the given distribution, and specify its sampling space.</p><pre><code class="language-julia hljs">struct LinearGamma &lt;: Distributions.Gamma end
sampling_space(::LinearGamma) = LinearSampling</code></pre><p>If you want to test a distribution, look at <code>tests/nrmetric.jl</code> to see how distributions are timed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/combinednr.jl#L97-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.consume_survival" href="#Fleck.consume_survival"><code>Fleck.consume_survival</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This updates the survival for a transition in the linear space, according to Gibson and Bruck. Transition was enabled between time record t<em>0 and t</em>n. Divide the survival by the conditional survival between t<em>0 and t</em>n. t<em>e can be before t</em>0, at t<em>0, between t</em>0 and t<em>n, or at t</em>n, or after t_n.</p><p><span>$u=\exp\left(-\int_{t_e}^{t_n}\lambda_0(s-t_e)ds\right)\exp\left(-\int_{t_n}^{\tau&#39;}\lambda_{n}(s-t_e)ds\right)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/combinednr.jl#L217-L226">source</a></section><section><div><p>This updates the survival for a transition in log space, according to Anderson&#39;s method.</p><p><span>$\ln u=-\int_{t_e}^{t_n}\lambda_0(s-t_e)ds - \int_{t_n}^{\tau&#39;}\lambda_{n}(s-t_e)ds$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/combinednr.jl#L244-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.sampling_space" href="#Fleck.sampling_space"><code>Fleck.sampling_space</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This function decides whether a particular distribution can be sampled faster and more accurately using its cumulative distribution function or using the log of its cumulative distribution function, also called the integrated hazard. The former is used for the Next Reaction method by Gibson and Bruck. The latter is used by the Modified Next Reaction method of Anderson. We are calling the first a linear space and the second a logarithmic space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/combinednr.jl#L7-L14">source</a></section></article><h3 id="Sampling-Helpers"><a class="docs-heading-anchor" href="#Sampling-Helpers">Sampling Helpers</a><a id="Sampling-Helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-Helpers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.CommonRandomRecorder" href="#Fleck.CommonRandomRecorder"><code>Fleck.CommonRandomRecorder</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Common random variates, also called common random numbers (CRN), are a technique for reducing variance when repeating runs of simulations with different parameters. The idea is to record the randomness of one simulation and replay the same choices in subsequent runs. This particular implementation does this by saving the state of the random number generator every time it&#39;s used by a sampler.</p><p>The Xoshiro sampler has a relatively small state (32 bytes), which is saved every time the sampler uses random numbers. This CRN recorder saves data in memory, but we could save that to a memory-mapped file so that the operating system will optimize transfer of that memory to disk.</p><p>What happens when replays of simulation runs use more draws than the first, recorded simulation? Those simulations draw from a fresh random number generator. This is not an exact approach.</p><p><strong>Example</strong></p><p>The goal is to run the simulation with ten different parameter sets and measure how much different parameters change the mean of some quantity determined by the trajectories.</p><pre><code class="language-julia hljs">using Random: Xoshiro
using Fleck
example_clock = (3, 7)  # We will use clock IDs that are a tuple of 2 integers.
sampler = FirstToFire{typeof(example_clock)}()
crn_sampler = CommonRandomRecorder(sampler, typeof(example_clock), Xoshiro)
for trial_idx in 1:100
    run_simulation(model, crn_sampler)
    reset!(crn_sampler)
end
for param_idx in 1:10
    each_model = modify_model!(model, param_idx)
    run_simulation(each_model, crn_sampler)
    reset!(crn_sampler)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/common_random.jl#L14-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.freeze" href="#Fleck.freeze"><code>Fleck.freeze</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">freeze(cr::CommonRandomRecorder)::FrozenCommonRandomRecorder</code></pre><p>The <a href="#Fleck.CommonRandomRecorder">CommonRandomRecorder</a> records every time it sees a clock request random number generation. It continues to do that every time it runs, which is a problem if you run simulations for comparison on multiple threads. If you want to use CRN and to use multiple threads for subsequent simulation runs, then first run the simulation a bunch of times on one thread. Then freeze the simulation, and then the frozen version will stop remembering new threads.</p><p>There is one part of the frozen recorder that will be mutable because it&#39;s useful for debugging, the record of missed clocks. Freeze a recorder for each thread, and each thread will track its own misses. They will all work from the same copy of the recorded random number generator states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/common_random.jl#L149-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.misscount" href="#Fleck.misscount"><code>Fleck.misscount</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">misscount(recorder::CommonRandomRecorder)</code></pre><p>The common random recorder watches a simulation and replays the states of the random number generator on subsequent runs. This counts the number of times during the most recent run that a clock event happened that could not be replayed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/common_random.jl#L79-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.misses" href="#Fleck.misses"><code>Fleck.misses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">misses(recorder::CommonRandomRecorder)</code></pre><p>This iterates over pairs of misses in the common random recorder during the most recent simulation run, where the start of a simulation run was marked by calling <code>reset!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/common_random.jl#L90-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.MultiSampler" href="#Fleck.MultiSampler"><code>Fleck.MultiSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiSampler{SamplerKey,Key,Time}(which_sampler::Function)</code></pre><p>This makes a sampler that uses multiple stochastic sampling algorithms (SSA) to determine the next transition to fire. It returns the soonest transition of all of the algorithms. The <code>which_sampler</code> function looks at the clock ID, or key, and chooses which sampler should sample this clock. Add algorithms to this sampler like you would add them to a dictionary.</p><p>Once a clock is first enabled, it will always go to the same sampler. This sampler remembers the associations, which could increase memory for simulations with semi-infinite clocks.</p><p><strong>Examples</strong></p><p>Let&#39;s make one sampler for exponential distributions, one for a few clocks we know will be fast and one for slower clocks. We can name them with symbols. The trick is that we need to direct each kind of distribution to the correct sampler. Use a Float64 for time and each clock can be identified with an Int64.</p><pre><code class="nohighlight hljs">using Fleck
using Distributions: Exponential, UnivariateDistribution

struct ByDistribution &lt;: SamplerChoice{Int64,Symbol} end

function Fleck.choose_sampler(
    chooser::ByDistribution, clock::Int64, distribution::Exponential
    )::Symbol
    return :direct
end
function Fleck.choose_sampler(
    chooser::ByDistribution, clock::Int64, distribution::UnivariateDistribution
    )::Symbol
    if clock &lt; 100
        return :fast
    else
        return :slow
    end
end
sampler = MultiSampler{Symbol,Int64,Float64}(ByDistribution())
sampler[:direct] = OptimizedDirect{Int64,Float64}()
sampler[:fast] = FirstToFire{Int64,Float64}()
sampler[:slow] = FirstToFire{Int64,Float64}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/sampler.jl#L69-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.SingleSampler" href="#Fleck.SingleSampler"><code>Fleck.SingleSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SingleSampler{SSA,Time}(propagator::SSA)</code></pre><p>This makes a sampler from a single stochastic simulation algorithm. It combines the core algorithm with the rest of the state of the system, which is just the time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/sampler.jl#L19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.ChatReaction" href="#Fleck.ChatReaction"><code>Fleck.ChatReaction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This sampler can help if it&#39;s the first time you&#39;re trying a model. It checks all of the things and uses Julia&#39;s logger to communicate them. It samples using the first reaction algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/firstreaction.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.DebugWatcher" href="#Fleck.DebugWatcher"><code>Fleck.DebugWatcher</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DebugWatcher()</code></pre><p>For debugging, it helps to have visibility into the simulation. This Watcher records everything that is enabled or disabled as a list of all enables and all disabled. It&#39;s the complete event history, and you can think of it as the filtration for the process going forward.</p><pre><code class="nohighlight hljs">watcher = DebugWatcher{String}()
# enable and disable some things.
(watcher.enabled[1].clock,
watcher.enabled[1].distribution,
watcher.enabled[1].te,
watcher.enabled[1].when)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/track.jl#L76-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.TrackWatcher" href="#Fleck.TrackWatcher"><code>Fleck.TrackWatcher</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TrackWatcher{K,T}()</code></pre><p>This Watcher doesn&#39;t sample. It records everything enabled. You can iterate over enabled clocks with a for-loop. If we think of the model as providing changes in which transitions are enabled or disabled, this Watcher accumulates those changes to provide a consistent list of all enabled transitions. Together, a model and this Watcher provide the Semi-Markov core matrix, or the row of it that is currently known.</p><pre><code class="language-julia hljs">for entry in tracker
    entry.clock
    entry.distribution
    entry.te
    entry.when
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/sample/track.jl#L23-L41">source</a></section></article><h2 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h2><p>Many samplers depend on data structures to allow efficient querying of clocks ordered with respect to some value, usually the firing time. These types and methods implement them for Fleck.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.CumSumPrefixSearch" href="#Fleck.CumSumPrefixSearch"><code>Fleck.CumSumPrefixSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CumSumPrefixSearch{T}()</code></pre><p>This stores hazard rates in order to make it easier for the Direct method to sample them. This version is the dumbest possible, but it can be faster when there are few hazards enabled. It uses a simple array and, each time the Direct method samples, this evaluates the cumulative sum of the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/prefixsearch/cumsumprefixsearch.jl#L6-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.BinaryTreePrefixSearch" href="#Fleck.BinaryTreePrefixSearch"><code>Fleck.BinaryTreePrefixSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BinaryTreePrefixSearch{T}(N=32)</code></pre><p>This stores hazard rates to make them faster for the Direct method to sample. This is a binary tree where the leaves are values and the nodes are sums of those values. It is meant to make it easier to find the leaf such that the sum of it and all previous leaves is greater than a given value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/prefixsearch/binarytreeprefixsearch.jl#L6-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.KeyedKeepPrefixSearch" href="#Fleck.KeyedKeepPrefixSearch"><code>Fleck.KeyedKeepPrefixSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This decorator turns a Prefix Search algorithm into one that works for arbitrary keys. This version only adds entries, so disabling a clock sets its hazard to zero without removing it. If a simulation re-enables the same set of clocks, this is the faster choice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/prefixsearch/keyedprefixsearch.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.KeyedRemovalPrefixSearch" href="#Fleck.KeyedRemovalPrefixSearch"><code>Fleck.KeyedRemovalPrefixSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This decorator turns a Prefix Search algorithm into one that works for arbitrary keys. This version reuses entries in the prefix search after their clocks have been disabled. If the simulation moves through a large key space, this will use less memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/prefixsearch/keyedprefixsearch.jl#L70-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.choose" href="#Fleck.choose"><code>Fleck.choose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">choose(pst::BinaryTreePrefixSearch, value)</code></pre><p>Find the minimum index such that the prefix is greater than the given value.</p><p>Precondition: The value must be strictly less than the total for the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/prefixsearch/binarytreeprefixsearch.jl#L92-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setindex!" href="#Base.setindex!"><code>Base.setindex!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setindex!(A, X, inds...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/prefixsearch/binarytreeprefixsearch.jl#L161-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rand(rng, sampler::SamplerTrivial{BinaryTreePrefixSearch})</code></pre><p>This method overload allows the machinery of Random to generate random variates from the BinaryTreePrefixSearch set of values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/prefixsearch/binarytreeprefixsearch.jl#L183-L188">source</a></section><section><div><pre><code class="language-julia hljs">rand(rng, sampler::SamplerTrivial{CumSumPrefixSearch})</code></pre><p>This method overload allows the machinery of Random to generate random variates from the CumSumPrefixSearch set of values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/prefixsearch/cumsumprefixsearch.jl#L62-L67">source</a></section><section><div><p>Drawing a random number from a left-truncated exponential is particularly simple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/lefttrunc.jl#L9-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Fleck.set_multiple!" href="#Fleck.set_multiple!"><code>Fleck.set_multiple!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>If there are multiple values to enter, then present them at once as pairs of tuples, (index, value).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/Fleck.jl/blob/94458e68851b92d5023e5f6d97e69a563f7915e4/src/prefixsearch/binarytreeprefixsearch.jl#L123-L126">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sir/">« SIR Model</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Friday 12 April 2024 20:07">Friday 12 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
