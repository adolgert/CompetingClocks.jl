<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Samplers · CompetingClocks.jl</title><meta name="title" content="Samplers · CompetingClocks.jl"/><meta property="og:title" content="Samplers · CompetingClocks.jl"/><meta property="twitter:title" content="Samplers · CompetingClocks.jl"/><meta name="description" content="Documentation for CompetingClocks.jl."/><meta property="og:description" content="Documentation for CompetingClocks.jl."/><meta property="twitter:description" content="Documentation for CompetingClocks.jl."/><meta property="og:url" content="https://adolgert.github.io/CompetingClocks.jl/reference/"/><meta property="twitter:url" content="https://adolgert.github.io/CompetingClocks.jl/reference/"/><link rel="canonical" href="https://adolgert.github.io/CompetingClocks.jl/reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CompetingClocks.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../guide/">Competing Clocks</a></li><li><a class="tocitem" href="../mainloop/">Sample Main Loop</a></li><li><a class="tocitem" href="../distributions/">Non-exponential Simulation</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../distrib/">Notation for Distributions</a></li><li><a class="tocitem" href="../background/">Markov Processes</a></li><li><a class="tocitem" href="../gsmp/">GSMP</a></li><li><a class="tocitem" href="../samplers/">Understanding Samplers</a></li><li><a class="tocitem" href="../hierarchical/">Hierarchical Samplers</a></li><li><a class="tocitem" href="../memory/">Transitions with Memory</a></li><li><a class="tocitem" href="../commonrandom/">Common Random Numbers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../constant_birth/">Birth-death Process</a></li><li><a class="tocitem" href="../sir/">SIR Model</a></li><li><a class="tocitem" href="../reliability/">Reliability</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../interface/">Interface</a></li><li class="is-active"><a class="tocitem" href>Samplers</a><ul class="internal"><li><a class="tocitem" href="#Sampler-Supertype"><span>Sampler Supertype</span></a></li><li><a class="tocitem" href="#Sampler-Types"><span>Sampler Types</span></a></li><li><a class="tocitem" href="#Sampling-Helpers"><span>Sampling Helpers</span></a></li></ul></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Samplers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Samplers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/adolgert/CompetingClocks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/adolgert/CompetingClocks.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Samplers"><a class="docs-heading-anchor" href="#Samplers">Samplers</a><a id="Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Samplers" title="Permalink"></a></h1><p>The choice of sampler determines specific algorithms that are used to sample, update, and disable clocks. Helpers also exist that are useful for logging, utilizing common random numbers, and hierarchical sampling.</p><h2 id="Sampler-Supertype"><a class="docs-heading-anchor" href="#Sampler-Supertype">Sampler Supertype</a><a id="Sampler-Supertype-1"></a><a class="docs-heading-anchor-permalink" href="#Sampler-Supertype" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CompetingClocks.SSA" href="#CompetingClocks.SSA"><code>CompetingClocks.SSA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SSA{KeyType,TimeType}</code></pre><p>This abstract type represents a stochastic simulation algorithm (SSA). It is parametrized by the clock ID, or key, and the type used for the time, which is typically a Float64. The type of the key can be anything you would use as a dictionary key. This excludes mutable values but includes a wide range of identifiers useful for simulation. For instance, it could be a <code>String</code>, but it could be a <code>Tuple{Int64,Int64,Int64}</code>, so that it indexes into a complicated simulation state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/9a2ed10073a7b879cc97e9baf34a0e3abdbee836/src/sample/sampler.jl#L5-L15">source</a></section></article><h2 id="Sampler-Types"><a class="docs-heading-anchor" href="#Sampler-Types">Sampler Types</a><a id="Sampler-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Sampler-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CompetingClocks.FirstReaction" href="#CompetingClocks.FirstReaction"><code>CompetingClocks.FirstReaction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FirstReaction{KeyType,TimeType}()</code></pre><p>This is the classic first reaction method for general distributions.  Every time you sample, this goes to each distribution and asks when it would fire. Then it takes the soonest and throws out the rest of the sampled times until the next sample. It can also be very fast when there are only a few clocks to sample.</p><p>One interesting property of this sampler is that you can call <code>next()</code> multiple times in order to get a distribution of next firing clocks and their times to fire.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/9a2ed10073a7b879cc97e9baf34a0e3abdbee836/src/sample/firstreaction.jl#L8-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CompetingClocks.FirstToFire" href="#CompetingClocks.FirstToFire"><code>CompetingClocks.FirstToFire</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FirstToFire{KeyType,TimeType}()</code></pre><p>This sampler is often the fastest for non-exponential distributions. When a clock is first enabled, this sampler asks the clock when it would fire and saves that time in a sorted heap of future times. Then it works through the heap, one by one. When a clock is disabled, its future firing time is removed from the list. There is no memory of previous firing times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/9a2ed10073a7b879cc97e9baf34a0e3abdbee836/src/sample/firsttofire.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CompetingClocks.DirectCall" href="#CompetingClocks.DirectCall"><code>CompetingClocks.DirectCall</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DirectCall{KeyType,TimeType,TreeType}()</code></pre><p>DirectCall is responsible for sampling among Exponential distributions. It samples using the Direct method. In this case, there is no optimization to that Direct method, so we call it DirectCall because it recalculates everything every time you call it.</p><p>The algorithm for the Direct Method relies heavily on what data structure it uses to maintain a list of hazard rates, such that it can know the sum of those hazards and index into them using a random value. This struct has a default constructor that chooses a data structure for you, but there are several options.</p><p><strong>Example</strong></p><p>If we know that our simulation will only use a small number of different clock keys, then it would make sense to use a data structure that disables clocks by zeroing them out, instead of removing them from the list. This will greatly reduce memory churn. We can do that by changing the underlying data structure.</p><pre><code class="language-julia hljs">prefix_tree = BinaryTreePrefixSearch{T}()
keyed_prefix_tree = KeyedKeepPrefixSearch{K,typeof(prefix_tree)}(prefix_tree)
sampler_noremove = DirectCall{K,T,typeof(keyed_prefix_tree)}(keyed_prefix_tree)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/9a2ed10073a7b879cc97e9baf34a0e3abdbee836/src/sample/direct.jl#L7-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CompetingClocks.CombinedNextReaction" href="#CompetingClocks.CombinedNextReaction"><code>CompetingClocks.CombinedNextReaction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CombinedNextReaction{KeyType,TimeType}()</code></pre><p>This combines Next Reaction Method and Modified Next Reaction Method. The Next Reaction Method is from Gibson and Bruck in their 2000 paper called <a href="https://doi.org/10.1021/jp993732q">&quot;Efficient Exact Stochastic Simulation of Chemical Systems with Many Species and Many Channels&quot;</a>.  The Modified Next Reaction Method is from David F. Anderson&#39;s 2007 paper,  <a href="https://doi.org/10.1063/1.2799998">&quot;A modified Next Reaction Method for simulating chemical systems with time dependent propensities and delays&quot;</a>.  Both methods reuse draws of random numbers. The former works by accumulating  survival of a distribution in a linear space and the latter works by accumulating  survival of a distribution in a log space.</p><p>Each enabled clock specifies a univariate distribution from the <code>Distributions</code> package. Every distribution is more precise being sampled in the manner of the Next Reaction method (linear space) or the manner of the Modified Next Reaction method (log space). This sampler chooses which space to use depending on the type of the <code>UnivariateDistribution</code> and based on performance timings that are done during package testing. Defaults are set for those distributions included in the <code>Distributions.jl</code> package. If you want to add a distribution, then define:</p><pre><code class="language-julia hljs">sampling_space(::MyDistribution) = LogSampling</code></pre><p>If you want to override a choice in the library, then create a sub-type of the given distribution, and specify its sampling space.</p><pre><code class="language-julia hljs">struct LinearGamma &lt;: Distributions.Gamma end
sampling_space(::LinearGamma) = LinearSampling</code></pre><p>If you want to test a distribution, look at <code>tests/nrmetric.jl</code> to see how distributions are timed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/9a2ed10073a7b879cc97e9baf34a0e3abdbee836/src/sample/combinednr.jl#L97-L134">source</a></section></article><h2 id="Sampling-Helpers"><a class="docs-heading-anchor" href="#Sampling-Helpers">Sampling Helpers</a><a id="Sampling-Helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-Helpers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CompetingClocks.CommonRandomRecorder" href="#CompetingClocks.CommonRandomRecorder"><code>CompetingClocks.CommonRandomRecorder</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Common random variates, also called common random numbers (CRN), are a technique for reducing variance when repeating runs of simulations with different parameters. The idea is to record the randomness of one simulation and replay the same choices in subsequent runs. This particular implementation does this by saving the state of the random number generator every time it&#39;s used by a sampler.</p><p>The Xoshiro sampler has a relatively small state (32 bytes), which is saved every time the sampler uses random numbers. This CRN recorder saves data in memory, but we could save that to a memory-mapped file so that the operating system will optimize transfer of that memory to disk.</p><p>What happens when replays of simulation runs use more draws than the first, recorded simulation? Those simulations draw from a fresh random number generator. This is not an exact approach.</p><p><strong>Example</strong></p><p>The goal is to run the simulation with ten different parameter sets and measure how much different parameters change the mean of some quantity determined by the trajectories.</p><pre><code class="language-julia hljs">using Random: Xoshiro
using CompetingClocks
example_clock = (3, 7)  # We will use clock IDs that are a tuple of 2 integers.
sampler = FirstToFire{typeof(example_clock)}()
crn_sampler = CommonRandomRecorder(sampler, typeof(example_clock), Xoshiro)
for trial_idx in 1:100
    run_simulation(model, crn_sampler)
    reset!(crn_sampler)
end
for param_idx in 1:10
    each_model = modify_model!(model, param_idx)
    run_simulation(each_model, crn_sampler)
    reset!(crn_sampler)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/9a2ed10073a7b879cc97e9baf34a0e3abdbee836/src/sample/common_random.jl#L14-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CompetingClocks.freeze" href="#CompetingClocks.freeze"><code>CompetingClocks.freeze</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">freeze(cr::CommonRandomRecorder)::FrozenCommonRandomRecorder</code></pre><p>The <a href="#CompetingClocks.CommonRandomRecorder">CommonRandomRecorder</a> records every time it sees a clock request random number generation. It continues to do that every time it runs, which is a problem if you run simulations for comparison on multiple threads. If you want to use CRN and to use multiple threads for subsequent simulation runs, then first run the simulation a bunch of times on one thread. Then freeze the simulation, and then the frozen version will stop remembering new threads.</p><p>There is one part of the frozen recorder that will be mutable because it&#39;s useful for debugging, the record of missed clocks. Freeze a recorder for each thread, and each thread will track its own misses. They will all work from the same copy of the recorded random number generator states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/9a2ed10073a7b879cc97e9baf34a0e3abdbee836/src/sample/common_random.jl#L149-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CompetingClocks.misscount" href="#CompetingClocks.misscount"><code>CompetingClocks.misscount</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">misscount(recorder::CommonRandomRecorder)</code></pre><p>The common random recorder watches a simulation and replays the states of the random number generator on subsequent runs. This counts the number of times during the most recent run that a clock event happened that could not be replayed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/9a2ed10073a7b879cc97e9baf34a0e3abdbee836/src/sample/common_random.jl#L79-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CompetingClocks.misses" href="#CompetingClocks.misses"><code>CompetingClocks.misses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">misses(recorder::CommonRandomRecorder)</code></pre><p>This iterates over pairs of misses in the common random recorder during the most recent simulation run, where the start of a simulation run was marked by calling <code>reset!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/9a2ed10073a7b879cc97e9baf34a0e3abdbee836/src/sample/common_random.jl#L90-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CompetingClocks.MultiSampler" href="#CompetingClocks.MultiSampler"><code>CompetingClocks.MultiSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiSampler{SamplerKey,Key,Time}(which_sampler::Function)</code></pre><p>This makes a sampler that uses multiple stochastic sampling algorithms (SSA) to determine the next transition to fire. It returns the soonest transition of all of the algorithms. The <code>which_sampler</code> function looks at the clock ID, or key, and chooses which sampler should sample this clock. Add algorithms to this sampler like you would add them to a dictionary.</p><p>Once a clock is first enabled, it will always go to the same sampler. This sampler remembers the associations, which could increase memory for simulations with semi-infinite clocks.</p><p><strong>Examples</strong></p><p>Let&#39;s make one sampler for exponential distributions, one for a few clocks we know will be fast and one for slower clocks. We can name them with symbols. The trick is that we need to direct each kind of distribution to the correct sampler. Use a Float64 for time and each clock can be identified with an Int64.</p><pre><code class="nohighlight hljs">using CompetingClocks
using Distributions: Exponential, UnivariateDistribution

struct ByDistribution &lt;: SamplerChoice{Int64,Symbol} end

function CompetingClocks.choose_sampler(
    chooser::ByDistribution, clock::Int64, distribution::Exponential
    )::Symbol
    return :direct
end
function CompetingClocks.choose_sampler(
    chooser::ByDistribution, clock::Int64, distribution::UnivariateDistribution
    )::Symbol
    if clock &lt; 100
        return :fast
    else
        return :slow
    end
end
sampler = MultiSampler{Symbol,Int64,Float64}(ByDistribution())
sampler[:direct] = OptimizedDirect{Int64,Float64}()
sampler[:fast] = FirstToFire{Int64,Float64}()
sampler[:slow] = FirstToFire{Int64,Float64}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/9a2ed10073a7b879cc97e9baf34a0e3abdbee836/src/sample/sampler.jl#L69-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CompetingClocks.SingleSampler" href="#CompetingClocks.SingleSampler"><code>CompetingClocks.SingleSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SingleSampler{SSA,Time}(propagator::SSA)</code></pre><p>This makes a sampler from a single stochastic simulation algorithm. It combines the core algorithm with the rest of the state of the system, which is just the time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/9a2ed10073a7b879cc97e9baf34a0e3abdbee836/src/sample/sampler.jl#L19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CompetingClocks.ChatReaction" href="#CompetingClocks.ChatReaction"><code>CompetingClocks.ChatReaction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This sampler can help if it&#39;s the first time you&#39;re trying a model. It checks all of the things and uses Julia&#39;s logger to communicate them. It samples using the first reaction algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/9a2ed10073a7b879cc97e9baf34a0e3abdbee836/src/sample/firstreaction.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CompetingClocks.DebugWatcher" href="#CompetingClocks.DebugWatcher"><code>CompetingClocks.DebugWatcher</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DebugWatcher()</code></pre><p>For debugging, it helps to have visibility into the simulation. This Watcher records everything that is enabled or disabled as a list of all enables and all disabled. It&#39;s the complete event history, and you can think of it as the filtration for the process going forward.</p><pre><code class="nohighlight hljs">watcher = DebugWatcher{String}()
# enable and disable some things.
(watcher.enabled[1].clock,
watcher.enabled[1].distribution,
watcher.enabled[1].te,
watcher.enabled[1].when)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/9a2ed10073a7b879cc97e9baf34a0e3abdbee836/src/sample/track.jl#L76-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CompetingClocks.TrackWatcher" href="#CompetingClocks.TrackWatcher"><code>CompetingClocks.TrackWatcher</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TrackWatcher{K,T}()</code></pre><p>This Watcher doesn&#39;t sample. It records everything enabled. You can iterate over enabled clocks with a for-loop. If we think of the model as providing changes in which transitions are enabled or disabled, this Watcher accumulates those changes to provide a consistent list of all enabled transitions. Together, a model and this Watcher provide the Semi-Markov core matrix, or the row of it that is currently known.</p><pre><code class="language-julia hljs">for entry in tracker
    entry.clock
    entry.distribution
    entry.te
    entry.when
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/9a2ed10073a7b879cc97e9baf34a0e3abdbee836/src/sample/track.jl#L23-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CompetingClocks.consume_survival" href="#CompetingClocks.consume_survival"><code>CompetingClocks.consume_survival</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This updates the survival for a transition in the linear space, according to Gibson and Bruck. Transition was enabled between time record t<em>0 and t</em>n. Divide the survival by the conditional survival between t<em>0 and t</em>n. t<em>e can be before t</em>0, at t<em>0, between t</em>0 and t<em>n, or at t</em>n, or after t_n.</p><p><span>$u=\exp\left(-\int_{t_e}^{t_n}\lambda_0(s-t_e)ds\right)\exp\left(-\int_{t_n}^{\tau&#39;}\lambda_{n}(s-t_e)ds\right)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/9a2ed10073a7b879cc97e9baf34a0e3abdbee836/src/sample/combinednr.jl#L217-L226">source</a></section><section><div><p>This updates the survival for a transition in log space, according to Anderson&#39;s method.</p><p><span>$\ln u=-\int_{t_e}^{t_n}\lambda_0(s-t_e)ds - \int_{t_n}^{\tau&#39;}\lambda_{n}(s-t_e)ds$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/9a2ed10073a7b879cc97e9baf34a0e3abdbee836/src/sample/combinednr.jl#L244-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CompetingClocks.sampling_space" href="#CompetingClocks.sampling_space"><code>CompetingClocks.sampling_space</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This function decides whether a particular distribution can be sampled faster and more accurately using its cumulative distribution function or using the log of its cumulative distribution function, also called the integrated hazard. The former is used for the Next Reaction method by Gibson and Bruck. The latter is used by the Modified Next Reaction method of Anderson. We are calling the first a linear space and the second a logarithmic space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/9a2ed10073a7b879cc97e9baf34a0e3abdbee836/src/sample/combinednr.jl#L7-L14">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface/">« Interface</a><a class="docs-footer-nextpage" href="../algorithms/">Algorithms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 29 May 2024 16:42">Wednesday 29 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
