var documenterSearchIndex = {"docs":
[{"location":"hierarchical/#Hierarchical-Samplers","page":"Hierarchical Samplers","title":"Hierarchical Samplers","text":"","category":"section"},{"location":"hierarchical/#Overview","page":"Hierarchical Samplers","title":"Overview","text":"","category":"section"},{"location":"hierarchical/","page":"Hierarchical Samplers","title":"Hierarchical Samplers","text":"Continuous-time samplers have to process each event separately. As simulations grow in size, samplers use more memory, and they take more time to select the next event. One approach to speed up sampling is to use multiple samplers arranged in a hierarchy.","category":"page"},{"location":"hierarchical/#Why-Hierarchical-Samplers","page":"Hierarchical Samplers","title":"Why Hierarchical Samplers","text":"","category":"section"},{"location":"hierarchical/","page":"Hierarchical Samplers","title":"Hierarchical Samplers","text":"There are two reasons to use hierarchical samplers.","category":"page"},{"location":"hierarchical/","page":"Hierarchical Samplers","title":"Hierarchical Samplers","text":"Some samplers are better for some simulations. If all transitions are Exponentially-distributed, then an optimized Direct sampler can be the fastest. If all of the distributions are of Exponential families, then Anderson's method is faster than the Next Reaction method. You can split the events among samplers according to the sampler that best fits the behavior of those events.","category":"page"},{"location":"hierarchical/","page":"Hierarchical Samplers","title":"Hierarchical Samplers","text":"The other reason to use multiple samplers has to do with the frequency and locality of the events, in the same way we think of the frequency and locality of memory accesses for cache use. If there is a small subset of events that regenerate frequently, it can make sense even to use a FirstReaction sampler for those events. While FirstReaction doesn't use a complicated data structure to optimize, it can be winningly fast for small numbers of events. Or, for a spatial simulation, you could make separate samplers for separate parts of the landscape, so that each event tends to affect a limited number of samplers.","category":"page"},{"location":"hierarchical/#First-Sampler-to-Fire","page":"Hierarchical Samplers","title":"First Sampler to Fire","text":"","category":"section"},{"location":"hierarchical/","page":"Hierarchical Samplers","title":"Hierarchical Samplers","text":"All of the different samplers find the first event to fire. If we set up two samplers, so that each holds mutually distinct enabled event distributions, we can ask each sampler which it thinks will fire next. The first to fire is the first of the two samplers. This generalizes to any number of samplers. We can make a MultiSampler which contains multiple samplers and always returns the soonest of those contained.","category":"page"},{"location":"hierarchical/","page":"Hierarchical Samplers","title":"Hierarchical Samplers","text":"Even further a MultiSampler can contain a MultiSampler if that makes sense.","category":"page"},{"location":"hierarchical/#Multiple-Direct-Samplers","page":"Hierarchical Samplers","title":"Multiple Direct Samplers","text":"","category":"section"},{"location":"hierarchical/","page":"Hierarchical Samplers","title":"Hierarchical Samplers","text":"It's possible to make a Direct-style sampler that is hierarchical, too. A Direct sampler works in two steps. It sums the hazards of all enabled events and then selects a time according to the sum of the hazards. The main algorithm of a Direct sampler is to sum hazards. A hierarchical Direct algorithm sums the sums of the hazards and then selects a time.","category":"page"},{"location":"hierarchical/","page":"Hierarchical Samplers","title":"Hierarchical Samplers","text":"While hierarchical samplers can contain multiple-Direct samplers, multiple-Direct samplers can only contain other multiple-Direct samplers.","category":"page"},{"location":"hierarchical/#How-to-Split-a-Simulation","page":"Hierarchical Samplers","title":"How to Split a Simulation","text":"","category":"section"},{"location":"hierarchical/","page":"Hierarchical Samplers","title":"Hierarchical Samplers","text":"Each time a simulation calls enable! and disable! for an event, it specifies a key for that event. If the sampler is hierarchical, it can use that key, and maybe the type of the distribution, to choose which sampler handles any given event.","category":"page"},{"location":"hierarchical/","page":"Hierarchical Samplers","title":"Hierarchical Samplers","text":"CompetingClocks's approach in the MultiSampler type is to let the user specify a function that takes as input the key and the distribution and returns some ID for the chosen sampler. The MultiSampler then remembers that choice for this event key, from that point on.","category":"page"},{"location":"hierarchical/","page":"Hierarchical Samplers","title":"Hierarchical Samplers","text":"","category":"page"},{"location":"hierarchical/","page":"Hierarchical Samplers","title":"Hierarchical Samplers","text":"This page was generated using Literate.jl.","category":"page"},{"location":"develop/#Design","page":"Design","title":"Design","text":"","category":"section"},{"location":"develop/","page":"Design","title":"Design","text":"The scope of this is that I want to make a continuous-time simulation that is rooted in stochastic processes and as fast as they can be. The state will be the simplest, a vector of integers. Transitions, however, can be non-Exponential distributions. I'd like to exercise all of the top sampling methods. This code asks how to set up a best-practices continuous-time simulation in Julia. The fastest method for sampling is to use a hierarchical setup, where different sets of transitions get the samplers that are most efficient for their distributions.","category":"page"},{"location":"develop/","page":"Design","title":"Design","text":"The main research question is how to hook the state and transitions of the stochastic process to the sampler algorithm. The mathematical work I've seen does sometimes discuss hierarchical sampling, but it doesn't discuss algorithms for how best to connect a transition with its appropriate sampler. How do we specify it that connection? There's nothing in the math about distributions having a name or an indexing key.","category":"page"},{"location":"develop/","page":"Design","title":"Design","text":"While we normally simulate, there are some other ways to use simulation code, and those other ways give a clue about how to separate functions.","category":"page"},{"location":"develop/","page":"Design","title":"Design","text":"Fire transitions in a given order without sampling them. Work through a trace.\nConstruct a state by specifying an initial state and sequence of transitions.\nMeasure likelihood of a state without sampling. This is used for MCMC.","category":"page"},{"location":"develop/#Vector-addition-systems","page":"Design","title":"Vector addition systems","text":"","category":"section"},{"location":"develop/","page":"Design","title":"Design","text":"A vector addition system (VAS) defines the state as a vector of non-negative integers. Transitions are two matrices of shape (transition x state). One indicates how large the state vector has to be for that transition to be enabled. Together, they define values removed and added to the state vector when a transition fires.","category":"page"},{"location":"develop/","page":"Design","title":"Design","text":"In practice, vector addition systems aren't implemented with vectors. The professional versions are defined on bipartite graphs where the state is one node type and transitions are the other node type.","category":"page"},{"location":"develop/#Semi-Markov-Vector-Addition-System","page":"Design","title":"Semi-Markov Vector Addition System","text":"","category":"section"},{"location":"develop/","page":"Design","title":"Design","text":"We'll make one little change to the VAS. Instead of having only exponential distributions, it can have general distribution types. That adds complexity to the sampler, but the samplers will handle that. For the VAS, it adds some state and adds burden to specification. The state now needs to track the time at which each transition was enabled, known as t_e. We'll call the main part of the state its physical state, which is the vector of integers in this case.","category":"page"},{"location":"develop/","page":"Design","title":"Design","text":"In order to specify a Markov VAS, you need to give a rate for each transition. A chemical simulation has a very particular function to determine the rate of transitions. For chemicals, the rate is a function of the number of possible combinations of the chemicals. For a Semi-Markov VAS, which we're making, we'll let the state be any function of the state of the system.","category":"page"},{"location":"develop/","page":"Design","title":"Design","text":"There's one other wrinkle to specifying a Semi-Markov VAS. The Zimmerman simulation book points out that non-Exponential transitions can have memory or be memoryless. He means that, if a transition is enabled and disabled, we need to decide whether that affects its rate the next time it's enabled. If the transition were emptying a bathtub, and we put in the stopper plug, then taking out that plug depends on the previous enabling. It must have memory. If it were the time a robot needs to put a gas cap on an assmebly-line car, it would need to begin from scratch during a restart.","category":"page"},{"location":"develop/#Core-responsibilities","page":"Design","title":"Core responsibilities","text":"","category":"section"},{"location":"develop/","page":"Design","title":"Design","text":"The state of the system is dictated by stochastic processes theory: a. Physical state, which can be a vector of integers for this version. b. Enabling times. This is the time at which each transition was, or wasn't enabled. c. The last time any transition fired.\nSampling depends only on distributions, not any other information about each transition. All optimized samplers keep a cache of the distributions of enabled transitions and modify that cache with each firing.","category":"page"},{"location":"develop/#Sampling","page":"Design","title":"Sampling","text":"","category":"section"},{"location":"develop/","page":"Design","title":"Design","text":"Most samplers optimize their work by tracking what transitions were last enabled. They treat newly-enabled and newly-disabled transitions as a modification to the likelihood of the next sample. Some samplers don't store any state. First-reaction method is this way, as is the original Direct method. These are naive samplers, and I don't think it's worth optimizing for them. I would, instead, assume that all samplers track which transitions were last enabled. I'll add that as a layer on the first-reaction and direct methods.","category":"page"},{"location":"develop/#Sequence","page":"Design","title":"Sequence","text":"","category":"section"},{"location":"develop/","page":"Design","title":"Design","text":"The simulation inner loop is critical for efficient simulation. For continuous-time simulation, it's a game of clock-cycles, so we should get this right. This inner loop can have a lot of different kinds of calculations to do, and those calculations benefit from good cache use, right near the processor on L1. As a consequence, we want to design the parts of the inner loop so that they interleave work that operates on the same data.","category":"page"},{"location":"develop/","page":"Design","title":"Design","text":"If we think of a single transition as a consecutive set of steps, each of which has a different function, then those functions traverse state updates, transitions calculations, and sampling decisions.","category":"page"},{"location":"develop/","page":"Design","title":"Design","text":"Fire a transition.\nModify state.\nCalculate changes to transitions.\nUpdate sampler information.\nSample for next transition.","category":"page"},{"location":"develop/","page":"Design","title":"Design","text":"However, the state and transitions will be stored on a graph for the most efficient simulations. We'd like to make the most efficient simulations possible. When state and transitions are stored on a graph, it helps to perform all operations on graph data while doing a single traversal of the graph.","category":"page"},{"location":"develop/","page":"Design","title":"Design","text":"Fire a transition\nFor each [state changed]\n    Update a single state\n    For each [transition depending on that state]\n        Calculate the hazard rate for that transition.\n        Update the sampler about that updated hazard.","category":"page"},{"location":"develop/","page":"Design","title":"Design","text":"The goal, then, is to make code where firing, finding affected transitions, and sampling those transitions, is all separate, but they get called nicely in order within a single loop.","category":"page"},{"location":"distributions/#Non-exponential-Simulation","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"","category":"section"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"CompetingClocks is a sampler for generalized semi-Markov processes (GSMP). Every event in a generalized semi-Markov process is chosen as the result of a competion among clocks to see which fires next.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"In a process-oriented simulation (like SimJulia), control flow is based on tasks. Each task performs some action on the state, rolls the dice, and sets a wake-up time. It might wake up as expected and possible execute code, or it might be interrupted by another task's actions. In contrast, an event-oriented simulation using CompetingClocks will create a set of possible next events, assign a probability distribution for when each can happen, and the timing of which happens first determines which next event happens. Let's look at how a probability distribution describes the time for an event to happen and then how they compete in CompetingClocks.","category":"page"},{"location":"distributions/#Distributions-in-Time","page":"Non-exponential Simulation","title":"Distributions in Time","text":"","category":"section"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"Let's say you have a cold. You know you aren't going to recover immediately, but, as days go by, you're more and more sure you'll recover soon. This graph below shows recovery as a hazard rate, which is the probability, per unit time, given that the event has not yet happened.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"(Image: )","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"This hazard rate starts at zero, meaning there's no way you'll recover when you're first sick. It gets more likely over time that you're at the tail end of being sick. The hazard rate shown is that of a Gamma distribution, commonly used to describe the rate of recovery for a population of individuals who are sick.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"If, instead, you want to see the number of people who recover on any given day, that is called a probability distribution function (pdf), which is a much more common way to display a distribution in time.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"(Image: )","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"Where the hazard rate is an instantaneous quantity at a point in time, the probability distribution function (pdf) integrates over all possible future times. If we call the hazard rate lambda(t) and call the pdf f(t), we get this relationship.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"f(t) = lambda(t) e^-int_0^t lambda(s)ds","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"The graph of the pdf tells us that the most likely time for this event is a little before time 5, in whatever units. You will see graphs of pdfs on Wikipedia because this is how people usually think about the probability an event happens at some time.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"A simulation, however, has multiple events possible at any one time. One event may happen, and then other events need to restart. Let's ask, if you still have a cold on day 5, what is the probability distribution function for when you will recover?","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"(Image: )","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"The probability distribution function changes now that you know you didn't recover earlier than day 5. On the other hand, the hazard rate for recovery from the cold will be unchanged. Using the same hazard rate, we can recalculate the pdf from the new time t_0=5.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"f(ttt_0) = lambda(t) e^-int_t_0^t lambda(s)ds","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"The hazard rate describes a flow of probability, whereas the distribution function tells us about ensembles of events.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"The hazard rate is related to the well known cumulative distribution function (CDF) by an integral. The CDF tells us what is the overall probability the event occured some time in the interval t_0t_1).","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"F(t_0t_1) = 1 - e^-int_t_0^t_1 lambda(s) ds","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"Equally important for simulation is the survival function (sometimes called the complementary cumulative distribution function), which is the probability the event will not occur until after t_1.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"S(t_1) = 1 - F(t_10) = e^-int_0^t_1 lambda(s) ds","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"(Image: )","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"For our example, survival is the chance the cold lasts longer than the given time.","category":"page"},{"location":"distributions/#Competition","page":"Non-exponential Simulation","title":"Competition","text":"","category":"section"},{"location":"distributions/#Individual-Distributions","page":"Non-exponential Simulation","title":"Individual Distributions","text":"","category":"section"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"Let's think of a moment when there are three possible next events. There is a Gamma distribution for when you recover from a cold, a Weibull distribution for when you decide to take medicine for the cold, and an Exponential distribution for when your Mom calls you. Each one is described by a distribution in time, and we can think of them as three hazard rates.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"(Image: )","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"The separate hazard rates are what we put into the simulation. Given their competition, the hazard rates will remain unchanged, but the pdfs will change.","category":"page"},{"location":"distributions/#Marginal-Probability","page":"Non-exponential Simulation","title":"Marginal Probability","text":"","category":"section"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"Each of the three clock distributions above corresponds to a unique event E_i, which has a probability that it will be the first to fire. We calculate this probability by marginalizing over the other events, which ends up being an integral over the distribution, multiplied by the survivals of the other events.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"PE_i = int_0^infty f_i(t) prod_jne i S_j(t) dt","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"That gives the chart on the left, where the sum of all PE_i is one.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"(Image: )","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"The graph on the right shows the conditional distribution in time for each event, given that it was the one that fired, so it is Pt_i  E_i. In the language of semi-Markov processes, these distributions are called holding times. You can see that these distributions don't match the distributions for the individual events. They are modified by competition.","category":"page"},{"location":"distributions/#Marginal-Time","page":"Non-exponential Simulation","title":"Marginal Time","text":"","category":"section"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"What if we split the marginal and conditional the other way? Instead of marginalizing the probability of which event fires, start with a marginal of the probability for when any event fires. One way to calculate this is to say that the hazard rate for any event to fire is the sum of the hazard rates.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"lambda_m(t) = sum_ilambda_i(t)","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"From here, we know the pdf for the first firing time.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"f(t) = lambda_m(t)expleft(-int_0^tlambda_m(s)dsright)","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"From the graph above, if we pick a time, t_1=10, we can read from the graph three hazard rates, (lambda_1(t_1)lambda_2(t_1) lambda_3(t_1)). Each hazard rate is the rate, per unit time, of that event. We know that, if the simulation makes it to t=10 without any event happening, the conditional probability for any one of those events is the ratio of hazard rates.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"PE_1t=t_1 = fraclambda_1(t_1)lambda_1(t_1)+lambda_2(t_1)+lambda_3(t_1)","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"Now we can plot, on the left, the pdf for who fires first and, on the right, the probability of which event fires, given the firing time.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"(Image: )","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"On the left of this graph is the pdf for the first event of the three to fire. We can see this as a marginal Pt and then the right-hand graph as the conditional PE_it.","category":"page"},{"location":"distributions/#Specification-of-a-Simulation","page":"Non-exponential Simulation","title":"Specification of a Simulation","text":"","category":"section"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"If we imagine a drug trial, where patients can recover, die, or exit the trial for some other reason, there are three mutually-exclusive events, like the example above. If we pick the recovery event and plot its distribution in time, which of the above plots will we see? This will be a holding time. It won't be the pdf that represents the rate of recovery in the absence of competing events. However, given observations of competing events, it is possible to calculate back to the original hazard rates using survival analysis.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"Survival analysis uses observations of event times and event cancellations to estimate hazard rates for each event. It helps you tease apart the effects of competition to see the underlying probability per unit time that any event would fire, given that it has not yet fired.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"Simulation is the opposite of survival analysis. It allows you to take rules for how any event would fire, in the absence of competition, and to place it in a more complicated environment where competition happens. When you specify a continuous-time simulation, it isn't specified with the pdfs of holding times but with the pdfs of rates derived from survival analysis.","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"","category":"page"},{"location":"distributions/","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"sir/#Non-Markovian-SIR-Model","page":"SIR Model","title":"Non-Markovian SIR Model","text":"","category":"section"},{"location":"sir/","page":"SIR Model","title":"SIR Model","text":"using Random\nusing Plots\nusing Distributions\nusing CompetingClocks","category":"page"},{"location":"sir/","page":"SIR Model","title":"SIR Model","text":"In this tutorial we demonstrate construction of a SIR (susceptible-infectious-removed) model with non-exponential recovery times. Infection events occur at the points of a Poisson process, which is equivalent to using a single exponential clock whose rate corresponds to the overall rate of infection in the population. The infection rate is beta c S I  N where N is the total population size, making this a frequency-dependent force of infection term rather than pure mass action (although as N does not change in this example, the difference is moot). Clocks for recovery events follow an arbitrary distribution.","category":"page"},{"location":"sir/#Model-structure","page":"SIR Model","title":"Model structure","text":"","category":"section"},{"location":"sir/","page":"SIR Model","title":"SIR Model","text":"We use a struct that stores the type of the recovery distribution as a type parameter. The model state is stored as a vector of integers, representing S, I, and R. Additionally, because recovery clocks need unique keys, we define the method get_key! which retrives an integer key and increments the stored key counter.","category":"page"},{"location":"sir/","page":"SIR Model","title":"SIR Model","text":"The initialize! method uses the initial state to enable the infection clock and recovery clocks for each initial infectious person. Note that the keys are a tuple where the first element is a Symbol giving the event type, and the second element is an integer.","category":"page"},{"location":"sir/","page":"SIR Model","title":"SIR Model","text":"mutable struct SIRNonMarkov{T<:Distribution}\n    state::Vector{Int}\n    parameters::Vector{Float64}\n    next_key::Int\n    recovery_distribution::T\n    time::Float64\nend\n\nfunction get_key!(model::SIRNonMarkov)\n    key = model.next_key\n    model.next_key += 1\n    return key\nend\n\nfunction initialize!(model::SIRNonMarkov, sampler, rng)\n    (β, c, γ) = model.parameters\n    # enable the infection clock\n    enable!(\n        sampler,\n        (:infection, get_key!(model)),\n        Exponential(1.0/(β*c*model.state[2]/sum(model.state)*model.state[1])),\n        model.time,\n        model.time,\n        rng\n        )\n    # enable the recovery clocks\n    for _ in 1:model.state[2]\n        enable!(sampler, (:recovery, get_key!(model)), model.recovery_distribution, model.time, model.time, rng)\n    end\nend;","category":"page"},{"location":"sir/#Model-update","page":"SIR Model","title":"Model update","text":"","category":"section"},{"location":"sir/","page":"SIR Model","title":"SIR Model","text":"In the model update function, we use the first element of the clock key to determine the event type corresponding to the clock that fired, and apply the corresponding logic. Infection events disable and enable the infection event with a new rate, and enable a recovery clock for the newly infectious individual. Recovery events simply disable the clock associated to that event. Both events update the state vector.","category":"page"},{"location":"sir/","page":"SIR Model","title":"SIR Model","text":"function step!(model::SIRNonMarkov, sampler::SSA{K,T}, when::T, which::K, rng) where {K,T}\n    (β, c, γ) = model.parameters\n    model.time = when\n    if first(which) == :infection\n        model.state[1] -= 1\n        model.state[2] += 1\n        # disable and reenable the infection clock after accounting for the new rate\n        disable!(sampler, which, model.time)\n        enable!(\n            sampler,\n            which,\n            Exponential(1.0/(β*c*model.state[2]/sum(model.state)*model.state[1])),\n            model.time,\n            model.time,\n            rng\n            )\n        # enable a recovery event for the newly infected person\n        enable!(\n            sampler,\n            (:recovery, get_key!(model)),\n            model.recovery_distribution,\n            model.time,\n            model.time,\n            rng\n            )\n    elseif first(which) == :recovery\n        model.state[2] -= 1\n        model.state[3] += 1\n        disable!(sampler, which, model.time)\n    else\n        error(\"unrecognized clock key: $(which)\")\n    end\nend;","category":"page"},{"location":"sir/#Simulation","page":"SIR Model","title":"Simulation","text":"","category":"section"},{"location":"sir/","page":"SIR Model","title":"SIR Model","text":"We first set parameters.","category":"page"},{"location":"sir/","page":"SIR Model","title":"SIR Model","text":"tmax = 40.0\ninitial_state = [990, 10, 0]\np = [0.05, 10.0, 4.0]\n\nseed = 456959517\nrng = MersenneTwister(seed);","category":"page"},{"location":"sir/","page":"SIR Model","title":"SIR Model","text":"Next we generate the model struct and the sampler object. Here we choose the CombinedNextReaction sampler type. We choose to use a Dirac delta distribution to simulate deterministic recovery times.","category":"page"},{"location":"sir/","page":"SIR Model","title":"SIR Model","text":"sirmodel = SIRNonMarkov(deepcopy(initial_state), p, 0, Dirac(p[3]), 0.0)\nsampler = CombinedNextReaction{Tuple{Symbol,Int},Float64}();","category":"page"},{"location":"sir/","page":"SIR Model","title":"SIR Model","text":"Now we may run the model, using a function run_sir!. We preallocate a matrix to store model output. Note that in the simple SIR model with only infection and recovery events, a maximum of 2S + I events is possible.","category":"page"},{"location":"sir/","page":"SIR Model","title":"SIR Model","text":"function run_sir!(model, sampler, tmax, rng)\n\n    output = zeros(2*model.state[1]+model.state[2]+1, 4)\n    nout = 1\n    output[nout,:] = [sirmodel.time; sirmodel.state]\n    nout += 1;\n\n    initialize!(model, sampler, rng)\n\n    (when, which) = next(sampler, model.time, rng)\n\n    while when <= tmax\n        step!(model, sampler, when, which, rng)\n        (when, which) = next(sampler, model.time, rng)\n\n        output[nout,:] .= [model.time; model.state]\n        nout += 1\n    end\n\n    return output, nout\nend\n\n(output, nout) = run_sir!(sirmodel, sampler, tmax, rng);","category":"page"},{"location":"sir/","page":"SIR Model","title":"SIR Model","text":"Finally we can plot the sampled trajectory.","category":"page"},{"location":"sir/","page":"SIR Model","title":"SIR Model","text":"plot(\n    output[1:nout-1,1],\n    output[1:nout-1,2:end],\n    label=[\"S\" \"I\" \"R\"],\n    xlabel=\"Time\",\n    ylabel=\"Number\"\n)","category":"page"},{"location":"sir/","page":"SIR Model","title":"SIR Model","text":"<img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlgAAAGQCAIAAAD9V4nPAAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nOzdd2AUxd8G8Nnda7lcek9IIyGVJCQQWiD0LoJSBQFBqiBiQZEfKlgAFRRBlCJFwIZ0QaRJMYReQw8JhCSE9HLJ9d19/whvBAw1l9srz+ev3Gbv5guX2+dmZ2eW4nmeAAAA2Cpa6AIAAACEhCAEAACbhiAEAACbhiAEAACbhiAEAACbhiAEAACbhiAEAACbhiAEAACbhiAEAACbhiAEAACbZg1B+NFHHymVyifcmWXZei0GnhneGrPF8zzWYjRb+ODUnTUE4U8//VRQUPCEO6tUqnotBp4Z3hqzpdfr9Xq90FVA7fDBqbt6DEKNRlNRUfHAxqqqqnPnzpWXlz+wPSsr6/Llyw9869RoNOfOnSsuLq6/IgEAwMbVSxBu3749NjbWwcGhY8eO927ftWtXUFDQ2LFjg4ODV61aVb2RZdlBgwYlJSX1798/ISGhsLCwevuRI0eCg4PHjBkTFhb21Vdf1UedAAAA9RKEDRs2/PbbbxctWnTvRo7jJkyYsGjRomPHju3atWvy5MnV/cKNGzeeP3/+6tWrFy9eDA8Pnzt3bvX+kydPnj59+vHjx48cOfLhhx/m5OTUR6kAAGDj6iUIo6KikpOTFQrFvRuPHTtWVlY2YMAAQkhiYmKjRo3++OMPQsivv/46dOhQe3t7QsiYMWN+/fVXQsj169fPnTs3cuRIQkhYWFhSUtKGDRvqo1QAALBxIpO1dOvWraCgIIZhqh+GhIRkZWURQrKysvr371+9sWHDhnl5eVqtNisry8vLqyZKQ0JCbt269bBX1uv1Fy5cKCsrq37o4uLSsGHDevyXAACAFTFdEFZVVUml0pqHdnZ2lZWV1dtlMlnNRp7nVSrVvRurt//3upsaZWVl06dPl0gk1Q8TEhIWLFjwsJ2rGwUzhLfGbOl0OkJIzUcMzAo+OI8mk8nEYvGj9zFdEHp5eZWWltY8LC4ubtq06QPbS0pKZDKZs7Ozl5dXSUnJvTv7+/s/7JU9PDy2bdsWEhLyhJU4ODg8yz8A6h/eGvOEIDRz+ODUkenmEcbFxd24caN6wh/LssePH68OwqZNm6amplbvk5qampCQQFFUZGSkRqO5cuVK9fYjR45U7wwAAGBc9dIjzM3N3bFjx7FjxwoLC5ctW+bv79+jR48GDRr07dt39OjR77zzzrp164KCgtq0aUMIGT9+fGJiYlJSko+Pz8yZM6tnSjg6Oo4cOXL8+PGzZs3asWMHx3HPPfdc3QszcKTVLmmXBqy3HeUtJ54yysOOeNkRdyllZ7q+MQAAmJF6OfxXVFScOnVKJBJ179791KlTWq22evuKFStmz5796aefhoeHb9++vXpjWFjY9u3bFy1apFar586dO3DgwOrt8+fP/+KLL2bPnh0QELB3716RyAilimjyTTN9WqUoT8VfKiMFai5fTQo1pEjD24tIS0/Kz55yFBOFmFKIiYOYOEtIgjsV6kjVvWkAALNy+/btvLw8oat4ChRFxcbGGiULHnxlK1hCMDQ0dNeuXU84RqhUKms9n56nIscKuQI1KdeRSj1faSCVelKiJQfzOBlDhTiSDr70c/5UpDP6jvXlYW8NCA5jhObsmT84vXv3vnLlipOTk9FLqifp6embN29+YJ0Wo8BB/S4fOekbWMuIKcsz2ZV8hpKsz+RGHeIylPzEKHpqLOMm/e++AAAWg2XZhQsX9ujRQ+hCnlTXrl3raYVxBOFjMBQJcqCCHEgnX4YQUqAm41LY0N/005swvQKoCCeKxnlTAABLhiB8Op52ZHMX5mo5Pecs98NVLruKD3ei4lypkWF0Ox9EIgCA5UEQPotwJ2p1O4YQojKQq+V8aj7ff58hxoXq6Eu396FaeFJia7i9FQCATUAQ1olcROLdqHg3alQYvT+P33+bm5TKNXSkNnZm0D0EALAICELjsBORnv5UT39GZSBddhoifjcke1NtvalhjTCGCABg1nAKz8jkInK4t+jnDkwzD2rhRc5ljX74ATZfLXRZAADwEOgR1oum7lRTd2pcBF2sJdNPsJEb9AxF4t2oNxozvfzRRQQAeBDP85mZmSUlJb6+vn5+fqZsGkFYv9ykZGkbZmkbpkBNDuRxww8YPohnXo+mMYQIAFAjJyend+/elZWV/v7+169fj46O3rlzp8laRxCaiKcdGdiQTnCnRhxk12dyE6LooSE0xg8BAAghM2fObNy48Zo1ayiKIoRcvXrVlK1jjNCkQh2pA71EU2PppZe5Tn8a7mDsEACAkLy8vODg4OoUJISEh4ebsnX0CE1NTJMXgui+QfTbR9kmm/RxrpSPnGrsSk2IpO3xbgCAcM4W80UaUzTkJiPxbvedEBs+fPiIESMuXLiQnJzcrVu3yMhIU9Tx/3DoFQZFyFctmbERdFYlyVPxu3P5+M2G71ozHX2xZhsACOP7y1ym0hS3YQhUUD+0Ze7dMmjQoMjIyPXr12/evHnq1KmjR4/+/vvvTVBJNQShkCKcqQhnQgj1ShhZk85NO8GqDGR7N6ahA8IQAExtaRvm8TvVm9jY2NjYWELIqVOnmjdvPnbs2Pj4eNM0jTFCczG8EX2yr2hiFJ20zTA/jdNxQhcEACCEJk2ayGSyiooKk7WIHqF5mRhFN3ah5p5jf7/BbejENLBH1xAArN/w4cMDAwNbtGghEolWr17t4+PTrFkzk7WOHqHZaedD7egm6uBDxW0yTD1WLzffAgAwK5MnT+Y4bvXq1StWrIiIiDh8+LC9vb3JWkeP0BzRFJmTyEyNZeI2GexE7MwEBlfQAIAVa9asmSm7gA9Aj9B8uUrJsT7M7lz+o9PoFwIA1BcEoVnzlVMbOzG/ZvAbbuDiGQCAeoEgNHd+9tSP7ZhJqeyWLGQhAFin/Pz8yspKoVpHEFqA1l7Utq6icSns/jxTzHUFADCxfv36/fTTT0K1jiC0DM09qF87ivrvNUw5ypZoha4GAMCKIAgtRgcf6soAcbmONN6of/c4e6EUvUMAACPA9AlL4iEjq5KZowX0tizuhT3sxf4iCb7JAICR6G5cZMtLTNAQ4+QqCY42QUNPCEFoeVp6Ui08mXMlhp5/Gda2F/nIhS4IAKyC+nyqobTABA0xTu4IQqgripANnUQTDrNvHGHXdxJynVwAsBpOfcYIXYIwcGbNUtmJyPdJTIGGD/jFMC8NMysAAJ4ReoQWzE5EDvQSnS7i22439A+ignDzJgCAp4cgtHjx7tQb0XTzrYbBIXSAgnqzMc0gEAHAoowYMaJJkyZCtY4gtHgUIbMTmZdC6D25/LIrXE4VP685I8I5bwCwHGPGCDk8ieOllYhxpd6Kof/uxWRWkMYbDZV6oQsCALAQCEKr4iuntnZlYlypWbhhBQDAk0EQWhuKkIWtmFXXuNsqLD0DAJbh9u3bmZmZmZmZd+7cMX3rGCO0Qj5y0sqLOpTHDw7BZTMAYAEGDRp069YtDw+PvLw8FxeXTZs2hYWFmax19Ait06gw+u1j3KzTmF8IAJZh+vTpJ0+ezM7ODg8P//DDD03ZNILQOr0QRK/vxKy9zu3IxglSALAYNE03b948OzvblI3i1KjVSvKivm3NjPmH3dGNiXXFOVIAeIyzBRfKNOUmaMhJ6hjvFfPAxqKioszMzFu3bq1cuXLYsGEmKKMGgtCadW9AvRtL997NvhRCzU3EkqQA8ChHc0/mVeaboCE/B5//BuGyZct+//33zMzMli1bTp8+3QRl1EAQWrnXo+k+gVT8ZsNnzRisOAMAjzA+/hUBW58+ffq4ceNKS0uTkpJWrlw5evRokzWNMULrF6CgGjlRe3IxWAgA5s7FxeWrr756//33KysrTdYogtAmdG9A7c3FFaQAYAG6d+8eERHx7bffmqxFBKFNaO9Dr77GbctCFgKAORo/fnyLFi1qHi5cuNDd3d1krWOM0Ca096G2dRX122to4Ul72QldDQDA/YYOHXrvw/j4+Pj4eJO1jh6hrWjtRXX0pWM26ou1QpcCAGBOEIQ25KcOTAtP6vdMnCAFAPgXgtC2zEpgZp5mdYhCAID/hyC0LQnulKcdtfkmkhAA4C4Eoc35phUz5Qh7phjTCgEACEEQ2qAOPtRbMUyvXYZyndClAACYAUyfsEVTY+nrFXzcJsOMeHpkGI2l1wBs086dO018n4e6yMnJqadXRhDaqKVtmGMF/Hsn2E/OcJOj6Tcb0zTiEMCWDBo0KDU19dSpU0IX8qSSk5MjIyPr45URhLarhSd1oJfobDH/8gG2kSN5PhDnyQFsyIgRI0aMGCF0FWYBxz5b18SN+iiBnpiKW/gCgI1CjxDIgGC6REumn2C7NxBhvBAAbA16hEAIIWMjaF85GXGQFboQAABTQxACIYRQhGzuItqZzf2Yjrn2AGBbcGoU7pIx5KcOohEHDfFuVKwrzpACmC+O56v0VdU/V+qr1CqtgTNUPzRwrNqgrtmzSqfiyd3hfy2r07HPPn1Yx+q0j3y6gTOoDZrHlK2renQrSt1j7ser0qsaOPqOih366N2eCoIQ/tW9AfVGNPPdJW5JG0boWgBsmtqgUenVKr1KZVBX6qoqdVU3y7N3ZOzJryoghNAUZS+2r96T53m52E5E3z2Yi2jGTvTvvdbsJXKK3P1eK2UkEkbyzCVJGIn0kU8X0SI7kewRO9AU5SBVPLoVXwfvR+8gF8vdZM6P3udpIQjhPi8GUV13cioDkeNPA8CotKyuQltRoatUapXlWmWlvkqlV6v0arVBXamrUulVSl1VsbqkTFterq0Q0WK52E4usrMXyxUSe7lYHujo936rN+K9Yh54WaVS6eDgIMi/yGrgaAf3CXem2vlQz+82/NldJMEIMtiAKr2K47man7UGrYbVVuqqnvZEotagrdKrVXpVlV5Vqa+q0qtUepVSV1mpq1LqKpW6KkKIo0ThKHVwlDg4Sh0UEnu52E4ukjtJHf0cfOQiO4XE3tXOxUXq5CRzEtM4OJsO/q/hPhQhP7Zj+u1l++w2rEwW+ciFLgjgmbA8q9L/O1Sm1FXeLL9VrC4lhKgNmhJ1aammrFBVnFF6U8fpGOruWIBcLJcyEjuRzF4ilzISKSN98hYljMReLLcX2zlIFd4KT3uxXC6WO0gUCom9g0ThIFE8+rwiCAhBCA+iKfJbJ2ZyKhv0q/7DBOZ/TdAxBDN1pTg9vTSTEKJnDXeq8m9X5qv0KkJIsbokrzL/3vEwhcQ+0NHfQ+5GCJGJpG52rkFOAW52LsHOge52rkLVD2YCQQi1kNBkSRtmbATdZachSEGGhiILQWA6VnerIudo7qnT+ecJIVpWe7M821HikOAdSxFKRIu87D2i3SMUEntCiIvM2d/BV8yIha4aLAOCEB4qwZ36o6towD62TyCtwCEFTEWlVyt1ygJV0Z2qgrSCyxeLrhSpSqr0qgYOPtEeEYMi+4pokZgWBTkFOEpxkQgYAYIQHqW1F9XDn2rzh+Hsi/hTAWOq0qv23jyYV5lfoikr05SXacqrryup1FdJGYmDROFl7+Fl79nQObB3o27udq4uxr5iHqAGjm7wGMvbMrKV+pwqvoE9ZtmDEfCEv1p8fdqBT2I8IqPcw4OcAlxkTs4yJweJonqqQM2lKwCmgSCEx6AIGR9Jr7jKf5SAIIQ6uVme/fnRbzLLslxkzq8ljOoa3F7oigAIQRDCkwh1pK6V4yZN8Oz0rD6t8PKXx759KerFrsHtZY9cfwTAxBCE8Hi+crLyGp+vJl52j98ZoEaBqujHtF9P3zlfpC7xc/AZFz+ifUCS0EUBPAhBCI/XJ5D+K4efeoxd0x6DN/B42RW55wou7L156HrpjRfCes1p/0EDB18RjT8eMFOmC0KNRnP79u17t3h5ednb2yuVysLCwpqNfn5+Uund1RzKy8vT0tICAgICAgJMVif8l4gmHybQMRsNLM/gzr3wCGmFl367vOVcwcUw15DBUS9EuYVjhgOYP9MF4eXLl/v371/9M8uyWVlZe/fu7dSp04YNGyZNmuTtfXfF8U2bNsXFxRFC9u/fP3DgwLi4uLS0tNdee+2jjz4yWanwX/72lFxEzhXzCe5IQqiFxqDZc/PgsjNrxsWPeLfl644S5B9YDNMFYXx8fEZGRvXPW7ZsmTRpUvv27asfdu7ceevWrQ/sP2XKlDlz5owePfrmzZuNGzceMWJEUFCQyaqF/5oczcw8zW3rihNccJ/00sxvTixLL82Mdg+f12lWuGuo0BUBPB1hxghXrFjxyiuvMMzdQyrLshkZGe7u7k5OTtVbrl27duXKlSFDhhBCgoKC2rVrt2nTprfeekuQaqHaa1H05+f0GRV0iCM6hUBO3TmXq8wrVBUfyk5N9m/9VaeP63KvOwABCRCEd+7c2bVr19dff12zJSUlpXfv3llZWV27dl2zZo2Dg8OtW7e8vLzk8rv3PggKCsrOzn7YC+p0upSUlMzMzOqHHh4esbGxD9uZ4ziO44z0T7EtCoZMaUy/+g+7vQtdH3crxFtjtqrfl5p3p0hdsvbC+uN5p5t6x3nK3cc2GdHCJ4GmaLx9gsAH59Fo+vFLJQsQhKtWrUpKSgoNvXv+pG/fvsOGDROJRCUlJb169Zo5c+b8+fPVarVE8u+3S6lUWllZ+bAXrKioWLJkiZ3d3Uv7Y2NjP/3004ftrFara3qi8LQmhpDrpaK22+n1bXU+xp5KgbfGbOl0OkKIwWAghGy6vmND+h8d/dt8lfyxk8SxegeNWiNkfbYNH5xHk8lkItFjkk6AIFyzZs306dNrHrq4uFT/4OrqOm7cuO+++44Q4u3tXVJSUrNPUVFRcHDww17Q3d193bp1ISEhT9I6z/MKheIZS7d5CkLWdiLvHWeb/ilNfV7U2MWY50jx1pgtnU7H8dzhOyf23jiYX1WwuNvn/o5+QhcFd+GDU3emDsJDhw7l5eX169ev1t/evHnTzc2NEBIZGWkwGC5cuNC4cWOe5w8fPjxo0CDTVgoP9XlzxldOjTjIHnked7G3frtvHFiT9lu2MreJV0y34A6dg5IxFghWxtRBuGLFipdeeqlm8I8Q8sEHH/j6+vr4+Jw5c2bevHkbNmwghCgUirFjx7766qszZsz4888/ZTJZ9+7dTVwqPML4SHp3Ljc5lV3SBudkrNaBW4e3pf+Vo8ybmjgxziP63tEKAGti6iAMDQ2tmU1YrWnTpjt27CgrK/Pz8zt06FDTpk2rt8+dO3fx4sVr16719/f/+++/cRLcrEgZsrQNk7DZ0MiJmhRFS/HmWBGO5w/eOpyae+J6aeaImMGt/BIpVuiaAOoTxfMWv5hyaGjorl27nnCMUKlUOjhgqq9xnCvhhx1gR4fTk6ONcIYUb405KFIV/3Rpw8m8c638mg2OfMHVzoX8/8Uy6BGaJ3xw6g4jPPDs4lypxa2Zz86yFv9lCgghhBSrS0f+OZnluC87znwtYVR1CgJYPQQh1Elbb8rbjtqZjSi0BsvO/tglqP1bzSd423sKXQuA6SAIoa76BlIv7DFcKUMWWiqO587mp809uvBS0dUxTYYJXQ6AqSEIoa5mNWXeiqFnncHaFpbqt8tb5h3/zsPObX6nT+xwy1ywPbgfIRjB/5owvj/rK/WMQix0KfA09Jzh10ub/szYOzru5U5ByUKXAyAM9AjBCBRiEqigllxBp9CScDw/J/XrM/lpk5uN7RDYVuhyAASDHiEYx/yWzP9OsO/E4KuVBajUVX1xbFFOxW2Kor/r9oUUK8WAbUMQgnE096CulfNalmByvZlLK7z06eGvkgNaD43u7+/ghxQEQBCCcThLSJwbte8239Mfdys0UxU65Uf/fH6tJOOtxAkYEQSogRNZYDTRLtSpIkyiMFMHb6UO3TY+3DV0Xe8lSEGAe6FHCEbzYhA96hA7JoL2NvatCqEueMIvP7t2f1bK3PYfRLtHCF0OgNlBjxCMposfFe9GfXkeKzSbl8+PLDx55+zSHvORggC1QhCCMX3Zgl6bzp0txglSc/HlsW9P55+f12GWowTrMgPUDkEIxhTuRM1MYN47jk6h8IrVpVP2/u9i0dU1zy12lCIFAR4KQQhG1j+YPlHE6zC3Xmj7s1JcZM4/9Fggw6ppAI+EIAQj87QjYU7U2nQkoZBYnt1782C7gNYiGvM6AR4DQQjG924sPf0kuzsXI4WC+Sf7qIEzJPu3EroQAAuA6RNgfC8G0WKaTEplrw3AH5gANAbtsrNrxjYZTlP4pgvwePicQL3oHUDrWHIS8+uFkFZ4yV4sbxfQWuhCACwDvrBDfRnWiPo9k2vmjjEq07lVkfPDuXXpJZnPN+pOEax1B/BEEIRQX1p70rPPYR6F6XA8P/3gZ71Du/Vt1DPGM0rocgAsBoIQ6ktrL+p8MZ9dxfvbo2tiCkdyTzhKHAZF9hW6EAALgzFCqC9OEtI7kF55FcOEppBZlvXV8e8GRDwvdCEAlgdBCPVoeCN67XWORRTWM41BMzPli0GRfTsEthG6FgDLgyCEetTVj1IbSModJGH9Ss094WbnMiCyj9CFAFgkBCHUr/eb0AP2GfJUQtdhvTQGzYpzPw2M6IvLRAGeDYIQ6tekKHp8JN3jLwNOkNaTny9tDHUJbuXXTOhCACwVghDq3aymjIYlJwuRhMZ3rSRjy7WdryWMEroQAAuGIIR6RxHSzofCKjNGl19V+M3JpWOaDPOy9xC6FgALhiAEU2jiRn1xnjucjyw0mlsVuWN2vukkdewZ0lnoWgAsGybUgymMjaAJISMOsif7ipwlQldj+f7K/Hv95S3dG3bESVGAukOPEEyBociESLqrH5W8HVfN1NW5govLz60dH//K+PiRQtcCYA0QhGA6i5OYYg25Vo4kfHY3yrKmHfh4eOOBzX0TaArzJQCMAEEIpkMR8n4TuuVWw4+4f/0z4Xhu/vHvh0T169Ooh9C1AFgPBCGY1KQoen0n0VdpCMJn8enh+ZX6qqHRA4QuBMCqIAjB1Dr6UrlV/OUynCB9OtdLb5zOT1vSbR7OiAIYF4IQTE1Mk7ER9NRjuFXh0/nm5LL+4b1lIqnQhQBYGwQhCOCjBCa7ioxPQRY+qYyym/lVBS9Fvyh0IQBWCEEIApAy5M9uzK+Z3LrrGCx8DJ7way+sf3PvjP4RzzMUI3Q5AFYIE+pBGH721MHnRJ3/NMgY0j8YX8geas+NA/tuHvo0+f1Yz2ihawGwTjgAgWDiXKmPmzIbbuCqmUfZfn33uPhXkIIA9QdBCELq4kdtyeKQhA9zrSQjrzI/3itG6EIArBmCEIQU6kg1cqQmpeKqmVrkVxWsufBbK79EXCkKUK8QhCCwfT1Fa9K5Eq3QdZiZ7dd3v7H3fz72XqPjXha6FgArhyAEgXnakX5BdOwmw/Zc/DXedaeqYPnZtVMSx01s+qqj1EHocgCsXC2HHo7jMjMzy8vLTV8N2KbV7Zj34+hl6biGmRBCrpdmTtz1br+I51r6NhO6FgCbUEsQ3rlzJyQk5OTJk6avBmzW8Eb0iWLKYPOzCjmen37ws6HRA4Y3HiR0LQC2opYgdHFxEYvFpi8FbJmDmLhLSXqFrV9AuvL8T55y9z5h3YUuBMCG1BKEdnZ2gwcP/uGHH0xfDdiyZm7877Y9p/BOVcGOjD2jmwzDCjIAplT7qEzr1q1nzJjRsmXL5557ztPT895fjR071iSFgc15L1rfdR/tKiWTomz0qpnPjy7s0bBTE8/GQhcCYFsonq/lO7i3t3d+fn6tT6h1f2GFhobu2rUrJCTkSXZWKpUODrgMzxwplcqTlYphB9hL/UWOtndu/ujtkx+nzPtjwE9m2B3U6XSEEIlEInQhUAsc0+qu9h7h1atXOc7mr1sAk+vgQ7X2pAb/bfijq4ixsZvufX961bstXzfDFASwerUHoZOTk4nrAKj2UwcmcoPhTDHfzN2GknBX5t+EkGT/VkIXAmCLHjpzS6/X7969++LFiwaDYfr06YSQK1euyOXygIAAE5YHNkdMk76B1Jp0rpm7rfSNOJ7fdG3HmCbDacpGB0cBhFV7EN6+fbt79+5paWlSqdTd3b06CJcvX37kyJHU1FTTVgg2p38w/dwuQztvqp9t3J7pakl6qaastV+i0IUA2KjaDzRjxoxRq9UnT57866+/ajYOGjTo2LFjWHEG6ltLT+q7JObd45zeNsapD2QdbunbDN1BAKHU8tmrrKzctWvXggULmjZtSlH/jtOEhoZyHJednW3C8sBGvRBE+9qTofut/K4UOlY37cDHx/JOvxT1otC1ANiuWoKwoqKCZdmGDRs+sN1gMJD/v5AaoF6JafJrByYln7tcZnbTdYzoWklmjjLvm86f+Si8hK4FwHbVEoQeHh729vbHjh17YPuePXtEIlFoaKhJCgNb52dPtfGiTxVZcxBmlN1o7BHpJHUUuhAAm1ZLEIrF4qFDh06bNm337t3V0+c5jtu+fftbb73Vv39/R0d8aMFE4t2pvbm8Fd/A/u+slCRcIwMgtNqvGp0/f/61a9e6desmk8kMBoOzs7NSqWzSpMmiRYtMXB/YsqEh1IB93OC/2fWdrHAqxek75zNKb8R5YUE1AIHVHoQKhWLfvn1//PHH7t27CwsLFQpF+/btBw8ejDWWwJQCFNSh50TBv+nPl9CxrtY2v/7PjL1jmgxzlGBxLACBPXRCPU3Tffr06dOnjymrAXiAlCHDQumV17gFLa2qU1iurTh558wrsYOFLgQAHh6EhJDz58+fOXMmNzfXy8srJiamefPmJisLoMbEKLrlNsOoMOvpFGoM2mkHPukS3KGBg6/QtQDAQ4KwvLx86NChO3bsuHdjUlLS77//7uPjY5LCAO4KUFA9/emv0rjV7aykU5hWeKlSV/VKDLqDAGah9sUsRo4cuX///i+//PLGjRsqlerWrVtLliy5cuXKiy9i2i8I4NvWzJECfvkVK+Xh1ZEAACAASURBVFlpZmfG3uSAVvZiudCFAAAhtfYIKyoqtm7dunz58lGjRlVv8ff3HzduXGBgYI8ePdLT0xs1amTaIsHWyRiyqDXz4Sl2TITFr0OWXZF7PO/M+hYrhC4EAO6q5bCi0Wg4jktKSnpge5s2bQghVVVVpqgL4H6tPamLpfxtlcVPKtx0bXu/8N5ysZ3QhQDAXbWvLBMWFpaSkvLA9n/++cfFxSUiIsIkhQHcRyEmk6LoN49a8NlRPWf48J+5uzL39wzpLHQtAPCvWk6NUhS1evXqwYMHl5SU9OvXz8vLq6ioaOfOnZ9//vnatWtlMpnpqwQghLwUQvfZw2pYIrPMi2bO5qdlV+T+3GepsxQ3vgYwI1T1ImqEkFWrVtUMCj5Czf7mIzQ0dNeuXSEhIU+ys1KpdHDAFGZz9Ni3xsCRF/YakrzoaXGWN1LIE37ynuk9G3bqYYHdweql9rGehnnCMa3u/u0RNmvWbO7cufXaWFZWFsvevbGOvb29l9fdFfdZlj1+/HhlZWVSUpJc/u+ldPn5+WfOnPH394+Ojq7XwsAiiGgyuCE95xz3VgwtsbQoTM05kau83SkoWehCAOBB/wZhTExMTExMvTaWmJjo6elZfXK1U6dOn3/+OSFEo9F069atoqLCw8Nj9OjRhw4dCgwMJITs3Llz2LBhbdq0OX369KBBg7788st6rQ0swtBQevElbuFF7p0YS0rC7dd3/3Bu7fTWb0oYdKoAzM6jVpapDxs3bgwPD793yy+//FJVVXX8+HGxWDx+/Pg5c+YsWbKE5/m33357wYIFL7/88u3bt8PDw8eNG4c7QAEhZF0HJmqD4fkAKszJYhaaOZxz7O3mE5v7JAhdCADU4qFBePjw4S1btuTm5lbfj7fG+vXr69LezZs39Xp9aGhozUU3mzZtGjhwoFgsJoQMHTq0X79+1ZP3MzMz+/fvTwjx9fVt37795s2bp06dWpemwTo0dKBeaURPPsJu7yoSWUK3UGPQXCq69mbzCUIXAgC1qz0IP/vssxkzZjg7OwcEBFRHlFFIJJJp06Zptdr8/PylS5dW51x2dnZAQED1DgEBAYWFhWq1Ojs728vLqyYsAwMDc3JyHvayGo1mx44d3t7e1Q99fHz+OwmyBsdxHGfBl+BbsSd/az5pSvXZw49LMXRrQHXyoVyk9V3aM9KyuhN5p3fd2B/uGuouc7XcP7zqyi23fuuGY9qj0fTjvy/XEoQGg+HTTz8dN27cwoULjXud2OXLl6uvbvr9999feeWV9u3bu7u763S6mqytbk6r1Wq1WpHo39okEskjJvKrVKodO3YoFIrqh2FhYU2bNn3Yzlqt1ojRDkb05G+NPSG/tKHePc3MPEXO+HMfxJrpUWD28QWF6uIYt8jBES9oNBqhy3l21VeN4mhrnnBMezSJRHJvmtSqll+XlpZqNJoxY8YY/Wrpmmt8BwwYMGnSpPPnz3fs2NHb27uoqKh6e2FhoVwud3Z29vHxKS4urnliYWHhI2ZHuLq6fvfdd084fYJl2XsvTAXz8VRvTaCc/NaZZCr55lsMExpLAxRmN164Ou2XC8VXfn9hpZg29Ui80VUfRzB9wjzhmFZ3tfQZ3d3dg4ODr1+/Xn+tFhQUlJaWVk+faNWq1cGDB6u3HzhwoFWrVoSQqKgoiqJOnz5NCOE47tChQ61bt66/esBCNXSgkn3oowVmN7dVqatcf3nrwi5zrCAFAaxe7SvLLFmy5PXXX/f29k5OTqYo43zXTklJWbduXWJiolar/f7777t37149O3D8+PGxsbGffPKJr6/vrFmzfvrpJ0KIXC6fOHHiqFGj3nvvvT///NPNza1zZ8ubhgwmkOBGzTrNRTpTMeZ0t8I5Rxb0CukS4OgndCEA8Hi1f11t06ZN06ZN27dvL5PJ7OzuWx24pKTk2Vpq1KhRw4YNU1NT7ezs3n333Zdeeql6u7+/f2pq6rJly7Kzs9evX9+pU6fq7R9//HFwcPDu3btDQkK++eabJxnwBBv0bhyt1POjDrEn+ppL3+tI7snMsqxZbd4TuhAAeCJUrUum9e/ff/PmzR06dIiMjLS3t7/3V/W9+swzwBJr1uGZ3xqOJzEbDZ83Z54LMItO4RdHFwU6+Q+K7Ct0IUaDJdbMGY5pdVfLl+jy8vJNmzYtWLBg8uTJpi8I4GnRFPkogZ5xku3aQCT40muXiq4duX3y1biXBa4DAJ5YLYcNlmV5nq+++yCARXghiC7Xk5ZbDaVagSu5VHQ11iPKzc5F4DoA4InVEoSurq6tWrU6dOiQ6asBeDZimpx7UdTIiVp0Sci5bhqDduX5n3qHdhOwBgB4Wg9dWWbkyJFqtbpLly6urq73/qphw4YmKQzg6TiKyftxdNIfhsnRtLNAg1kXCi/7O/o182kiTPMA8Exqv1jG29s7Pz+/1ifgfoRQT4zy1vT4y9DBl343VoChQo7npu6f2cy7yUtRL5q+9XqFi2XMGY5pdVd7j3D58uUWvSIU2KwpjZmZp1lBgnDthd/Vek3/iOdN3zQA1EXtQdi7d28T1wFgFK28qOwqsuQyNz7SpFlo4Ni/Mvd9kjwNS8kAWByhLzYHMCpHMdndg3nvOJtebtJz+KvTfrEXywMd/U3ZKAAYRe3fXgcOHFhaWlrrr/bs2VOf9QDUVZQz1TuQ/juPb2SqO/dyPLfv5qEPkt4WM7gJAIDleaIeYVFRUUpKysmTJ+u7GgCj6BdELb3MaVhTtKVn9avO/+IkdYxyDzdFewBgbLX3CP97G/o7d+7079+/Z8+e9V8SQF09H0h/eZ7bd5vv5V/vncJfLm86nnf6LdyAHsBiPekYobe399dffz19+vSKiop6LQig7hiKDGxI/5Zhisn1V4uvD4zsG+4aaoK2AKA+PMXFMv7+/hqNpl7vUwhgLK29qLTSer9exsCx6aU3Qp2D6rshAKg/TxGEK1euJIQEBgbWWzEARtPEjcqq5BM2G4rqc0Ls50e/CXEOCnBqUI9tAEA9e9KrRm/cuJGRkTF48GA3NzeTFAZQJxKa5LwkfuUg+8Ep9vskpj6aSCu8fKHwyvIeX1PELG7/BADP5ol6hBRFJSUlrVu3bt26dfVdEICxyEVkWhy9N5fX18NYYX5V4edHF3Zv2FEhsX/83gBgxp70qlEASxTjSnE82Z/Hd/Uzcqdtw9U/4jyjR8QMNu7LAoDpYWUZsGZimrzRmJ59luWMfd1MSvbRF8IwmwjAGtzXI0xJSXnsWtudO3euz3oAjOy1SHrxJW7vbWN2Crem76zQKUNcgo31ggAgoPuC8OWXX87Kynr0E8zwNkwAjyCiyaQoevgBQ/ZLYrExzoDcLM/+4ey6BZ0/wzUyANbhviBcvHixSqX6704Gg2HlypV79+6laZxKBcvzejS9Op3beIMbHFLXP+AKrfKTw/N6N+rWyAV3qAawEvcFYa9evR74Nc/zGzZsmDlz5rVr1zp37vzFF1+YsDYAo/m6JfP8bkOII5XoUadu3A/n1gU4NhjeeKCxCgMAwT3qC/LevXsTExMHDhzo6up64MCBPXv2xMfHm6wyACNK9qaGhdLvn2DZup3aP5SdOqbJMJlIZqS6AEB4tQfhsWPHOnXq1KVLF41Gs379+iNHjrRr187ElQEY1yfNmPQK8sPVZ59UWK6t0LF6b3svI1YFAIJ7MAgvX748cODAVq1aZWRkLF269Ny5cwMGDBCkMgDjcpaQT5vRU46wn555xiw8dedclHs4TeEaGQCrcl8QTpo0qXHjxikpKYsXL05PTx87dizD1MvaVACCGBZK7+0p+v4yd/Hp1+P+K/PvxadWDIh4vj4KAwAB3XexzPbt2zmOc3Z2XrFixYoVK2p9Am7PCxYtyYvqFUAlbzdMjWXejqGfcEJFhU759Ynv57b/MN4rpp4LBABTuy8I27Rp06hRI6FKATCNZW2YISH02BS2VMt/3vzx5zx4wn91/Pto9wikIIBVui8IsaY22Ij2PtS69szLB9iPmxLp46KwWFVy/PbpNc8tNklpAGBqmCAPNirRg3KTkv15jx8s3Jf1T4J3rLscNyADsE4IQrBRFCH9g+kvzrH56kftVqQu2X3jQFPvOFPVBQCmhiAE2zWlMS1hSOON+r9yau8XVuiU0/Z/HOjo1yko2cS1AYDJIAjBdjEU+au76Md2orH/sIb/zC3keG7B8SV2Yrspzcc7ShyEKBAATAFBCLauhz+lEJM/sx9Mwl039l8rzXyv5etIQQDrhiAEW0cRsqAV88ZRTn9PFBo4dumZ1W8mjm/g4CtcaQBgCghCANLVj/KUkZGH/r2R/YWiy252bgnesYLWBQCmgCAEIISQHd1Exwv5+WkcIeRswYWvj3/fyq8Zbr0LYAtEj98FwAa4y8jSNky/vYZIZ+rHU1+9Gvdyp8C2QhcFAKaAHiHAXR18qM+aMTNSt/OUuFvDjmJGLHRFAGAKCEKAf7V0vezC/5ZSMe1/J1ihawEAE8GpUYC7Dtw6vODE0nebv+LmGNR/LxvhzA1vhG+KANYPQQhw15HcE0Oi+/UI6UwImdWU/uwsZy8i/YKRhQBWDh9ygLuuFKfHeUZX/zwyjP6yOT0p9TErkQKAFUAQAhBCyPG80+VaZZBTQM2W5wPp3oH0R6cwWAhg5RCEAORKcfqMg7NHxQ6RMpJ7t3+eyGzJ4g7defytmgDAciEIAchb+z4YHz/y+UbdH9juIiWzE5m559ApBLBmCEKwdVeK03nCvxjeq9bf9g2kzxTxu3PRKQSwWghCsHU7M/f1aNj5Yb91lZKVyaIRBwzHC5GFANYJQQg2rVJXtfvG/v4RvR+xTw9/6rNEZsoRnCAFsE4IQrBp5wsvRrqF+Sq8H73b8FA6u4psuPGfu/cCgOVDEIJNu1J8Pdw19LG7iWjyXRI9LoV1W6tfdx1xCGBVEIRg0w7cOtzcN+FJ9uwdQOcOES9tw8w7jyAEsCoIQrBd10tvlKhL4zwbP+H+Mob0DqBvVvJHC3DhDID1QBCCjbpZnv350YXdG3akqae4+66UIV+3ZCalskhCAKuBIAQbNe/Yt6EuwePjRz7tEwc1pMt1ZMtNnCAFsBIIQrBF5dqKzLKst5q/JqKZp32uXETebExvvsmjUwhgHRCEYOU4dWXpz/Mr9vxS8uMc9YWj1RtP3zkf6xklpp/xNmQdfKlduVyLrYYSrfEKBQCBIAjBamkuHSc8X75lmfb6+YodP6rO/VP683xtRlqFTrns7JpeIV2e+ZUjnamcl8QiivTZYyjUGLFkABAAbswLlo2tKGXLCglFqU7uc35h/L3bi5Z9aN+iW9Wx3Z5TvqYkMkomL5g3sXzr8hWtGrZukNjWv1Vd2hXTZGd30Qt7DP33GrZ1FTlJHv8UADBP6BGCJWErSlSn/i5e9Zn6fGr1lspDW4qW/K/4h5lVKdv1t2/U7KnNOM84uKjTUuXNu0gCI8S+wSJXL4+Jn19R3jpwK2VgRJ+6F+MkIes6MA5i0muXIacKI4YAlgo9QrAYnEpZ+O27hoIcxtFFm35WfS7F9eWpupuXZdHNuYpSxtlDnXZE5NmAEokNhbnlW5Y59h5l17gVxTDk/ydIiP1CDgU49y3j3Fnj/OX7yqnNXUTTTrCRGwwfN2XebIxvlgCWB0EIFqP8j5VsaYEiuY9j95eLV31qKMm/M3ccr650GzmDtndU7vu94s8f9Xk3pMFRmiunKZHYLiqRliseeJEcOZWYWVS+fZVTz+G0gwthWUoirUtVYprMb8H0CaRf3GPYmc29G8t09nuKiYkAIDgEIVgAQ3522ZZl2swLbiNnyKKaE0I8Jn7Os4byrcvtGrei7R0JIXaNW2ouHlWf/Ud99h9CiOcbX9EK5wdeR6VX3yCVbScsKlv8PuFYxsVTe+2s55sL6l5hsjd1+gXRr5n8kP2GeS2Y4Y3QNQSwGAhCMHscV7rhW13mRbsmbatTsBrFiJxfnFDzUOTl7zF5fvHqz2SRibSdvSQ46r+vdK3keohzsNw3RPz6vIKv3+B1Gopm9LkZYr+QupcZoKDejaW6N6Be3MvOPM0FKsjfvUToGwKYPwQhmLvKw9v1uRmeUxeL3H0fu7PbK/97xG+Xnv0x0SeBECL2DhB5+Ik9/BgXj6pju+8N1DqKdaXOviAq0PD997KTUtlpcbS/PdIQwKzhBA6YMY7T592s3L/RZfCbYu9ASiSuy4tpDJrMsqxh0QOqHzq/ON6pz2hpeIIu6yrheV6r5lRKYxRNFGLS0IHa21OUXs4nbDb8cQuLsQGYNfQIwXxVHd9T+tsCaaMmsugWdX+1PzP2RbtHiJm7aSpt2JgQQssd9Xey8udPIizLVZV7z1hFSWR1b4sQ4iolu3uI5qdxc89xOpY8F0BLn3o1NwAwBfQIwVzw5UWE4wgh+twMzeWThBDdratOvV91H/cJxdT1G9u+m4dWpf38WsKoB7ZTEqljt6H6nAzG2Z0Qqnz7qvLtq9iSgjo2V2NoKN29AT31OPf8boNSb6xXBQBjQo8QzALPGipXfWwIitDn32JLCwnLUmIJp6lyH2uEFCSE/H5l26CIvqEuwf/9lUP7Fw2Fuc79J5b9vqjqyE7a3kl9+gDt5OaQ3NcuPpkQUvLTl/KEDrLIZs/Qrrcd+SCefiuGfn63YfElblocvnoCmB0EIQhMuW89W16sPp/KlRWqlaW8QW8X04qrquA0VY7PjZQ0jK57ExllN3OUt/tHPF/7r2naZdAbhBCHTgMdOg5g3LzvfDpKf+taZeoOnvBVKdu1GWmGwlxKakcILw2OJk9z/8Jq9iLyXRLTfIuhysC/E8NgPTYAs4IgBAFor6eVrJkjT+wkb96lfMdqWmbvMniKhqdc4lobvS2e8CvOrRsS3U8meszEeZGHX/UP7mM/5qqURUuma9PPMY6uinZ9Kw9uKVz4NqEo15fekjfvQnhen3dT7FtL//Jhwp2odR2Yeee5w3cMr0XRXRvQjnW69AcAjMakQVhWVnbs2DGNRtOkSZPAwMDqjcXFxTdv3qzZJyIiwt7evvrnrKysEydONGjQoGXLlqasE+oVr9cVr/6UcXRV7vudU5ZJgyKd+o6VBIQblMa5aPNeWlY3ZuebYlo8vVX3J3+W2CeIEOIx6Uu2sswuqjmhaVlEU82VU9KQGOX+jfLmXTRXTpX8ONt3zsan6h32DqA7+NBTjrJfnOd+uMq9H8e088HMCgDhmW7E4siRI4GBgfPmzVuzZk1sbOyiRYuqt2/btq1z587j/l9NKG7evLlp06ZbtmwZNmzYhAlGm+YFwqo6tivvg5douYPn24vk8e1Up/YrOg6QBITXU3PLzv7oInNe0XOBQmL/tM+VBEXYNW5JaJoQIotMdH5hvCw8QX/7RukvXxUt/5DTqNRpRwzFd57qNRVi8kNbZmd3UZQz1Xu3odkWw4VSrNYNIDCKN9V9tvPz82ma9vDwIITs2rWrb9++FRUVYrF41apVW7Zs2bp167078zwfFhY2e/bsAQMGFBYWhoaGHj16NDIystZXDg0N3bVrV0jIEy0OolQqHRwc6v7PgafCVZZx6ipKLC34arIsqrmibe//LuZi9LcmJefYt6d+WNRljofc3VivmffRUK6y3C4+maKZquN7RJ4NXF9+VxIQ9myv9s4xdvkVrksDOlhBkryp5wNo2iy7iDqdjhAikWBs0xzhmFZ3pjs16uXlVfNzUFCQXq/X6/VisZgQUllZuX//fm9v7/DwcJqmCSGXLl3Kycnp06cPIcTDw6NDhw7btm17WBCC+as6tke551dOqxK5erkMfJ3Q9T6lLiXn2Nwj38xIesuIKUgIcXpuJG/Q27fqwSpLGVcv5d8bCr95y+t/K0SuXo9/8n/Ma8FMiqJPFPH/3OGnHOG+u8Rt6ixSYOwQwLSEuVhmzpw5/fv3l8vl1Q+zs7M/++yzK1euNGjQ4I8//vDw8MjJyfHy8qr5Burv75+bm/uwV1OpVD///HN1X5MQEhIS0rFjx4ftzLIsy7LG+6fAE9HlpFMSqaJ1D4ceI1iekNreAiO+NSk5x748/u2rsUMTveKN+3ZLEzoQQliWJXJH+y4vSWNaV2z7ofLwDruE9iLvwGd4QX858Q8gLwaQOU2pUf/wDX/Tz0qgXg6h5OZ0HVv1/yE+OOYJx7RHo2maetxYvgCftnnz5h09ejQlJaX64ZAhQ0aOHEkI0Wq1ffr0+eCDD5YsWaLX6xnm306DSCRSq9UPe0GtVpuWlubo6Fj9sLS0tG3btg/bubonapx/CTyBqj9XM54NNBePOU/+mnH31bNsrSlIjPfW7M9OWZ62bkrCuDZ+Ler9vXbzZQIjq/b9pjqx1+XdpXVZBI4h5MckklJAzTpLLbpITYzgCCHxbiTOhWeEPl9a/d/42KMJCALHtEcTi8X3pkmtTB2Eixcv/v777w8ePOjufveElVQqrflhyJAhCxcuJIT4+PgUFRXxPF/92SsoKAgLe+gwjIuLy5w5c55wjFCv18tkxllDCx6P40pO/c1r1U7Pj7Zv0PDR+xrlrdEYNEvPr5kQ/0rnhu3q+FJPSNp5gFOrbiU/z1eu+Mh9zCxaXqfRms4BpK0f+eg0e76cZnnywVnujWhmRjwtbBZWD1hgjNA84ZhWdyZd52LlypVffPHF3r17GzRoUOsO58+f9/X1JYRER0eLxeLjx48TQgwGw8GDB5OTk01ZKhhFxe6fRe6+Xu8tUST3MU2Lh3OO+zv6dWv40HPjRkdJZIyLp33zrvqc69qMtLq/oJQhcxOZpW2YH9oy69qL5qWxcZsM006wdx56TgQA6sR0PcKUlJQxY8b069dv6dKl1VvefvttDw+PCRMmuLq6+vn5nTlz5pdfftmzZw8hRCaTTZkyZcSIEW+++eZff/0VEBDQvn17k5UKRqG/k6X8e4PrkLdrJqqbwMKTy99u8ZrJmqshT+xEO7oULZ3hPu5TWXiCsV62pz+VN0R8tIBfk86Fr9dv7Spq40WJsEwbgFGZLgg9PDxmz55975bq8y1DhgzZt2/f5cuXQ0NDL168WDPRfsaMGWFhYSkpKW3bth07dizGJyyO6sReu+gWdk0eOl5rdGXacgNvSPZvZbIW7yULT3B+fnTFn2ukwVHGuoUFIUQhJp39qM5+zJLL1CsHWScJebMx3cGXClTgEwFgHKabR1h/MI/QHPH87Q8Gu4+ZJQmMeMJn1P2t+e3ylktFV2e1fa8uL1IXXFXFnTlj7OLauAx4vZ6a+Pwc988d7lgh721HvdGYHhVmiqmHmEdoznBMqzucZAHj02VdKd+6XOTq/eQpWHdHb59ce2G9UN3BarS9o8vgN9WnDuhuXa2nJt6Lo7d3E2W/JJ6dSM8+ywX/Zmi2xdBym2FLFm7/C/CMzGmyEliLij/XaNLPeU1dbMpGr5Vk9Anr0SlI4IuqZI3iJIHh6vOp9bduHCFExpDeAXTvAPpqOV+pJwfz+BEH2FXtyItB+GoL8NTwsQEj41RKXdZVnw9/rF662mQqtEpHifAniCipndML46tSd7AVpYQQ3qBnK0rqr7lwJ6qpO/VWDL2hs+jVQ2zIb4bmW7F+KcDTQY8QjImrLCtZ96XYN5hxNubCZo+lZXV7bhyc3+ljUzb6MGLvAEXbPgVfvyFy8bRLaFe+eal9y+7OAybVa6Nd/Kj0geIKPb8rh+/0p2F6HNPG++7gYaSzea1TA2Bu8PkAo9FmpBUvn0krnEx8UpQQciT3hIQR13oDekE4dn+Z12vVaUcq/lxj36qH6vR+h64vcSplvfaS3WXEXUZNiKRCHKkll7m11zlCiNpA8tW8k+RuKDI0aelB2YmIhCbDG9GJHrj0FABBCMZTdfQvaXiCy8DXKamdKdvNVeZ9lvr1tJaTTdnoY1CU0/OjHboM1qaft2vc0lCYW/jd+4b8W97TfxB51r6ahBF19aO6+v27ptStSt7w/+dK1QZytIBneVKiJQP2seU6vnpeUnMPqncA/Wo4Lav35dABzA6CEIyD1+vU51Lcx35C2zuast0qveq9Ax+/EjNY8Mtk/ou2U9jFtiaE2Ld5TnVst9gnsGzjd2xlmcfEL2i5wmRlBNw/4zDa5e7Dd2Ppch0hhJTq+L25/JYs7r3jrIQhhBA7huroS7XzoYIUFCHEYKDCnPiGmD0BVgpBCMah3POLyM1HGhprykYP3Dq8/Ozahs6BQ6P7m7Ldp2UX09oupjVbXpw3azgtkalO71e06S10UYSmiIuUEEJcpNTYCGpsBF2uIxxPCCElWn5LFv9b5t0pGSzLp5VRLP/vys5tvGgf+X2v1sGHcpfdjVgpQxI9KHQuwVIgCKGu2JICTlWh3L9RntDBlO1+f3rV/lspo2KHdgk20fradcQ4uTX4aofuxsXi1bNlkYkiN2+hK3qQ0//3+Vyk1Nsx1Nsxd68q1+l0LM9ryN1f51TxRwruuzBVZSArr3E1m5R6cqGElzCkieu/6fgACUO6N6CkTx+WblIq1JH4K7DWFBgNghDqqmzzEvWFI/atergMNN0o3bb0v/7JObqi5zcOEtOdYzQKSXC0yMO39Jev3CfMphiL+QAyFHG5JyZjXB+MoSmN75uLpTYQpZ78c4d72Dz/3CqyLetZpnkUaLj0cnJbdfe57jIS4kg1sKeqmw9UkAhnylFCCCEKEeVhRzxlxF2G62bhUfDXAc9On3NddWq/5tJx16FT7eLamKzdWxW5K8//9E3n2RaXgtWcnh9TsGBK1T/bFO1fFLqW+mInInYi0i/4UTOVpzQ2QkP5apJRweeqeEIIz5ObleRwPl+pJ4SQCj1XoCZFGlKk5dUGQgjxkJE4N8pFcl+K+yvIgGC6iRvO5douBCE8C16vK9+6rDL1T0bh7NB9qLyZ6W57RAg5fvt0K7/EQCd/UzZqRJKAMK93FhcsmCINTzDxyH2TigAAH1pJREFUsgPWx8uOeNlRhDzRidLbKj6thFTo7+uJniniJ6Wytyr59j4PjW17MZHQhBCiEBMxTQghDmJKRBFCiKOEVN8t0klCTLDu63+p1bSd3dMtsGcvoiQ0kTDEXkRo6u4pcUcxxVBELiLPcL7a0iEI4Snwep3q+B7t9fOcRqXPzXDuO85kNxqsUaFTbk3/c1LT0SZu17jEvsHyhPZlGxa7j/uUkkiFLsdW+MopXzl5IDUHBJPZieRsMZ9e8dBTtVV6ouMIIaRST/QcIYQo9XcnpWRVEpYnhJCaS41MzGAQiURP13CVgdNxRMsSlYFwPKm+eLhcx3OEqAxEy9ZLnUbUxpv65zljhheCEJ5C+Y7V6tP77WKT9Hey3CfOFXsFmLgAjudHbJ/UOTC5hW9TEzdtdPatehQufEeXfU0aEiN0LUCauFFN3Czy+hulUuXggO9SdYIghCelOr6n6shOr3e+NeWNdh/w2+XNCrH9xKavClWAEUkCIxy6D1WfPoggBBAWFt2GJ1W+Y7XzC+MFTMGrxdd/vrRxXseZQhVgdNKgSNWZA6qTfwtdCIBNQxDCE9FlX+O1avvmnYUq4Grx9WkHPxnXZISXvadQNRidNCRGkdy3fPsq1SlkIYBgcGoUHo+tKC39baF9656EFuZ6Mp7wi0+vGBjR57nQroIUUF9oxrH7y2LvwMp/tsmbmvTKWwCogR4hPJ7mykmRi6fT8wJcqMny7Nb0nSO2TypUFfdp1MP0BZiAJDhKn5tRfze1B4BHQ48QHo9XKRkh1gPbd/PQjxd+oyn65ej+zX0T5GKT3tTCZBgnN0WnARW7fnEfM1PoWgBsEXqE8Hiaa2dMvzDm2fy0L499Oyp2yMqeC7sGd3CWOpm4AFNyaN9Pf+tqyboveIP+8XsDgFEhCOExOI1Kc+WUfeuepmz0VkXOtAOffJw8rX1AEm0DqytTYonryBnq86nFqz7lVEqhywGwLQhCqB2nqeJ1Wn3ezYJ5ExVtept4eeivTywZHPVCc58EUzYqLGnDaK+pi/XZ6RV/rRO6FgDbgjFCeJChKE91+oD6zEGuqpytKJUERzm/OMGUBRSpii8VXZvXcZYpGzUHIg8/t5H/K1r+kTbjglPvUbIIi189B8AiIAjhPoaivPy5YxlHV/uk50SuXrSDsyQ4ysQ1LD275sWwXgxle0v/EiIJjnYZ9EbVsT1lm5d6vb0Iy5ACmACCEO5TeWCjNCTGbezHQt0qb8OVP1Jyjq7utUiQ1s2BXVxbu9g2xas/y/twiDQiQezZwLHnCKGLArBmGCOEfxUt+Z867YjLkLeFSsESdemK8+tebzrGmpaPeRYU5TZyhuuwqbxeX3V8D6/TCF0QgDVDEMJdqtMHdDnX3V79iHFyE6SAW8rcqftn9g7t1jNEsIXczIosuqX7mJkid18sRgpQrxCEQLjKcnXakbKN33lM/FwSECZUGftzUho6B42PHylUAeZJ0a5v+fZVeR8NVf69QehaAKwTxghtGq9VGwpvKw9uVp/7xz6xi7B3S79Skv5y7ABbmDX4VOxiWou9A7UZF8p+X0TL5Cae0AlgCxCEtkibeZEtzdemn9dcPsFVVTCOrt7TVzDO7gKWVKIuvV5+I8bD1FeoWgSRh5/Iw09/O7Pir7Vi32BJUKTQFQFYFQShzdHfySpaMp2wrDyxs9vomcSgF/s3okRiAUu6Xpq5LX1XE48Ye7FcwDLMnPOLEzhlWeHi99wnzJE2jBa6HADrgSC0OcXLPnTsPkwWlSj2DhS6FkIIuV15Z/Ke6ckBrSfGjhK6FnPnOuL9yoNbChe94zLgdZwjBTAWBKFt0Vw+SRiRol1foSZIPEDH6j49/FWfRj3GxY9QKrHG5uMpkvtQYknF7p+1mRfsYlrJGrcyk7cSwHLhI2RDtJkXy7evcuo5wkwOnTfKst7++8Nw10ajYocIXYvloCj71j15njPcvlny03yKZrxnrKQV1nxrDoD6ZhYHRDAB1ekDZb9/K3L3kUU3F7qWu5afWzs48oWBkX2FLsTyKJKeIxwnb9658uCWip1rnQdMEroiAAuGeYQ2QX3un4rtqxy6DfF8ayElkQldDiGEcDx3ruBix8C2QhdisWhaEhjh3H+S+vJx7fXzQlcDYMEQhDZBc+mEvEVXh/YvErOZpff96VXxXjHucmFWsbEatFzh1PvVkrWfs6UFQtcCYKkQhNaPZw3qC0fliWa0btnuG/u3Z+weH/+K0IVYA3mTZFlkYtGKWZWHtvKsQehyACwPxgitnPbaGe2NyyJXb5Grl9C1EEJIdkXuivM/XSq69nHbaQ0cfIUuxypQlFPfMSWrZyv3b+T1WodOA4UuCMDCIAitmf5OVvGPc6TBUc4DXxe6FnKx6MpXx5eUakpjPaN/6PG1o9RB6IqsBy2zdx//me7WtZLVnymS+5b+Mt++VU9pozih6wKwDAhC66TLTi/96UveYHDsMVzR5jmhyyGFqqI39vzvhfBeo+NeljISocuxTpKAMJGX/51PRhCa4TkOQQjwhBCE1qly/0aRdyDhicIM1h/ZeHX7zoy9Cd6xExOwdkz9chs5Q332H2loXN4nIzRXT8vCE4SuCMACIAitkOrMQfX5w55TF4u9AoSuhfxxfdf6y1uGxwzqGtRe6FqsHyWRyZt3IYS49J+k3P2LLCzefK4TBjBbuGrUuvC8cu9vZb99I2/exRxScN2F3xedXP5Rm3d7hXQRM0Ku621r5M27sJVlmssnhS4EwAKgR2gN9LdvVB3eobl+nhJLaInMZcg7drGthS6KZJTd/O3KliXd5zd0NovVvW0KJZbYt+imvnBEFpUodC0A5g49QgvHcbpbV/O/fI3TqV36TxR7B7iP/0zYFDRwbErOsUFbRk/4650uQe2RgkKxi03SXj9f9P10Q3Ge0LUAmDX0CC0Yp6kq/OZttqLELqaV69CphBDBLxS8XXnnu9MrrxRfn5AwsrlPvL3YXth6bJnI3cf7/eVFyz7InzvO693vRR5+QlcEYKYQhJaK01SV/jRfEhjuMvhNoWu5S6VX/+/gZ3Gejb/qNCLAEYddM0BR7uM+Vf69oeCbtz0mfCb2CxG6IABzhCC0TDxfvOxD2sHV6fn/a+9Ow6K40j2An9p6b7pZpRsFUUAFtyig46iI+4IaFU3MjEs2STQZE+7MY9SYyc3jOBkzSxIz0asmJpqYxFyziI6CZjSgAURjRCCMgUhUGrtZuqH3ruXcD+0lBjdUpBrq/X2qzfbfT1H91qlTdepJsaNc1exteeHYK0lh/Z9LyRI7C/gF7fhMOqRH/durg6Yt1vx6BtxHCkAbUAi7Hk/FSfe5QsHtDH/2r4Hzo/Zi/p+DFfqVUAUDknLoGCaqT9POV12nj8pi+ulmLCUYGNYAgKugEHYZvK3ederf9qN7SYVa/esZ2kkPB0gVFDDeWLzJ7Kx/Lf2PDAl/UQGKDo+KyH6z+V/vs6Ya88anw578b8xzBCOnwwxiRwNAZPCz1TUILkfDlhdJdVDIb/4gjx8SOKfzrMCty9/g8Lm2T/+Hgg6INx2CmyII3YylCCFn4UHL339HyBSIICKef53Sh4udDAAxQSHsAgSHreF/1imSUnUzHxc7yy9UWS/srtjb4Gr655SNMIJoF6L+1TRZnyQ6JNJx7LP6t1apUiZqx80h5EqxcwEgDiiEAQdzLEFfMwiLwDfufFXWd5AuI4AG6vTyvi9/OPju2Q/n9sv4XfKTUAW7HP/AQ9pJDzM9+7bkfYR9blnvREqjk8Umih0NgM4GhTCwcJbL9VvWKOKHBi/MRghxDXXN+7YTJKWb+ViA9AgihC40X8z+al2UJvLVceuG9hgkdhxwTxQDUgRHi/3YXnfpN9jrjvivTZQuVOxQAHQqKISBgm9udJUcsR/7TJ06yV1e7F9S/0Y2begd+tiLBBUQe8rqaS64VLjlzHvLhz2WETdZ7DigY6hSJqhSJiCEWg7utH22OfTRF8VOBECngiHWxIe9bnfpCfNrKzirJSxrvXrEFMTz1j1vml/NUo+dFb78z6QiIMZnOX3l7G/2ZRVcKloz6nmogt2SdsIC1nTB8ka270KF4HGKHQeAThIQ7Qxp8lads+39J9dkRggxhpjQpWvlcYMQQlyDiWswUSE9Ite9R6o04oYsrD21o3Q3QojHvM3T/Gzyk9P6TBA3Erh/CJkicvU2Z9Ehy6bfExStHDpWO2EBEyn+a0wAuK+gEIoAsz7nif0tR/YEZ65QDEhuc7ceHWaMfOl9OjhC3E5BH+/7+PvPd5fvXZm8rE9wb4RQT61RzahEjAQ6A0mqR01XDh7FO5pdJUcatqyhw6O0Dz2PaBkmNIHz3A4AHQgKYecSePvRz+yHP5bHD45Y+bebjYNMh/To5FzXYnl27/n9n3z/RVxw7DvT34jSwgPXkkNq9KRGr5v5uC7jseZ/vd/092cxz5FKjeqBsZq0OZQ+TOyAAHQkKISdR/C4Grf/ESEi4g9v0aEBWl0a3db13/yt2dPyl3EvxQXHkgT0IksbQehmLFWMnYNIirRZXN8es/xjpX7ecnncENGv2wPQUaAQ3neeytPus8c58yXWdEE5LC04cwUiKbFDtVVSd+bbK6XN3pZC06leWuPmqX+FRwNBK//Veyaqjy6qj7zvwOZ973CNdUHTl6iGj6eCgsVOB8C9gkJ4vwjOFmfhQU/laa6+VjvpYdXwdMYYS6q0Yuf6BYzwrrI9PzVfPmn6dl7/jN6KXgsGPGjU9JBBFQQ3oUhMlfcbxjeZm3b/zfHv/xXcDsYYG/zw84wxVuxoANwlKIQdz3HsM0f+l4LbKeszUDvpYVl0AqkMuItIOVW5n//ngNlVHyTTPpI0b/HABTG6XmKHAl0DQdF0eFTEyr8jhDDHtuR+2LB1HanUyBMeCJryG7hkCrocKIQdR+B9l35wnyt0nz0e+sTLAXuCbHJc+aomP+/CsaeHPToofICMksFVUHDXCJrRTV8i7zsIYewpL76y4fGwZa/IovuJnQuAOwCFsAPwLdbmfds8ZcVUaA953ODQx9Yxht5ih2rLybo2ndpWZDrl49nBEYmvjH0hVgfPh4GOQBCK/sMRQooByUyv+Kadf0EIEzSjSp2MeE49ajqpDhI7IgC3AoXwrgiC5/sS74UK1vQjZ74suO2qlEmRL75LanRiJ/sZJ/AldWfqXQ2nr5z18t7vzGUDwwdsnvLXYIVeQcvFTge6J/WIyerUSZ6Kk4gg3eVFgrPF/udliv7DmMgYOjJGmZiKSLgPGQQcAmMsdoZ7FRcXl5ub27dv3/ZsbLfbtdp7uGMFY9e3Rx0FOQhhxYAUWc++dI9oOiQyoA5vAQtFplOfVHzBClyEOizVMEzFKAeEJoSrwsiAGbn7eve6a8B94/P5EEIy2d1cQuca67xVpZz5kvfHMsQLYU+thwZix4ID595Bi7C9PP/51ldT6fuxjG9p0qTPU6dMDJzXQfhhhE/VfedkXUdq8n9oqh4fM2bp4IXQ/wfERYcarj41i7Hty231m9coB6TQxt7Kgb+CcWpAgIBC+DPMc9jrEdx27PVgr1vwugW3w3v+O/ZyNddoovThisRU9cipioEjA+oAvmw37fvhkNlZX+cwY4SNmsg++uhlQxdHB9142BoAxEEQ+tlPussKWdMFV3Fey6EP1CkTZdEJpDaY1OgojT7QziyBdAR0ISwvLy8qKoqOjp44cSLRQQcJ5jne1sC3NAp2K29v5u1NgqNFcDZzjWa2tpqgaVKpIWQKQq4k5UpCqZb1SlCPnEKHGTvzeg4n8G7OjRDy8r5i02kBCwghH88Wm05XNv7Q7G25dmMFLZ/WZ2J6zGglrUgxDAvki59A6ghCOWiUctAoJAgthz/m6k2e82cEu01wNPMOGylXEkoNqVSTSg2p0lDBEZQ+nDHGKhIeCKiuB9D9BG4f4e7du5977rn58+cXFBQMGTJk165dN9vyDvoIBd60/nFC4KigEFIbTGn0pFZPaXSkWkfpw2Qx/QiZoiO/w12x+xxPHnze4bv6EpxYfUxMUE//dFJ4/34hcX30MeKlu4+gqyNg3UsfYfsJHid2OQW3Q3A7BZedt1p4q8V7oYK9XEVqdFRwBB1ulMcmyeOH8FYLb7fSET2ZHjGETI4Qwqyv9ToN5jmCpK5tX2KOJUjKX00xxxIUfX3r01t9jrc1EIycVCgJuZJg5IRcQSrUiCAxx2LWgxDCLItZr/+/Q5wPIST4vIhjEUKCz4MEnlSoCaWalKsIhYpUqEilus2Q+vcDHDj3LkBbhIIgrF27dvv27bNmzbLZbLGxsaWlpYMHD77XzyUp1SN/0McldUTG+8XqsdEkvX/+brGDANCpSIUaKdQUimi7QuD5FitvtbDmS56Kky15H9HhUZRGx9bv5ZvMVEgPvqEOsz5CqaZDDYLLztvqEUEyPXohkvK3NRHHIpKkw6OQwHONVzDPU5ogUqOn9GFMZIzgsnvOn0EYyWMTMesTvG7scWHWi31eweNEWCAo5uopMs2QMjlCCNEyf90lGDnBMAghQqYgSFLwuASXA3vdgseFPU7B48Ksl1RqSJXW38wl1UGkOohUaUmVllSqCbmKVCgJpYaUKwm5klRpA6rbRToCtBCWl5dbLJZp06YhhPR6/fjx4w8cONABhRAhqkcXeHiOQHB5E4D/R1KUPozSh8liE9Ujp1y7hm9p4m0NdJiRVGl4u5VvqCNUGjrMiDiWNV9CgkCqtaQ2mFSoMOvjzJcQQdCR0QRB8o5mwWHjrWa27idSpQ2f+BAdZrwv4QVecDkEt0Nw2QWXQ3C1CE674LJz9bWCx4k9bsHrxm6H4HFhr1tw2RFFU0EhpEZPKlWkXEUo1aRC5a+XdEQvWUx/GLjnfgjQQlhbWxsREcEwjH82KirKZDLdbGOn07l58+aQkBD/bEJCwuzZs2+4JUZ4X/UhgQrQq8F+Vo+NJiiWZcUO0tlYlpXgt+4S/Pulo/rpO5JSSyi1PEI8yyKFhugZjxDiBIxImjDEIoQwQlfXIgL1iL66FvFIqUFKDRXek0oY7t/sPv7tyVVIriL0ERRCtx1uX3A7sKOZdzRjjxN73djjEtxO7HNzDpurrIirq6ENPw9ZRcgViKQ4jvPQNEExhPznnh1SqUat59M007ah6fNgnscci1kvEnjB40IIIa8bCwJmvQRzm+eMCYXq1nc2kXIlom5VXAhGTtDMrTagGXTzxjEV0kMxZMytQ/68MUWRt+tjDtBCyPP8tUcdSZJer/dmG3McZ7PZWmfr6up4nr/hlgIWrJ5mggq84/kaNEH/PmXFzb5CN8bzvAS/dZfg3y+wdzqDTIlClFRI5A1X8o11gtXSOou9HiTwgtstVyoxz2Kv5+dVHhdCV8/4MesTnPZrP4eQKQiFnKQZRMsQSTIKNUIIyZUESRKMDLO+W2fEHhe65c0lgteNeO5WH8H5MHerMw+BY/EvM/8iAMW0/6/xtlUQBWwhNBqNDQ0NgiD4v4PZbE5MTLzZxjqdbvXq1e18oH5J0kPQsRyYWJZVKMS/WQlcz38Y3u+bZcDtRcWiqLaDGBNws8w9C9CbkpOSkpRK5YkTJxBCXq/36NGj6enpYocCAADQDQVoi1Amk61atWrx4sUrVqw4fPhwUlLS6NGjxQ4FAACgGwrQFiFCKDs7e/PmzTabbf78+QcOHOiQz8QY5+bmdshHgQ739ddfO51OsVOAG6iqqjp//rzYKcANuN3uY8eOiZ2iywvcB+rbr/0P1Dc2NiYkJDQ2NnZCKnCnUlNT33zzzZEjR4odBLT18ssvcxy3fv16sYOAtk6fPv3EE0+cOXNG7CBdW+C2CAEAAaIbnC4DcAtQCAEAAEgaFEIAAACS1h36CENCQhITE5XK2w9uy7LsN998k5aW1gmpwJ0qKSnp169fUBC8tTXg/Pjjjxjjdj6qCzqT3W6vqKgYMWKE2EEC15w5c5YvX37rbQL08Yk7sm3btqCgoHaO/3ThwoXY2LZPpIJAcPHiRaPRSNPd4W+ym7HZbBjj4OBgsYOAtniev3z5ckxM93wjTYdozw9+d2gRAgAAAHcN+ggBAABIGhRCAAAAkgaFEAAAgKRBIQQAACBp0rpD78SJE+fPnx8+fHiHvOwe3COLxVJRUREbG3vtPW8cx+Xl5dXX148fP75Xr14ixpOy77777ty5czqdLj09/dpX/NTU1Hz99deRkZETJ06kqNu+ZRZ0MEEQKioqysvLfT7fsGHDkpKSWle1tLQcOnQIYzx16lSdTidiyK5IQi3C7OzsJUuWFBcXT5kyZcuWLWLHkbqMjIzevXtnZGTs2bOndSHP81OmTHnllVfy8/OHDh1aUFAgYkLJysrKWrBgQV5e3qZNm+Li4r7//nv/8ry8vOHDhx8/fnzt2rWzZ8+GG847X01Nzfz583Nyco4cOTJu3LjVq1f7l5vN5sGDB+/evXvPnj2DBg0ymUzi5ux6sDRcvHhRoVBcvnwZY1xQUBAWFubxeMQOJWk1NTUsy86cOXPjxo2tC/ft2xcXF+ffNW+88UZaWppo+SSsurpaEAT/9KJFi5YuXeqfTklJ2bp1K8bY6XT26tXrq6++Ei0iwPjkyZMMw7jdbozx2rVrMzMz/csfeeSRVatWiRqt65FKi/DgwYMpKSlRUVEIodGjR9M0XVhYKHYoSYuJibn+2fn9+/dnZGTI5XKEUGZmZn5+vt1uFyOdpPXp06d1eAqDweD1ehFCV65cKSkpmTdvHkJIpVJNnz59//79YqaUPJfLpdPpGIZBCOXk5GRmZvqXz5s3D3bNnZJKH2FtbW3Pnj1bZ41GY21trYh5wA3V1taOGzfOPx0ZGUmSZG1tbf/+/UUNJV21tbXvvvvuxx9/jBAymUwqlSokJMS/KioqqqysTNR00vXQQw+ZzeaampovvvjC31NbW1vrP8tHCEVFRcGP252SSouQ5/lrx2CjaZrjOBHzgBvieZ4kr/5NEgRBkiTsJrHYbLZZs2YtW7ZswoQJ6LojiKIo2DVieeaZZ7Kzs4cOHbpu3Tqe59Ev9w7smrsglRahwWAoLi5unTWbzUajUcQ84IYMBoPFYvFPNzU1sSwLu0kUdrt9+vTpo0eP/tOf/uRfEhkZ6XQ6nU6nWq1GCJnNZoPBIGpG6RozZgxCaNq0aWFhYcXFxaNGjTIYDPX19f618ON2F6TSIkxLSyssLPR3OFVWVjY0NKSmpoodCrQ1bty4w4cPY4wRQrm5uUOGDGm9Fgc6jcvlmjVrVmJi4uuvv966sGfPnvHx8YcPH0YICYJw5MiR9PR08TICZLfbvV6v/20t6enpubm5/uV5eXmt/QugnaTSIhw4cODkyZMzMjLmzJmzffv2Z599Fh61EdeuXbuOHz9eWlpqsViqqqoeffTRkSNHLliwYMOGDb/97W8feOCB11577a233hI7phQ988wzJSUl8fHxTz31FEIoNjb2hRdeIAhi7dq1y5cvr66uLioqoihq1qxZYieVnA8++ODgwYODBg3yeDyffPLJjBkz/I8Srly5csSIEXq9nqKo999/H+4EvFMSevsEy7I7d+6sqqpKTk6eO3duO1/bBO6T/Pz8ysrK1tn09PT4+HiEkNVq3bFjR1NT09SpU0ePHi1eQOk6dOjQxYsXW2cjIiIefPBB//TRo0ePHDkSERGxdOlSOJXsfE1NTTk5OVVVVQzDpKSkTJ06tfV3rKqq6qOPPsIYL1y40H8ogfaTUCEEAAAArieVPkIAAADghqAQAgAAkDQohAAAACQNCiEAAABJg0IIAABA0qAQAgAAkDQohAB0ScXFxXv37hU7BQDdATxHCEAgWrVq1aeffnqztS+99FJJSUlOTs61T74DAO6OVIZYA6BrGTNmjFar9U+fOnXqyy+/zMrKan2VWFJSUmRkJLygCoAOAS1CAALd1q1bs7KyioqKRowYcduN3W63y+UKDQ1tXdLS0sIwjFKpvH5jr9drtVr1er1CoejIxAB0KdBHCECXtGbNmpSUFP+0yWQKCQnZsWPHokWLgoKCwsLCkpOTf/rpp+rq6jFjxuh0uqCgoEWLFnk8ntZ/brFYFi5cqNfrDQaDXq9fvHix/90sAEgQFEIAuqTm5maz2eyfFgTBarWuXr1ap9MVFBR8+umnNTU1S5YsmTt37pw5c0pKSjZu3Pjhhx++/fbb/u2dTmd6enpxcfHOnTvLy8vfe++9vLy8hQsXivdtABAT9BEC0E0kJye3vrjq7Nmz69ev37BhQ3Z2tn9VTk7O559/7p995513Kisrz507l5iYiBBKTExkGCYzM7O8vNz/Wh8AJAUKIQDdxOTJk1unExISrl9y6NAh/3Rubq7BYDCZTCaTyb/Ef69AWVkZFEIgQVAIAegmgoODW6dlMlmbJXK53Ofz+afNZrPFYlmwYEGbf97U1NQpSQEILFAIAZAcnU6XkJBQVlYmdhAAAgLcLAOA5KSlpVVWVpaWloodBICAAIUQAMlZsWKF0WicO3fugQMHbDZbQ0PD8ePHn3766fr6erGjASACuDQKgOSEhoYeO3YsKytr5syZ/ttkKIoaO3asv2cRAKmBkWUACHQYY0EQKIpqsxBjTJL3dFHHYrHU1NSo1ero6OjWEd0AkBoohAAAACQN+ggBAABIGhRCAAAAkgaFEAAAgKRBIQQAACBpUAgBAABIGhRCAAAAkvZ/UpftWXGq+FYAAAAASUVORK5CYII=\" />","category":"page"},{"location":"sir/","page":"SIR Model","title":"SIR Model","text":"","category":"page"},{"location":"sir/","page":"SIR Model","title":"SIR Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"constant_birth/#Delayed-Birth-Death-Process","page":"Birth-death Process","title":"Delayed Birth-Death Process","text":"","category":"section"},{"location":"constant_birth/","page":"Birth-death Process","title":"Birth-death Process","text":"using Random\nusing Distributions\nusing CompetingClocks","category":"page"},{"location":"constant_birth/","page":"Birth-death Process","title":"Birth-death Process","text":"Birth-death processes are a fundamental type of stochastic process, and are the building block of many more complicated models. Here we demonstrate how to use CompetingClocks to build a very simple simulation of a birth-death process where birth occurs according to an exponential (Markov) clock, but death occurs according to a Weibull distribution. We compare ensemble results to the known stationary distribution. Such models have been considered many times in the literature, but a recent reference is in \"Stochastic description of delayed systems\" by Lafuerza and Toral.","category":"page"},{"location":"constant_birth/#Model-structure","page":"Birth-death Process","title":"Model structure","text":"","category":"section"},{"location":"constant_birth/","page":"Birth-death Process","title":"Birth-death Process","text":"The model will be stored in a struct with a type parameter that is a subtype of ContinuousUnivariateDistribution, which is the distribution type for the clock associated to death. We also define a function initialize_model! which enables a single clock for the birth event, and for each individual in the initial population, enables a death clock for that individual.","category":"page"},{"location":"constant_birth/","page":"Birth-death Process","title":"Birth-death Process","text":"Known results tell us that the mean of the stationary distribution will be the birth rate multiplied by the average duration alive, which we use to choose the number of individuals in the initial population. We expect the model to fluctuate randomly around this value.","category":"page"},{"location":"constant_birth/","page":"Birth-death Process","title":"Birth-death Process","text":"mutable struct ConstantBirth{T <: ContinuousUnivariateDistribution}\n    birth_rate::Float64\n    death_distribution::T\n    next_name::Int64\n    alive::Int64\n    when::Float64\nend\n\n\nfunction initialize_model!(model, sampler, rng)\n    enable!(sampler, 1, Exponential(1.0 / model.birth_rate), 0.0, 0.0, rng)\n\n    initial_population = model.birth_rate * mean(model.death_distribution)\n\n    for name_id in 1:Int(round(initial_population))\n        past_birth = rand(rng, model.death_distribution)\n        enable!(sampler, name_id, model.death_distribution, -past_birth, 0.0, rng)\n        model.next_name = name_id + 1\n        model.alive += 1\n    end\nend;","category":"page"},{"location":"constant_birth/#Model-update","page":"Birth-death Process","title":"Model update","text":"","category":"section"},{"location":"constant_birth/","page":"Birth-death Process","title":"Birth-death Process","text":"There's two classes of events that can occur in this model. Birth is always assigned to key 1. When it fires, we disable and enable the birth process to reset it, and then enable a death clock for the new individual. If the firing event was death, we simply disable the clock. We return the integrated population over time from the step! method to check simulation results.","category":"page"},{"location":"constant_birth/","page":"Birth-death Process","title":"Birth-death Process","text":"function step!(model::ConstantBirth, sampler::SSA{K,T}, when::T, which::K, rng) where {K,T}\n    if which == 1\n        disable!(sampler, 1, when)\n        enable!(sampler, 1, Exponential(1.0 / model.birth_rate), when, when, rng)\n\n        name_id = model.next_name\n        enable!(sampler, name_id, model.death_distribution, when, when, rng)\n        model.next_name += 1\n        model.alive += 1\n    else\n        disable!(sampler, which, when)\n        model.alive -= 1\n    end\n    duration = when - model.when\n    model.when = when\n    model.alive * duration\nend;","category":"page"},{"location":"constant_birth/","page":"Birth-death Process","title":"Birth-death Process","text":"Our run function is simple. We use the FirstToFire sampler, but any sampler from CompetingClocks capable of supporting non-Exponential distributions can be used.","category":"page"},{"location":"constant_birth/","page":"Birth-death Process","title":"Birth-death Process","text":"function run_constant_birth(rng, max_step = 10000)\n    birth_rate = 117.0\n    death_rate = Weibull(2.0, 80)\n    model = ConstantBirth(birth_rate, death_rate, 2, 0, 0.0)\n\n    sampler = FirstToFire{Int,Float64}()\n    initialize_model!(model, sampler, rng)\n    # Begin by dropping a few events to account for burn-in.\n    when = 0.0\n    (when, which) = next(sampler, when, rng)\n    while when < 1e4\n        step!(model, sampler, when, which, rng)\n        (when, which) = next(sampler, when, rng)\n    end\n\n    # Then collect statistics.\n    total::Float64 = 0.0\n    start_time = when\n    for _ in 1:max_step\n        total += step!(model, sampler, when, which, rng)\n        (when, which) = next(sampler, when, rng)\n    end\n    steady_state = model.birth_rate * mean(model.death_distribution)\n\n    observed_state = total / (when - start_time)\n    (steady_state, observed_state)\nend;","category":"page"},{"location":"constant_birth/#Simulation","page":"Birth-death Process","title":"Simulation","text":"","category":"section"},{"location":"constant_birth/","page":"Birth-death Process","title":"Birth-death Process","text":"We check below that as we increase the data collected, it gets closer to the expected average with smaller standard deviation.","category":"page"},{"location":"constant_birth/","page":"Birth-death Process","title":"Birth-death Process","text":"function multiple_runs(trial_cnt = 20, max_step = 1000)\n    rng = Xoshiro(837100235)\n    trials = zeros(Float64, trial_cnt)\n    single_expected = 0.0\n    Threads.@threads for trial_idx in 1:trial_cnt\n        expected, observed = run_constant_birth(rng, max_step)\n        trials[trial_idx] = observed\n        single_expected = expected\n    end\n    (single_expected,\n     (mean(trials) - single_expected) / single_expected,\n     std(trials) / single_expected)\nend\n\nmultiple_runs(5, 100)","category":"page"},{"location":"constant_birth/","page":"Birth-death Process","title":"Birth-death Process","text":"(8295.084022237816, -0.0066604446780677735, 0.008892718847004514)","category":"page"},{"location":"constant_birth/","page":"Birth-death Process","title":"Birth-death Process","text":"multiple_runs(5, 200)","category":"page"},{"location":"constant_birth/","page":"Birth-death Process","title":"Birth-death Process","text":"(8295.084022237816, -0.006388077460778242, 0.012503310457599722)","category":"page"},{"location":"constant_birth/","page":"Birth-death Process","title":"Birth-death Process","text":"","category":"page"},{"location":"constant_birth/","page":"Birth-death Process","title":"Birth-death Process","text":"This page was generated using Literate.jl.","category":"page"},{"location":"commonrandom/#Common-Random-Numbers","page":"Common Random Numbers","title":"Common Random Numbers","text":"","category":"section"},{"location":"commonrandom/#Introduction","page":"Common Random Numbers","title":"Introduction","text":"","category":"section"},{"location":"commonrandom/","page":"Common Random Numbers","title":"Common Random Numbers","text":"If you set up the same model and run it with different initial random number generator (RNG) states, then it will create a set of trajectories. CompetingClocks sees these as a sequence of clock events and times of those events. You are usually interested in some summary outcomes of a simulation, such as the total time to a goal or the number of events. This summary outcome is a predictable function of the trajectories. We often want to ask how the goal function depends on simulation parameters, and that can be difficult to determine because each trajectory gives an individual value, and the set of trajectories gives an estimate that can have wide variance.","category":"page"},{"location":"commonrandom/","page":"Common Random Numbers","title":"Common Random Numbers","text":"What we want is a variance reduction technique. Common random numbers (CRN) are a variance reduction technique that enables you to use fewer simulation runs to compare the effect of different simulation parameters on the outcome. There are several other variance reduction techniques, such as antithetic variates and importance sampling, but let's look at common random numbers in CompetingClocks.","category":"page"},{"location":"commonrandom/","page":"Common Random Numbers","title":"Common Random Numbers","text":"If you estimate a value with n independent trajectories, then the bias of the estimate is proportional to 1sqrtn in most cases. If you want to distinguish the effect of changing a parameter, then the estimate must be precise enough that you can see the difference. It is common to use millions of trajectories. On the other hand, CRN means that you can produce n=100 trajectories, with significant bias in the estimate, and still see the effect of changing a parameter.","category":"page"},{"location":"commonrandom/","page":"Common Random Numbers","title":"Common Random Numbers","text":"CRN works well when the sample path is similar from run to run. If two runs use completely different events, then there will be too little overlap. If the causal chain of which events affect other events changes, that can be a problem, too. In most cases, people try CRN and see if it helps.","category":"page"},{"location":"commonrandom/#Using-Common-Random-Numbers-in-CompetingClocks","page":"Common Random Numbers","title":"Using Common Random Numbers in CompetingClocks","text":"","category":"section"},{"location":"commonrandom/","page":"Common Random Numbers","title":"Common Random Numbers","text":"CompetingClocks implements common random numbers by recording the state of the random number generator every time a clock is enabled. There are other ways to do this, but this one works with the CombinedNextReaction and FirstToFire samplers. The workflow you would use looks notionally like:","category":"page"},{"location":"commonrandom/","page":"Common Random Numbers","title":"Common Random Numbers","text":"Create a sampler.\nWrap it in a CommonRandomRecorder.\nRun a lot of simulations in order to explore and record all possible clock states. Run reset!(recorder) after each simulation.\nFor every parameter set to try, run it the same way, using reset! after each run.\nCompare outcomes.","category":"page"},{"location":"commonrandom/","page":"Common Random Numbers","title":"Common Random Numbers","text":"Because the CommonRandomRecorder stores the state of the random number generator at each step, it works best with random number generators that have small state, such as Xoshiro on a linear congruential generator (LCG).","category":"page"},{"location":"commonrandom/","page":"Common Random Numbers","title":"Common Random Numbers","text":"using Random: Xoshiro\nusing CompetingClocks\nexample_clock = (3, 7)  # We will use clock IDs that are a tuple of 2 integers.\nmodel = MakeModel()\nsampler = FirstToFire{typeof(example_clock),Float64}()\ncrn_sampler = CommonRandomRecorder(sampler, typeof(example_clock), Xoshiro)\nfor trial_idx in 1:100\n    run_simulation(model, crn_sampler)\n    reset!(crn_sampler)\nend\nfor param_idx in 1:10\n    each_model = modify_model!(model, param_idx)\n    run_simulation(each_model, crn_sampler)\n    reset!(crn_sampler)\nend","category":"page"},{"location":"commonrandom/#Multithreading","page":"Common Random Numbers","title":"Multithreading","text":"","category":"section"},{"location":"commonrandom/","page":"Common Random Numbers","title":"Common Random Numbers","text":"A joy of using simulations is how easy it is to parallelize simulation runs across tasks. That can be a challenge for the CommonRandomRecorder because it continues to observe and record new RNG states as it comes across them. That will result in divergence between behavior on different threads. For that reason, it is possible to freeze a CommonRandomRecorder. It will stop recording states, so make sure to first prime it with lots of simulation runs, and then freeze the recorder and use that as the sampler for multiple simulations on multiple threads.","category":"page"},{"location":"commonrandom/","page":"Common Random Numbers","title":"Common Random Numbers","text":"using Random: Xoshiro\nusing CompetingClocks\nexample_clock = (3, 7)  # We will use clock IDs that are a tuple of 2 integers.\nmodel = MakeModel()\nsampler = FirstToFire{typeof(example_clock),Float64}()\ncrn_sampler = CommonRandomRecorder(sampler, typeof(example_clock), Xoshiro)\nfor trial_idx in 1:100\n    run_simulation(model, crn_sampler)\n    reset!(crn_sampler)\nend\nfor thread_idx in 1:10\n    frozen_crn = freeze(crn_sampler)\n    # start a simulation run on this thread with frozen_crn.\nend","category":"page"},{"location":"commonrandom/#Checking-effectiveness-of-Common-Random-Numbers","page":"Common Random Numbers","title":"Checking effectiveness of Common Random Numbers","text":"","category":"section"},{"location":"commonrandom/","page":"Common Random Numbers","title":"Common Random Numbers","text":"If your simulation has a large sample space, CRN may not help. We run a first set of simulations in order to record the state of the system for lots of different clocks and different multiplicities of clock events. If that worked well, then subsequent runs of the simulation will re-use draws from the random number generator. If there are a lot of events which are needed but haven't been recorded, those misses are a sign that CRN is unlikely to reduce variance much for this simulation.","category":"page"},{"location":"commonrandom/","page":"Common Random Numbers","title":"Common Random Numbers","text":"We check this by checking the misscount during later runs of the simulation under CRN. If that miss count is high, we can look into which clocks are firing that didn't previously fire by iterating over the misses, which are pairs of (clock key, number of misses for that clock).","category":"page"},{"location":"commonrandom/","page":"Common Random Numbers","title":"Common Random Numbers","text":"The final word on effectiveness of CRN is to look at the variance of summary outcomes for runs with and without CRN. The CRN will, in general, slow down a sampler, but it should mean that many fewer runs are required to distinguish the effect of changes in system parameters.","category":"page"},{"location":"commonrandom/","page":"Common Random Numbers","title":"Common Random Numbers","text":"","category":"page"},{"location":"commonrandom/","page":"Common Random Numbers","title":"Common Random Numbers","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reliability/#Reliability-Model-of-a-Work-Crew","page":"Reliability","title":"Reliability Model of a Work Crew","text":"","category":"section"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"This is an extended example using a reliability model.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"using ColorSchemes\nusing Distributions\nusing CompetingClocks\nusing Logging\nusing Plots\nusing Random\nusing StatsPlots","category":"page"},{"location":"reliability/#Overview","page":"Reliability","title":"Overview","text":"","category":"section"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"The classic model for reliability is of a machine that is either working or broken. There is a distribution of failure times and a distribution of repair times [1]. Let's extend this idea to the reliability of a vehicle motor pool.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"There are 16 vehicles.\nEvery morning, 10 vehicles go out for work. They all leave in the first 15 mins.\nEach vehicle works at least half a day, at most the whole day.\nWhile working, a vehicle can break, where the chance of breaking depends on the total time since it was last repaired.\nThere is a distribution of repair times.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"Number two, above, says that vehicles start in the first 15 minutes. This plan will initiate ten transitions in rapid succession. We could, instead, start all ten vehicles at the same time, using a single transition. Either would work.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"CompetingClocks will take care of the timing of all of the events, but we will see that there is plenty of work to track the state of all of the vehicles. This extended example shows that, if we wanted to create more reliability models, it would make sense to create a framework for reliability modeling, one that uses CompetingClocks underneath.","category":"page"},{"location":"reliability/#Define-State-for-the-Model","page":"Reliability","title":"Define State for the Model","text":"","category":"section"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"If we think about an individual vehicle, the states are ready, working, or broken.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"@enum IndividualState ready working broken","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"There are four allowed tansitions among the three states because a vehicle breaks only while it's working.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"const IndividualTransitions = Dict(\n    :work => (ready, working),\n    :done => (working, ready),\n    :break => (working, broken),\n    :repair => (broken, ready)\n);","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"An individual has state and parameters. In the language of generalized semi-Markov processes, this state is called the physical state in order to distinguish it from the state of each enabled transition for each vehicle.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"mutable struct Individual\n    # State for the individual\n    state::IndividualState\n    work_age::Float64 ## How an individual remembers its total work leading to breaks.\n    transition_start::Float64  ## This is bookkeeping.\n    # Parameters for the individual\n    done_dist::LogUniform\n    fail_dist::LogNormal\n    repair_dist::Weibull\n    Individual(work, fail, repair) = new(\n        ready, 0.0, 0.0, work, fail, repair\n        )\nend","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"The simulation as a whole is the state of the individuals and the system time. We put some parameters here:","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"workers_max - Each morning, this many vehicles start driving, if at least this many vehicles are ready, instead of broken.\nstart_time - Vehicles start in the first 15 min or so, and this is that 15 min.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"mutable struct Experiment\n    time::Float64\n    group::Vector{Individual}\n    # Each day the group tries to start `workers_max` workers.\n    workers_max::Int64\n    start_time::Float64\n    rng::Xoshiro\n    Experiment(group::Vector, crew_size::Int, rng) = new(0.0, group, crew_size, 0.01, rng)\nend","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"Make a simulation by making individuals.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"function Experiment(individual_cnt::Int, crew_size::Int, rng)\n    done_rate = LogUniform(.8, 0.99) # Gamma(9.0, 0.2)\n    break_rate = LogNormal(1.5, 0.4)\n    repair_rate = Weibull(1.0, 2.0)\n    workers = [Individual(done_rate, break_rate, repair_rate) for _ in 1:individual_cnt]\n    Experiment(workers, crew_size, rng)\nend","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"Main.var\"##246\".Experiment","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"And make some helpers. The key_type says that we will track transitions using a tuple of (index of vehicle, symbol to identify the transition).","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"key_type(::Experiment) = Tuple{Int,Symbol};\nworker_cnt(experiment::Experiment) = size(experiment.group, 1);","category":"page"},{"location":"reliability/#Define-Transitions-for-the-Model","page":"Reliability","title":"Define Transitions for the Model","text":"","category":"section"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"If we were modeling one individual, transitions would be very simple, but by asking that ten vehicles work every morning, we require that those individuals interact.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"One way to think clearly about interactions is to think about the state of the whole system. If less than ten vehicles are currently working, then every ready vehicle must have an enabled transition to start work at the next available time. Once the tenth vehicle begins working, all of those transitions need to be disabled.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"It's implied that the start of each day happens at 1.0, 2.0, 3.0, etc. When a vehicle becomes ready, or when the total working vehicles drops below ten, then each ready vehicle could work at a future time. This function takes in the current time and returns two times, relative to the current time, between which the vehicle can start work.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"function next_work_time(now, fifteen_minutes)\n    hour = now - floor(now)\n    if hour < fifteen_minutes ## If vehicles are still going out today.\n        return 0.0, fifteen_minutes - hour\n    else ## You can't start until tomorrow.\n        return one(hour) - hour, one(hour) + fifteen_minutes - hour\n    end\nend;","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"Now we handle simulation events. This function's complexity is an argument for using a framework like a queueing model, a generalized stochastic Petri net, or some other continuous-time simulation framework.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"The arguments are:","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"when - The time of the next event.\n(who, transition) - This expands the key_type, which identifies the transition.\nexperiment - It's our simulation data.\nsampler - This is a CompetingClocks.SSA from CompetingClocks to enable and disable transitions.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"The first few statements of the function are automatic for any transition. Then this handler works through the transition types.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"function handle_event(when, (who, transition), experiment, sampler)\n    start_state, finish_state = IndividualTransitions[transition]\n    individual = experiment.group[who]\n    @assert individual.state == start_state\n    individual.state = finish_state\n    experiment.time = when\n    disable!(sampler, (who, transition), when)\n\n    # If a vehicle is done work, or if they break, then include the time worked\n    # in their total work age.\n    if start_state == working\n        work_duration = when - individual.transition_start\n        @debug \"Adding $work_duration to $who\"\n        individual.work_age += work_duration\n    end\n\n    # The state of the system, as a whole, depends on the total number\n    # currently working.\n    worker_cnt = count(w.state == working for w in experiment.group)\n    need_workers = worker_cnt < experiment.workers_max\n    max_hour = experiment.start_time\n\n    # When an individual was working, there were two possible transitions,\n    # one to `ready`, and one to `broken`. Don't forget to disable the `:break`\n    # transition. Then schedule the next day's work only if the system has less\n    # than ten working.\n    if transition == :done\n        disable!(sampler, (who, :break), when)\n        if need_workers\n            rate = Uniform(next_work_time(when, max_hour)...)\n            enable!(sampler, (who, :work), rate, when, when, experiment.rng)\n            @debug \"schedule $who for $rate\"\n        end\n\n    # A `:repair` transition can happen at any time, including during the first\n    # fifteen minutes of a day.\n    elseif transition == :repair\n        if need_workers\n            rate = Uniform(next_work_time(when, max_hour)...)\n            enable!(sampler, (who, :work), rate, when, when, experiment.rng)\n            @debug \"schedule $who for $rate\"\n        end\n\n    # The `:work` transition represents a vehicle going out to work for the day.\n    # This enables two possible transitions, finishing work or breaking. The\n    # breaking transition is interesting because it has what Zimmerman [2] calls\n    # \"memory.\" It remembers how long it was previously enabled\n    elseif transition == :work\n        # enable :done and :break\n        enable!(sampler, (who, :done), individual.done_dist, when, when, experiment.rng)\n        # Time shift this distribution to the left because it remembers\n        # the time already worked.\n        past_work = when - individual.work_age\n        enable!(sampler, (who, :break), individual.fail_dist, past_work, when, experiment.rng)\n        @debug \"schedule $who for done or break\"\n\n    # When a vehicle breaks, the only option is to repair it. This resets the work age.\n    elseif transition == :break\n        # If you broke, you don't get to finish your work.\n        disable!(sampler, (who, :done), when)\n        individual.work_age = zero(Float64)\n        enable!(sampler, (who, :repair), individual.repair_dist, when, when, experiment.rng)\n        @debug \"schedule $who for repair\"\n\n    else\n        @assert transition ∈ keys(IndividualTransitions)\n    end\n    individual.transition_start = when\n\n    # We haven't handled how we ensure that at most ten vehicles start work every\n    # morning. For that, we need to think about the system as a whole, explicitly\n    # by looking at the current worker count and whether it crossed the threshold of\n    # ten workers.\n    #\n    # If a vehicle just started and is the tenth worker, then cancel the ability of\n    # all other vehicles to work.\n    if transition == :work && worker_cnt == experiment.workers_max\n        notnow = Int[]\n        for too_many in [widx for (widx, w) in enumerate(experiment.group) if w.state == ready]\n            # You don't start today.\n            disable!(sampler, (too_many, :work), when)\n            push!(notnow, too_many)\n        end\n        @debug \"Unscheduling $notnow\"\n\n    # If a vehicle stopped work, either by finishing or breaking, and it was the\n    # first of the work crew to quit, then notify all `ready` vehicles that they\n    # should start work at the start of the next morning.\n    elseif transition ∈ (:done, :break) && worker_cnt == experiment.workers_max - 1\n        rate = Uniform(next_work_time(when, max_hour)...)\n        upnext = Int[]\n        for next_chance in [widx for (widx, w) in enumerate(experiment.group) if w.state == ready]\n            if next_chance != who\n                enable!(sampler, (next_chance, :work), rate, when, when, experiment.rng)\n                push!(upnext, next_chance)\n            end\n        end\n        @debug \"scheduling $upnext for $rate\"\n    end\nend;","category":"page"},{"location":"reliability/#Configure-the-Model","page":"Reliability","title":"Configure the Model","text":"","category":"section"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"For anything other than an example, the most important step would be configuring the model so that it matches observations. Here, however, we have put this directly into the Experiment type. Here is a plot of the distributions.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"function show_distributions()\n    experiment = Experiment(16, 10, Xoshiro(9378424))\n\n    plot(experiment.group[1].done_dist, label=\"Done\")\n    plot!(experiment.group[1].fail_dist, label=\"Break\")\n    plot!(experiment.group[1].repair_dist, label=\"Repair\")\n    title!(\"Distributions for Transitions\")\nend\nshow_distributions()","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"<img src=\"data:image/png;base64,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feedd6xWK3dy0F25+O3ijpJWD9QH3JTe3t7Dhw//9NNP9+/fTxy+89CkIQjhDoZhfvnll6FDh5pMpsmTJ9cyO5rTKALyVxpxw8AJIdyJebm5uQ9e1apVqxx7e//+97/LysqGDh1q/0XPDU7fs2ePvY3JZOLGbzji9vTes6T27dt37tw5Jyfnp59+si9kGIb74c+dbeu66h+UUqmUyWQ2m62uvxK4MS2rV692nPH1+PHjiYmJKpWq9iEo9YvbWeo4K6zRaPz444/vY1U2m636BLZO36XquE2Zl5dX+8qHDx/u5eW1Z8+eCxcu2BdqNJovv/yS1Mem5MqopU5oQjAIhr+2bt3Kna2n1WoLCwtPnjzJjQObPn06N0qhJn379u3QocPYsWOjoqJ8fHwyMjLee+89Qoh9/1hoaGhoaOjx48dnz57dqVMnsVjcs2dP+zw1dZKbmztp0qTXXntNqVTu3r373XffFYvFH330kb3BlClT1qxZ884777As26NHj+zs7OXLl1ssFqf1dO/enaKozz//3Gw2h4WF0TQ9bty4u8638sknnwwfPvz5558vKioaNmxYWVnZqlWrkpKSOnbsOGvWrDoV/9Zbb507d27atGkdOnQIDQ3Nz8//+uuvi4uLH3300eoHpWo3YsSIYcOG7du3b8iQIe+++25YWNjJkyffeustQsjHH39c17U9iEGDBm3fvn3GjBkrVqzo2LFjZmbmfR8qq6qqioqKmjZtWkJCQuvWrWmaPn369KJFi2ia5oL/rnr06EEIee211y5cuMBtwWeffdZxXiGOUql8//33X3/99REjRixZsiQ+Pj4rK+u9994rKCgYN25cTUMVazJ69GilUjlhwoQ2bdqo1err169zX8L73icMjYtHB2+AZ1T/OUzTdLt27Z599tmTJ09Wb+80jnDkyJFOf3e4KxXYbDb7U/744w/HuaycZpap/hI1jSNMSUlp2bKlfT1KpXL79u1Oz/3www8dT/IcPHgwNxuA4zhClmU//fRTx+SrZWaZbdu2OZ2WMmjQoPz8fMc23MwyTpVs2bKFEPLmm29yd5ctW1Z97MHo0aNLS0urfwJ2dx1HyC2fMmWK40FKhULx+eefO7bhRt198skntaz/rmoaR5iamurU0mKxOM0rFB8fz+2z7d27t70ZN47wiy++cHq647hPjUZTfdIfPz+/DRs2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BCF2jQIAuFNycvKvv/66a9cuQkh0dPS5c+dGjBhBCDl79mxYWJhcLr/rs1QqVWho6KhRox555BG3lnsvzSIIpVQprsQEANCQrl69umzZMr1en5aWtmfPnsWLFw8dOpQQ8vrrr48dOzYgIECpVC5YsOCtt96qZSXLli2bMWPGokWLwsPDMzMzdTrd66+/7q53UKPmEIRSARFSRGshCpGnSwEAaI769eun0+nKy8uVSuW4ceO+/PLL4OBg+0O///77hg0bDAbDZ599NmbMGEJIcHDw888/b3/6jBkzwsLCCCHTpk2Lioratm3b4cOHIyIiJk2a5JG346Q5BCH5q1OoEN3j6C4AANyHhISEhISEmh7t3r179+7dHZe0aNFi/vz59ruvvvqq/XafPn0a22WHm8M4QkKIn4SU4HwZAACou2YShP5SUorzZQAAoO6az67REiNLCHaNAgDUv4KCgvz8fEKIRCJp2bKlj4/PA67w6tWr+/fvf+mll+qjugfVXHqE2DUKANBgvvvuu8GDB8+aNWv69Onh4eFz5szhRs3ft5s3b/73v/+tr/IeUDMJQj8pKcUlCQEAGgw36fbZs2fT0tK++eab8+fP2x9iGOb69ev2ybULCwudJhE1m803b95sJDOLVtdMgtBfSpXgGCEAQMNTqVRCoZDrEa5atWr48OG9evWaMGHCgQMHLl++3KVLl9GjR/fs2XPixIkmk4kQsnnz5vbt2//jH//o0qXLpEmTrFar49psNtvs2bOHDRum0Wg8836azTFC7BoFgObKWlpgyc105ysK1IHilu2cFp47d27WrFlmszk5OXnu3LndunXjlh8/fjw1NTUqKophmG7dui1YsOCJJ55gGGbixIlff/31vHnzEhISrl27JhAIrFbr0KFDt2zZ8sQTT3DP1el0U6ZMCQwM3L17t1DosTxqLkEopUqMmHcbAJoha1GePjXJna8oiexYPQgDAgIGDx5stVpDQkI2bdr03HPPcXONJiQkREVFEUJu3ryZkZEhEAi2bNlCCAkNDU1KSpo3b56vr++GDRvOnj1rNBorKysvXLjABWF5efmgQYPGjh27cOFCd7676ppJEAbIyG30CAGgOZJ27CHt2MPTVZCwsLCJEycSQp544omMjIyvvvpqxYoVhBC1Ws01KCsrE4lEN2/etLfnBs7PnTs3Ly/v+eefDwwM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rPdeuRPWYmadwpIQQlhiMRmsRitb7SGWcbrUifPjNithbLU0cGa1EOYueVsnrM1CbDYbyxhYy71bNwyL1Spy+InAWGv7lPhAzApoubc7jw0IZH/nRX39sXI1CENDQwsKCrjbBQUFwcHBNb18QEBA7969Fy5c6OKapa07itp1Edb+8xPchaIoiqJEogY5J6hpUYsaxfW5NBqNt3fT/knRnGBzNCoikahe/li5mqXDhw//7bffuNs7duwYPnz4g782AACAx7naD3v++ed79OgxZcoUHx+fX3/99fjx4w1aFgAAgHu42iMMDAxMTU0dPnx49+7dL1y40LZt2/qqYM+ePRcvXqyvtcEDSk1N/f333z1dBdxRXFzczMYpNWkMw6xcudLTVcDfvv76a6327sfy66QOhxlVKtVTTz313HPPhYTU54X09uzZc+rUqXpcITyIP//8c9++fZ6uAu7IzMz86aefPF0F3GE0GlesWOHpKuBv3333XX5+/oOvBwOBAQCA1xCEAADAawhCAADgNYq925waD2LmzJnbtm2zD6i/p5KSEolEgqE5jYRGozGbzX5+fp4uBAghxGQylZaWhoaGeroQIIQQlmVzcnJatbr75Pjgfnl5ecHBwbUPQ586deqHH35Y+3rqPwhNJlN2drbrA+QtFotAIKivmWXgAdlsNpZlMb9B42EymSSSRnF5ECDYHI2MK5sjJCTEcW6mu6r/IAQAAGhC0A8DAABeQxACAACvIQgBAIDXEIQAAMBrHj458PTp01u2bJHL5U8//TROSvas69evHzp0yH53zJgx9TuXHtwTwzBXr149e/asVqudOXOm4yU/Dx06tHv37sDAwBkzZtRymWuoX4WFhSkpKfn5+UOGDImMjOQWpqenJyUl2duMHz/e39/fQwXyy8WLF/fu3VtYWBgdHT1t2jSF4s6ls/V6/bfffpudnd2nT5+JEyfex5o92SNMSkoaPHhwQECARqPp0aNHYWGhB4uB06dPL1269MZfjEajpyvinVOnTg0cOHDNmjWzZs1iHK6j+/PPP0+dOjUiIuLq1at9+vTR6+t8YV64P3379l26dOkbb7xx9uxZ+8KjR4+uWrXK/i/FZDJ5sEL+YBhm8ODBeXl5LVu23L59e8+ePXU6HffQqFGj9u/fHx0dvWjRonsOGbw71nNGjRq1ZMkS7vaECRPef/99DxYDGzduHDp0qKer4DVuEOfVq1cJIVar1b68c+fOP/74I3e7R48e69at80x9/MNtkY4dO27dutW+cO3atRMmTPBcUfxlMBi4G2azOSQkZNeuXSzLHj9+3N/f32g0siybkpKiUqn0en1d1+zJHmFiYuLQoUO520OGDElMTPRgMUAIyc/PX7ly5b///e+ioiJP18JHd51Wory8/OLFi4MHD+bu4l+KO9U00Ud2dvaKFSu+//770tJSN5fEZ1Kp1H7baDRyu0YTExMffvhhblh9fHw8TdMXLlyo65o9FoQajUar1dqPdgQGBhYUFHiqGCCEeHt7d+nSpaKiYseOHe3bVsQHagAAAxVJREFUt3fcFwQeVFBQQNO0/ShUUFBQvVx3Bu6bUqns2LFjZWXl1q1b27Vrd+XKFU9XxDuLFi3q0KHDgAEDCCEFBQWOR80DAwPv4x+Ix06WEYlEhBCr1crdtVqtYrHYU8UAIWTUqFGjRo3ibr/yyivvvffezp07PVsSEEJEIhHDMDabjeudWCwWTPHlWRMnTrSfkfHss89+8MEHGzdu9GxJvLJu3bqffvopKSmJ+xchEokcT2iwWCz3ESUe6xFKpVK1Wn3r1i3u7q1btzCzcOPRt2/fGzdueLoKIISQkJAQiqLsP3Jv3bqFs3kbD/xLcbP//Oc/ixcvPnz4sH2UQWhoqD1HrFZrUVHRfUSJJ48RPvroo1u2bCGEMAyzbdu2MWPGeLAYMBgM3A2WZXft2hUTE+PZeoCjUCgGDRq0detWQojRaNy5c+ejjz7q6aJ4zd7/YBhm9+7d+JfiNps3b3777bf37dsXFRVlXzhmzJikpKTi4mJCyL59+9RqdWxsbF3X7MlJt69evfrQQw89/PDDxcXFVVVVSUlJXl5enioGHnvsMY1G06JFi4sXL2o0mv379zt+28ANdDrdww8/bDKZLl26FBcXp1KpDh48SAg5ceLEo48+OmLEiPT0dLVavWfPHoFA4OlieWH27NmnT59OS0sLDQ1VqVTfffdd165dhwwZQggJDg4+d+6c1Wo9ePBgWFiYpytt/qqqqtRqdXBwcHBwMLdk/vz5kyZNIoS88MILBw8e7N+//65duz7//PMpU6bUdeUevvpEeXn5wYMHFQpFQkICjnx4Vnl5eXJycllZWWhoaJ8+fXDI1v1sNltqaqr9rlAo7NKlC3e7oKAgKSnJ399/4MCBSEG3uXr1qkajsd9t166dQqEoLS1NTk6uqKgICwvr06cPrlnmHk7/Oggh4eHhgYGB3O0TJ05kZ2f36NGjTZs297FyXIYJAAB4DXONAgAAryEIAQCA1xCEAADAawhCAADgNQQhAADwGoIQAAB4DUEIAAC8hiAEAABeQxACAACvIQgBAIDXEIQAAMBr/w9AdjbO1dbkVQAAAABJRU5ErkJggg==\" />","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"The short blue line in the upper-left is the probability distribution function for a LogUniform distribution that represents the time a vehicle drives on a single day. You can see that these vehicles break about once a week and take a couple of days to repair, on average.","category":"page"},{"location":"reliability/#Run-the-Simulation","page":"Reliability","title":"Run the Simulation","text":"","category":"section"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"Running a simulation means we are sampling from the stochastic process. For a continuous-time stochastic process like this, that means asking the sampler when the next transition is and which transition it is. If there are no possible transitions, the next time will be infinite and the chosen transition will be nothing.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"function run(experiment::Experiment, observation, days)\n    sampler = FirstToFire{key_type(experiment),Float64}()\n    rng = experiment.rng\n    rate = Uniform(next_work_time(0.0, experiment.start_time)...)\n    for initial in 1:length(experiment.group)\n        enable!(sampler, (initial, :work), rate, 0.0, 0.0, rng)\n    end\n    when, which = next(sampler, experiment.time, rng)\n    while isfinite(when) && when < days\n        # We use different observers to record the simulation.\n        observe(experiment, observation, when, which)\n        @debug \"$when $which\"\n        handle_event(when, which, experiment, sampler)\n        when, which = next(sampler, experiment.time, rng)\n    end\nend","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"run (generic function with 1 method)","category":"page"},{"location":"reliability/#Observers","page":"Reliability","title":"Observers","text":"","category":"section"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"Without care, data collection from continuous-time simulation can generate a lot of data quickly. In many cases, especially for performance analysis, not every event time and transition is important. Therefore, to avoid saving the raw data stream, we use observers of the system to summarize that data. Construction of observers is important as it connects the simulation to tools or analyses that may be used to guide decision-making. It also identifies which variables and metrics are most important.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"Let's look at a few examples for the vehicle crew.","category":"page"},{"location":"reliability/#Continuous-time-Summary-Observer","page":"Reliability","title":"Continuous-time Summary Observer","text":"","category":"section"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"The first example will record data at every transition, but it will record only the total number of working or broken vehicles.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"This represents a single time point.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"struct ContinuousRec\n    working::Int64\n    broken::Int64\n    total_age::Float64\n    time::Float64\nend","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"The observer stores a vector of those single time points.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"mutable struct ObserveContinuous\n    state::Vector{ContinuousRec}\n    ObserveContinuous() = new([ContinuousRec(0, 0, 0.0, 0.0)])\nend","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"This observer keeps a running sum of the number working and broken. Note that it has to know how different transitions change those numbers. The relationship between the transition and how it changes counts is called stochiometry (or stoichiometry), because it was first observed for chemical simulations. Both chemical simualtions and GSPN would have this information encoded in a formal model.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"function observe(experiment::Experiment, observation::ObserveContinuous, when, which)\n    who, transition = which\n    working = observation.state[end].working\n    broken = observation.state[end].broken\n    if transition == :work\n        working += 1\n    elseif transition == :done\n        working -= 1\n    elseif transition == :break\n        broken += 1\n        working -= 1\n    elseif transition == :repair\n        broken -= 1\n    else\n        @assert transition ∈ (:work, :done, :break, :repair)\n    end\n    total_age = sum(w.work_age for w in experiment.group)\n    push!(observation.state, ContinuousRec(working, broken, total_age, when))\nend;","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"This plot shows a timeline of the count of working and broken vehicles over five days.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"function plot_timeline(obs::ObserveContinuous, experiment::Experiment)\n    state = obs.state\n    last_time = state[end].time\n    first_idx = findlast([x.time < last_time - 5 for x in state])\n    times = [x.time for x in state[first_idx:end]]\n    times .-= 4009\n    working = [x.working for x in state[first_idx:end]]\n    broken = [x.broken for x in state[first_idx:end]]\n    ready = [worker_cnt(experiment) - x.working - x.broken for x in state[first_idx:end]]\n    plot(times, working, label=\"working\", line=(:steppost, 2))\n    plot!(times, broken, label=\"broken\", line=(:steppost, 2))\n    xlabel!(\"Time [days]\")\n    ylabel!(\"Status [count]\")\n    title!(\"Timeline of Work Crew Over Five Days\")\nend\n\nfunction show_typical_timeline()\n    rng = Xoshiro(9234232)\n    years = 11\n    day_cnt = 365 * years\n    worker_cnt = 16\n    experiment = Experiment(worker_cnt, 10, rng)\n    observation = ObserveContinuous()\n    run(experiment, observation, day_cnt)\n\n    plot_timeline(observation, experiment)\nend\nshow_typical_timeline()","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"<img src=\"data:image/png;base64,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j7pavHjxrl27PD0958yZY16uUqleeumlwsLCNWvW/Pnnn76+vs8995x5BbbGzp8/3/xMGFNYWGhxaNSmWIZeu3at1YT98ssvOzo6rlu3jp1/NScIQjmrejmOHz8eGhp6/fr11q1bs8su6b/RACkpKeY1169fbzV1eXh4DBky5PLly2yAzGuvvWb+aemolEol63dKaPiMfQarQhkqe/mE+cXOgiCw50J07drV4uvsojHThRZGo5GN+2/VqtX333/PnmYQERExbdo0T09P06XQFb+g3mJ2ERERRPTOO++YSnbv3q1QKBwcHN5+++3du3fHx8fv2bNn+fLlTz755Lx588ppkMTERDc3N47jZs6ceeLEibi4uKlTpxKRh4fH9evXTdUqfvkEYxpXaTEiXxAE0yZ48ODB5uVHjx5VKpUqlerDDz88c+bM4cOHhw4dSkQNGjQwv5yAXVBfeo6lL6hfunQpx3ENGjRITEwsP9qIiAg2SKdz585ffPHFrl27duzYsXLlStaX7du3L6tmuqDe4us8z7/00ktE1Lx581WrVh09epTdnvT111/39vY2b0aj0Wg6WpuUlGQqN3Ug4uLiyg+VYVlTLpePHj168+bN+/fvX7NmDUuiTk5Oe/bsKf0V1ttj55tNF3qb6PX67t27E1H79u1/+umnuLi448eP//777xMnTnRzczNd+slGL2/cuLEiQVbqOkITnucbNWqkUChUKlXdunVL342drYqenp4fffRRVFRUfHz89u3bP/roo6ZNm65Zs6aceFinv3379rNnz549e/b06dOHDx9uuu9ocHDwjRs3TJV1Oh27hcW0adNOnjwZHx/PdpgaNWpEZlcumRw/fpxNp1atWhb3ow8PD2/ZsuWyZcv27t176dKlY8eOsatFmzdv/vD3mn9UIBFWL+IkQkEQtFrtrFmzLA5zyeXykJAQ0wXIVZgIBUGIjo423c/JpF69ehEREeW3SVxcnGlUHvP444+zu3+ZVDYRstYja/cRZZ08Ivryyy8tPtq9e7fFabann37aPGEIlUmEgiCsWrVKJpPVq1fv8uXL5Qd84sSJ0r0xtVo9cuRIUwBlJUJBEPR6/XvvvWcxrEkul3fp0sXihgaDBg0iosDAQPNCNvrf/ILC+9q0aZP5LdyYkJCQcm6RYzpraHG9KVNcXDxt2jSLoVVKpbJ79+6mC9VF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\" />","category":"page"},{"location":"reliability/#Once-a-day-Observation-of-the-Working-State","page":"Reliability","title":"Once-a-day Observation of the Working State","text":"","category":"section"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"Suppose that we want to match our simulation to observation data that counts, every day, how many vehicles went out and how many were broken that morning. This observer records that status each day.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"mutable struct ObserveLots\n    status::Array{Int64,2}\n    started_today::Array{Int64,1}\n    total_age::Array{Float64,1}\n    broken_duration::Array{Float64,1}\n    ObserveLots(day_cnt, individual_cnt) = new(\n        zeros(Int64, 2, day_cnt),\n        zeros(Int64, day_cnt),\n        zeros(Float64, day_cnt),\n        zeros(Float64, individual_cnt)\n    )\nend\n\ndays(observation::ObserveLots) = size(observation.status, 2);","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"This observer waits until the current transition time is just after the first 15min of the day. Then it records every vehicle's status.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"function observe(experiment::Experiment, observation::ObserveLots, when, which)\n    who, transition = which\n    day_idx = Int(floor(when))\n    if transition == :work\n        observation.started_today[day_idx + 1] += 1\n    elseif transition == :repair\n        observation.broken_duration[who] += when - experiment.group[who].transition_start\n    end\n    day_start = Int(floor(experiment.time + next_work_time(experiment.time, experiment.start_time)[1]))\n    next_start = Int(floor(when + next_work_time(when, experiment.start_time)[1]))\n    if day_start != next_start\n        worker_cnt = count(w.state == working for w in experiment.group)\n        broken_cnt = count(w.state == broken for w in experiment.group)\n        work_ages = sum(w.work_age for w in experiment.group)\n        for rec_idx in day_start:next_start - 1\n            observation.status[1, 1 + rec_idx] = worker_cnt\n            observation.status[2, 1 + rec_idx] = broken_cnt\n            observation.total_age[1 + rec_idx] = work_ages\n        end\n    end\nend;","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"Now we can use this observer to make a plot.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"function walk_simulation()\n    day_cnt = 20\n    experiment = Experiment(16, 10, Xoshiro(979798))\n    observation = ObserveLots(day_cnt, worker_cnt(experiment))\n    run(experiment, observation, day_cnt)\n    plot(1:day_cnt, observation.status[2, :], seriestype=:scatter, label=\"repair\",\n        yticks=0:2:10)\n    plot!(1:day_cnt, observation.status[1, :], seriestype=:scatter, label=\"working\")\n    title!(\"Number Working or in Repair\")\nend\nwalk_simulation()","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"<img src=\"data:image/png;base64,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\" />","category":"page"},{"location":"reliability/#Distribution-of-Broken-Vehicles-and-Probability-of-Missing-Crew","page":"Reliability","title":"Distribution of Broken Vehicles and Probability of Missing Crew","text":"","category":"section"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"If we were focused more on the small probability that there wouldn't be enough vehicles in the morning to start a full ten, then we want to understand the histogram of how many vehicles are broken on any given day.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"mutable struct ObserveHistogram\n    counts::Array{Int64,2}\n    working::Int64\n    broken::Int64\n    burn::Float64\n    ObserveHistogram(e::Experiment, burn) = new(\n        zeros(Int64, e.workers_max + 1, worker_cnt(e) + 1), 0, 0, burn)\nend\nmust_work(o::ObserveHistogram) = size(o.counts, 1)\ntotal_workers(o::ObserveHistogram) = size(o.counts, 2)\n\nfunction observe(experiment::Experiment, observation::ObserveHistogram, when, which)\n    if when > observation.burn\n        day_start = Int(floor(experiment.time + next_work_time(experiment.time, experiment.start_time)[1]))\n        next_start = Int(floor(when + next_work_time(when, experiment.start_time)[1]))\n        if day_start != next_start\n            observation.counts[observation.working + 1, observation.broken + 1] += 1\n        end\n    end\n\n    who, transition = which\n    if transition == :work\n        observation.working += 1\n    elseif transition == :done\n        observation.working -= 1\n    elseif transition == :break\n        observation.broken += 1\n        observation.working -= 1\n    elseif transition == :repair\n        observation.broken -= 1\n    else\n        @assert transition ∈ (:work, :done, :break, :repair)\n    end\nend;","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"This observer will help us see what happens if we keep the same total number of vehicles but send more out each day for work.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"function compare_across_workers(obs::Vector{ObserveHistogram}, labels, title)\n    firstplot = true\n    cols = palette(:tableau_20, length(obs))\n    for (obs_idx, observation) in enumerate(obs)\n        worker_cnt = total_workers(observation)\n        broken = vec(sum(observation.counts, dims=1))\n        cnt = findlast(broken .> 0)\n        normed = broken[1:cnt] / sum(broken)\n        if firstplot\n            firstplot = false\n            plot(1:cnt, normed, color=cols[obs_idx], seriestype=:scatter, markersize=2.5, label=false)\n            plot!(1:cnt, normed, color=cols[obs_idx], label=labels[obs_idx], legendtitle=\"Crew Size\")\n        else\n            plot!(1:cnt, normed, color=cols[obs_idx], seriestype=:scatter, markersize=2.5, label=false)\n            plot!(1:cnt, normed, color=cols[obs_idx], label=labels[obs_idx])\n        end\n    end\n    xlabel!(\"Count of Broken\")\n    ylabel!(\"Probability Mass\")\n    title!(title)\nend\n\nfunction show_competition_effect()\n    rng = Xoshiro(4377124)\n    observations = ObserveHistogram[]\n    labels = String[]\n    years = 10\n    day_cnt = 365 * years\n    worker_cnt = 20\n    for must_work in [1, 5, 10, 15, 20]\n        experiment = Experiment(worker_cnt, must_work, rng)\n        burn = min(day_cnt ÷ 10, 3650)\n        observation = ObserveHistogram(experiment, burn)\n        run(experiment, observation, day_cnt)\n        push!(observations, observation)\n        push!(labels, string(must_work))\n    end\n\n    compare_across_workers(observations, labels, \"Number Broken as Crew Increases\")\nend\nshow_competition_effect()","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"<img src=\"data:image/png;base64,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\" />","category":"page"},{"location":"reliability/#References","page":"Reliability","title":"References","text":"","category":"section"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"Limnios, Nikolaos, and Gheorghe Oprisan. Semi-Markov processes and reliability. Springer Science & Business Media, 2012.\nZimmermann, Armin. Stochastic discrete event systems. Springer, Berlin Heidelberg New York, 2007.","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"","category":"page"},{"location":"reliability/","page":"Reliability","title":"Reliability","text":"This page was generated using Literate.jl.","category":"page"},{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"These are methods which are defined for any samplers subtyping <:SSA, the abstract sampler type.","category":"page"},{"location":"interface/#Use-a-Sampler","page":"Interface","title":"Use a Sampler","text":"","category":"section"},{"location":"interface/#CompetingClocks.enable!","page":"Interface","title":"CompetingClocks.enable!","text":"enable!(sampler, clock, distribution, enablingtime, currenttime, RNG)\n\nTell the sampler to start a clock.\n\nsampler::SSA{KeyType,TimeType} - The sampler to tell.\nclock::KeyType - The ID of the clock. Can be a string, integer, tuple, etc.\ndistribution::Distributions.UnivariateDistribution\nenablingtime::TimeType - The zero time for the clock's distribution, in absolute time. Usually equal to when.\nwhen::TimeType - The current time of the simulation.\nrng::AbstractRNG - A random number generator.\n\n\n\n\n\nenable!(dc::DirectCall, clock::T, distribution::Exponential, when, rng)\n\nTell the DirectCall sampler to enable this clock. The clock argument is an identifier for the clock. The distribution is a univariate distribution in time. In Julia, distributions are always relative to time t=0, but ours start at some absolute enabling time, t_e, so we provide that here. The when argument is the time at which this clock is enabled, which may be later than when it was first enabled. The rng is a random number generator.\n\nIf a particular clock had one rate before an event and it has another rate after the event, call enable! to update the rate.\n\n\n\n\n\n","category":"function"},{"location":"interface/#CompetingClocks.disable!","page":"Interface","title":"CompetingClocks.disable!","text":"disable!(sampler, clock, when)\n\nTell the sampler to forget a clock. We include the current simulation time because some Next Reaction methods use this to optimize sampling.\n\n\n\n\n\ndisable!(dc::DirectCall, clock::T, when)\n\nTell the DirectCall sampler to disable this clock. The clock argument is an identifier for the clock. The when argument is the time at which this clock is enabled.\n\n\n\n\n\n","category":"function"},{"location":"interface/#CompetingClocks.next","page":"Interface","title":"CompetingClocks.next","text":"next(sampler, when, rng)\n\nAsk the sampler for what happens next, in the form of (when, which)::Tuple{TimeType,KeyType}. rng is a random number generator.\n\n\n\n\n\nnext(dc::DirectCall, when::TimeType, rng::AbstractRNG)\n\nAsk the sampler what clock will be the next to fire and at what time. This does not change the sampler. You can call this multiple times and get multiple answers. Each answer is a tuple of (when, which clock). If there is no clock to fire, then the response will be (Inf, nothing). That's a good sign the simulation is done.\n\n\n\n\n\nnext(multiple_direct, when, rng)\n\nSelects the next transition to fire and when it fires.\n\nThere are two main algorithms for this selection. This implementation handles the case when there are a lot of clocks or when some clocks have much smaller hazards. It first draws a random number to choose which subset of hazards will be used, and then it asks that subset to draw a random number to choose which particular hazard is used. When there are many hazards, it is possible that a random number generator will never choose a particular value because there is no guarantee that a random number generator covers every combination of bits. Using more draws decreases the likelihood of this problem.\n\n\n\n\n\nFor the first reaction sampler, you can call next() multiple times and get different, valid, answers. That isn't the case here. When you call next() on a CombinedNextReaction sampler, it returns the key associated with the clock that fires and marks that clock as fired. Calling next() again would return a nonsensical value.\n\n\n\n\n\n","category":"function"},{"location":"interface/#CompetingClocks.reset!","page":"Interface","title":"CompetingClocks.reset!","text":"reset!(sampler)\n\nAfter a sampler is used for a simulation run, it has internal state. This function resets that internal state to the initial value in preparation for another sample run.\n\n\n\n\n\nreset!(recorder::CommonRandomRecorder)\n\nThe common random recorder records the state of the random number generator for each clock, but the same clock can be enabled multiple times in one simulation, so it records the generator state for each (clock, index of the enabling of that clock). The reset! function says we are starting a new simulation run, so all clocks haven't been seen.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Base.copy!","page":"Interface","title":"Base.copy!","text":"copy!(destination_sampler, source_sampler)\n\nThis copies the state of the source sampler to the destination sampler, replacing the current state of the destination sampler. This is useful for splitting techniques where you make copies of a simulation and restart it with different random number generators.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Query-a-Sampler","page":"Interface","title":"Query a Sampler","text":"","category":"section"},{"location":"interface/#Base.getindex","page":"Interface","title":"Base.getindex","text":"getindex(sampler, clock::KeyType)\n\nReturn stored state for a particular clock. If the clock does not exist, a KeyError will be thrown.\n\n\n\n\n\ngetindex(sampler::FirstReaction{K,T}, clock::K)\n\nFor the FirstReaction sampler, returns the distribution object associated to the clock.\n\n\n\n\n\ngetindex(sampler::FirstToFire{K,T}, clock::K)\n\nFor the FirstToFire sampler, returns the stored firing time associated to the clock.\n\n\n\n\n\ngetindex(sampler::DirectCall{K,T}, clock::K)\n\nFor the DirectCall sampler, returns the rate parameter associated to the clock.\n\n\n\n\n\ngetindex(sampler::CombinedNextReaction{K,T}, clock::K)\n\nFor the CombinedNextReaction sampler, returns the stored firing time associated to the clock.\n\n\n\n\n\ngetindex(sampler::Petri{K,T}, clock::K)\n\nFor the Petri sampler, returns the EnablingEntry time associated to the clock.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Base.keys","page":"Interface","title":"Base.keys","text":"keys(sampler)\n\nReturn all stored clocks as a vector.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Base.keytype","page":"Interface","title":"Base.keytype","text":"keytype(sampler)\n\nReturn the type of clock keys.\n\n\n\n\n\n","category":"function"},{"location":"interface/#CompetingClocks.timetype","page":"Interface","title":"CompetingClocks.timetype","text":"timetype(sampler)\n\nReturn the type of clock times.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Base.length","page":"Interface","title":"Base.length","text":"length(sampler)::Int64\n\nReturn the number of stored clocks.\n\n\n\n\n\n","category":"function"},{"location":"mainloop/#Sample-Main-Loop","page":"Sample Main Loop","title":"Sample Main Loop","text":"","category":"section"},{"location":"mainloop/#Introduction","page":"Sample Main Loop","title":"Introduction","text":"","category":"section"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"Let's walk through a small simulation so that we can see how CompetingClocks could appear in the main loop. This models individuals wandering around on a checkerboard, where no two individuals can occupy the same space. First, let's import libraries.","category":"page"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"import Base\nusing Distributions\nusing Random\nusing SparseArrays\nusing Test\nusing CompetingClocks","category":"page"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"There is a physical state for the model, separate from the state of the bag of clocks and separate from the time. Most of the board is empty, so let's use a spare matrix to represent the locations of individuals.","category":"page"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"mutable struct PhysicalState\n    board::SparseMatrixCSC{Int64, Int64}\nend\n\n# They can move in any of four directions.\n@enum Direction Up Left Down Right\nconst DirectionDelta = Dict(\n    Up => CartesianIndex(-1, 0),\n    Left => CartesianIndex(0, -1),\n    Down => CartesianIndex(1, 0),\n    Right => CartesianIndex(0, 1),\n    );","category":"page"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"The simulation, itself, carries the state of the clocks in the sampler, as well as the physical state. We'll call it a finite state machine (FSM) because it has the traits of a Moore machine.","category":"page"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"mutable struct SimulationFSM{Sampler}\n    physical::PhysicalState\n    sampler::Sampler\n    when::Float64\n    rng::Xoshiro\nend","category":"page"},{"location":"mainloop/#Main-Loop","page":"Sample Main Loop","title":"Main Loop","text":"","category":"section"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"The main loop will ask what event happens next to the state. When that event changes the state, the loop will update the set of possible next events by disabling outdated ones and enabling new ones. The calls to CompetingClocks are:","category":"page"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"next(sampler, current time, random number generator (RNG))\nenable!(sampler, event ID, distribution, current time, start time of clock, RNG)\ndisable!(sampler, event ID, current time)","category":"page"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"There are a lot of samplers in CompetingClocks to choose from. This example uses CombinedNextReaction algorithm, which has good performance for a variety of distributions. Samplers in CompetingClocks require two type parameters, a key type for clocks and the type used to represent time. In this case, the clock key type fully represents an event, giving the ID of the individual, where they start, and which direction they may move.","category":"page"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"const ClockKey = Tuple{Int,CartesianIndex{2},Direction}\n\nfunction run(event_count)\n    Sampler = CombinedNextReaction{ClockKey,Float64}\n    physical = PhysicalState(zeros(Int, 10, 10))\n    @test showable(MIME(\"text/plain\"), physical)\n    sim = SimulationFSM{Sampler}(\n        physical,\n        Sampler(),\n        0.0,\n        Xoshiro(2947223)\n    )\n    initialize!(sim.physical, 9, sim.rng)\n    current_events = allowed_moves(sim.physical)\n    for event_id in current_events\n        enable!(sim.sampler, event_id, Weibull(1.0), 0.0, 0.0, sim.rng)\n    end\n\n    for i in 1:event_count\n        (when, what) = next(sim.sampler, sim.when, sim.rng)\n        if isfinite(when) && !isnothing(what)\n            sim.when = when\n            move!(sim.physical, what)\n            next_events = allowed_moves(sim.physical)\n            for remove_event in setdiff(current_events, next_events)\n                disable!(sim.sampler, remove_event, when)\n            end\n            for add_event in setdiff(next_events, current_events)\n                enable!(sim.sampler, add_event, Weibull(1.0), when, when, sim.rng)\n            end\n            current_events = next_events\n            @show (when, what)\n        end\n    end\nend;","category":"page"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"For this checkerboard with wandering individuals, the allowed moves are moves by any individual to any free square on the board. The set of allowed moves is precisely the set of enabled clocks, so it stores ClockKeys.","category":"page"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"function allowed_moves(physical::PhysicalState)\n    allowed = Set{ClockKey}()\n    row, col, value = findnz(physical.board)\n    for ind_idx in eachindex(value)\n        location = CartesianIndex((row[ind_idx], col[ind_idx]))\n        for (direction, offset) in DirectionDelta\n            if checkbounds(Bool, physical.board, location + offset)\n                if physical.board[location + offset] == 0\n                    push!(allowed, (value[ind_idx], location, direction))\n                end\n            end\n        end\n    end\n    return allowed\nend;","category":"page"},{"location":"mainloop/#Changes-to-the-state-of-the-board","page":"Sample Main Loop","title":"Changes to the state of the board","text":"","category":"section"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"We set up the board with an initializer that places individuals at random. We move one individual at a time, when their next event happens.","category":"page"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"function initialize!(physical::PhysicalState, individuals::Int, rng)\n    physical.board .= 0\n    dropzeros!(physical.board)\n    locations = zeros(CartesianIndex{2}, individuals)\n    for ind_idx in 1:individuals\n        loc = rand(rng, CartesianIndices(physical.board))\n        while physical.board[loc] != 0\n            loc = rand(rng, CartesianIndices(physical.board))\n        end\n        locations[ind_idx] = loc\n        physical.board[loc] = ind_idx\n    end\nend;\n\n\nfunction move!(physical::PhysicalState, event_id)\n    (individual, previous_location, direction) = event_id\n    next_location = previous_location + DirectionDelta[direction]\n    # This sets the previous board value to zero.\n    SparseArrays.dropstored!(physical.board, previous_location.I...)\n    physical.board[next_location] = individual\nend;","category":"page"},{"location":"mainloop/#How-it-runs","page":"Sample Main Loop","title":"How it runs","text":"","category":"section"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"A run of this simulation produces a sequence of moves, no two happening at the same time because this is a continuous-time simulation.","category":"page"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"run(10)","category":"page"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"(when, what) = (0.07319364933011555, (4, CartesianIndex(9, 1), Main.var\"##230\".Down))\n(when, what) = (0.16874877793434204, (2, CartesianIndex(5, 10), Main.var\"##230\".Up))\n(when, what) = (0.1951607095320235, (6, CartesianIndex(8, 8), Main.var\"##230\".Up))\n(when, what) = (0.2118081725791219, (7, CartesianIndex(7, 6), Main.var\"##230\".Left))\n(when, what) = (0.21262700127864034, (6, CartesianIndex(7, 8), Main.var\"##230\".Left))\n(when, what) = (0.23194690792288974, (7, CartesianIndex(7, 5), Main.var\"##230\".Right))\n(when, what) = (0.2634608206635203, (3, CartesianIndex(1, 8), Main.var\"##230\".Down))\n(when, what) = (0.2646327040189687, (9, CartesianIndex(1, 3), Main.var\"##230\".Down))\n(when, what) = (0.36309380269243435, (1, CartesianIndex(7, 10), Main.var\"##230\".Left))\n(when, what) = (0.3635942996465016, (2, CartesianIndex(4, 10), Main.var\"##230\".Down))\n","category":"page"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"","category":"page"},{"location":"mainloop/","page":"Sample Main Loop","title":"Sample Main Loop","text":"This page was generated using Literate.jl.","category":"page"},{"location":"debugging/#Debugging-a-Simulation-that-Uses-CompetingClocks","page":"Debugging a Simulation that Uses CompetingClocks","title":"Debugging a Simulation that Uses CompetingClocks","text":"","category":"section"},{"location":"debugging/","page":"Debugging a Simulation that Uses CompetingClocks","title":"Debugging a Simulation that Uses CompetingClocks","text":"It can be difficult to debug simulations that use time-varying hazards, especially when it's possible to cancel events and re-enable events with new hazard rates. This library provides a few tools to help.","category":"page"},{"location":"debugging/#Sample-Unlikely-Events-with-the-Petri-Sampler","page":"Debugging a Simulation that Uses CompetingClocks","title":"Sample Unlikely Events with the Petri Sampler","text":"","category":"section"},{"location":"debugging/","page":"Debugging a Simulation that Uses CompetingClocks","title":"Debugging a Simulation that Uses CompetingClocks","text":"If your simulation has rare events, and you want to test code paths for those rare events, one approach is to sample the next clock entirely randomly. The Petri sampler ignores the distribution of times for events and picks the next event evenly among all enabled keys.","category":"page"},{"location":"debugging/","page":"Debugging a Simulation that Uses CompetingClocks","title":"Debugging a Simulation that Uses CompetingClocks","text":"petri_sampler = Petri{K,T}()\nenable!(tw, 3, Exponential(100.0), 0.0, 0.0, rng)\nwhen, what = next(petri_sampler, now, rng)\n@assert abs(when - now - 1) <= 1e-9","category":"page"},{"location":"debugging/","page":"Debugging a Simulation that Uses CompetingClocks","title":"Debugging a Simulation that Uses CompetingClocks","text":"It also returns a time that is one plus the current time.","category":"page"},{"location":"debugging/#Keep-History-of-Enabling-and-Disabling","page":"Debugging a Simulation that Uses CompetingClocks","title":"Keep History of Enabling and Disabling","text":"","category":"section"},{"location":"debugging/","page":"Debugging a Simulation that Uses CompetingClocks","title":"Debugging a Simulation that Uses CompetingClocks","text":"The DebugWatcher records every time an event is enabled or disabled. You wouldn't normally want to use all of this time and memory (and memory churn), but it can be helpful to see the trace of all events enabled and disabled, in addition to those that fired.","category":"page"},{"location":"guide/#Competing-Clocks","page":"Competing Clocks","title":"Competing Clocks","text":"","category":"section"},{"location":"guide/","page":"Competing Clocks","title":"Competing Clocks","text":"A discrete event simulation tracks the effects of individual events in time. We classify discrete event simulations by the pace of advances in time. If time advances in steps of the same size, it is a discrete-time simulation. If time advances to the next event, whenever that event might happen, it is continuous-time simulation. This library supports continuous-time discrete-event simulations.","category":"page"},{"location":"guide/","page":"Competing Clocks","title":"Competing Clocks","text":"We write discrete event simulations by defining the state of a system and events that can act on that state. The state of a system can be the count of each chemical species for a chemical reaction system. It can be different numbers of chickens at different weights in different chicken coops for a farming simulation. It can be the age of each widget in an engine for a reliability simulation. These states are called the physical state of the system and vary widely in what they represent.","category":"page"},{"location":"guide/","page":"Competing Clocks","title":"Competing Clocks","text":"An event is an observable change of state at a time. It is a function where the argument is the current state of the system and the return value is the new state of the system. We say an event occurs, happens, or fires when we apply that function to the state. How that state changes is up to the model and how it defines the state, but what about when that state changes?","category":"page"},{"location":"guide/","page":"Competing Clocks","title":"Competing Clocks","text":"Given the current state of the system, there is a set of possible next events which could happen. We call the possible next events enabled. Think of the moment in time just after the simulation has begun or an event has just happened. At this moment, there may be multiple enabled events. Which one is next depends on how often that event happens. If our simulation includes both the radioactive decay of an unstable element and decay of iron, the unstable element will usually decay first. We describe the rates of these events using probability distributions in time. Each event has an associated continuous univariate distribution where the variable is time.","category":"page"},{"location":"guide/","page":"Competing Clocks","title":"Competing Clocks","text":"We can think of all event distributions in a model as a bag of clocks. The next one to ring is the next event to occur. When that event occurs, the state changes. When the state changes, it will enable some events and disable others. Enabled events are added to the bag of clocks. Disabled ones are removed. CompetingClocks is responsible for managing this bag of clocks.","category":"page"},{"location":"guide/#Sets-of-Clocks","page":"Competing Clocks","title":"Sets of Clocks","text":"","category":"section"},{"location":"guide/","page":"Competing Clocks","title":"Competing Clocks","text":"In CompetingClocks, clocks can be either enabled or disabled. The firing of clocks triggers events, which change the state of the system. This in turn changes the set of clocks that are enabled. This is the basic algorithm to sample models that are phrased as continuous-time discrete-event systems.","category":"page"},{"location":"guide/","page":"Competing Clocks","title":"Competing Clocks","text":"It is worth examining what happens at a state update in more detail. Let E^* be the set of clocks (typically, just a single clock) that fires, and whose associated event updates state from S to S^. There are then three basic sets of clocks to consider: E(S), the set of clocks enabled in S, E(S^), the set of clocks enabled in S^, and E^*, the set of clocks that fired.","category":"page"},{"location":"guide/","page":"Competing Clocks","title":"Competing Clocks","text":"Newly enabled clocks are those that are enabled in S^ not part of the set that was enabled in S and remains enabled in S^. Newly disabled clocks are those that were enabled in S but are not enabled in S^. Finally old clocks are those that were enabled in S, and remain so in S^.","category":"page"},{"location":"guide/","page":"Competing Clocks","title":"Competing Clocks","text":"All these sets are visualized in the figure below, reproduced from \"Stochastic petri nets: Modelling, stability, simulation\" by Peter J. Haas (2002).","category":"page"},{"location":"guide/","page":"Competing Clocks","title":"Competing Clocks","text":"(Image: )","category":"page"},{"location":"guide/","page":"Competing Clocks","title":"Competing Clocks","text":"CompetingClocks is responsible for knowing E^*, but it is the main event loop of the simulation using CompetingClocks that decides which clocks to disable and enable.","category":"page"},{"location":"guide/#References","page":"Competing Clocks","title":"References","text":"","category":"section"},{"location":"guide/","page":"Competing Clocks","title":"Competing Clocks","text":"[Haas:2006]\tPJ. Haas, “Stochastic petri nets: Modelling, stability, simulation,” Springer Science & Business Media, 2006.","category":"page"},{"location":"vas/#Vector-Addition-System","page":"Vector Addition System","title":"Vector Addition System","text":"","category":"section"},{"location":"vas/","page":"Vector Addition System","title":"Vector Addition System","text":"One way to understand how to use CompetingClocks is to look at a very simple simulation. A vector addition system (VAS) is a lot like chemical simulations, but it's free of some of the assumptions about chemical rates. The physical state of the system is a vector of integers. Such a simple physical state can make it easier to understand possible complications in how we define events.","category":"page"},{"location":"vas/","page":"Vector Addition System","title":"Vector Addition System","text":"There are variations on how to define a vector addition system. Let's begin with one and introduce variations as they become interesting.","category":"page"},{"location":"vas/","page":"Vector Addition System","title":"Vector Addition System","text":"A vector addition system is","category":"page"},{"location":"vas/","page":"Vector Addition System","title":"Vector Addition System","text":"a physical state p which is a set of d integers, labeled (p_1 p_2cdots p_d).\na system time, t\na finite set of events E where each event has an enabling rule, a distribution, and a firing rule.\na rule for when the event is enabled, where the rule is an invariant on the physical state, such as r_i(p)ge 0. When the invariant is met, the event is enabled. When the invariant is not met, the event is disabled. For a vector addition system, this rule must be expressible as a matrix multiplication, so Mcdot vecp ge 0, where the ge means we are checking elementwise that every element is non-negative.\na distribution in time, where the distribution is determined at enabling time and is a function of the physical state and system time at enabling. The distribution in time can have shocks, such as a delta function, but it may not have a shock at time zero, must have a measure-zero probability of firing at the same moment it is enabled.\na rule for how the event changes physical state when it happens. The domain and co-domain of the rule are physical states of the system. Let's limit this model to require all events to modify the state, so that we exclude events that don't modify the state. As with enabling, this must be expressible as a matrix operation on the physical states to produce a new physical state.\nFrom the rules, we see that an event's state is either disabled or enabled at an enabling time t_e.","category":"page"},{"location":"vas/","page":"Vector Addition System","title":"Vector Addition System","text":"How would we implement this system? It's set up so that enabling rules and firing rules can be done with linear algebra. We can write this in Julia code ","category":"page"},{"location":"vas/","page":"Vector Addition System","title":"Vector Addition System","text":"Simulation using the VAS requires concrete implementation of the interface:","category":"page"},{"location":"vas/","page":"Vector Addition System","title":"Vector Addition System","text":"zero_state(vas::VectorAdditionSystem)\nvas_delta(vas::VectorAdditionSystem, transition_idx)\nvas_initial(vas::VectorAdditionSystem, initial_state)\nfire!(visitor, vas::VectorAdditionSystem, state, modify_state, rng)\nsimstep!(fsm::VectorAdditionFSM, state_update::Function, rng::AbstractRNG)","category":"page"},{"location":"vas/","page":"Vector Addition System","title":"Vector Addition System","text":"The method fire! first modifies state, then, for each clock in the system, it checks whether it has been newly enabled or disabled.","category":"page"},{"location":"vas/","page":"Vector Addition System","title":"Vector Addition System","text":"newly disabled: visitor is called to disable that transition\nnewly enabled: visitor is called to enable that transition and cache its newly calculated intensity\nstill enabled: we check if the new intensity differs from the old and if so use visitor to update the intensity","category":"page"},{"location":"vas/","page":"Vector Addition System","title":"Vector Addition System","text":"The method simstep! first applies fire!, followed by next.","category":"page"},{"location":"reference/#Samplers","page":"Samplers","title":"Samplers","text":"","category":"section"},{"location":"reference/","page":"Samplers","title":"Samplers","text":"The choice of sampler determines specific algorithms that are used to sample, update, and disable clocks. Helpers also exist that are useful for logging, utilizing common random numbers, and hierarchical sampling.","category":"page"},{"location":"reference/#Sampler-Supertype","page":"Samplers","title":"Sampler Supertype","text":"","category":"section"},{"location":"reference/#CompetingClocks.SSA","page":"Samplers","title":"CompetingClocks.SSA","text":"SSA{KeyType,TimeType}\n\nThis abstract type represents a stochastic simulation algorithm (SSA). It is parametrized by the clock ID, or key, and the type used for the time, which is typically a Float64. The type of the key can be anything you would use as a dictionary key. This excludes mutable values but includes a wide range of identifiers useful for simulation. For instance, it could be a String, but it could be a Tuple{Int64,Int64,Int64}, so that it indexes into a complicated simulation state.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Sampler-Types","page":"Samplers","title":"Sampler Types","text":"","category":"section"},{"location":"reference/#CompetingClocks.FirstReaction","page":"Samplers","title":"CompetingClocks.FirstReaction","text":"FirstReaction{KeyType,TimeType}()\n\nThis is the classic first reaction method for general distributions.  Every time you sample, this goes to each distribution and asks when it would fire. Then it takes the soonest and throws out the rest of the sampled times until the next sample. It can also be very fast when there are only a few clocks to sample.\n\nOne interesting property of this sampler is that you can call next() multiple times in order to get a distribution of next firing clocks and their times to fire.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CompetingClocks.FirstToFire","page":"Samplers","title":"CompetingClocks.FirstToFire","text":"FirstToFire{KeyType,TimeType}()\n\nThis sampler is often the fastest for non-exponential distributions. When a clock is first enabled, this sampler asks the clock when it would fire and saves that time in a sorted heap of future times. Then it works through the heap, one by one. When a clock is disabled, its future firing time is removed from the list. There is no memory of previous firing times.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CompetingClocks.DirectCall","page":"Samplers","title":"CompetingClocks.DirectCall","text":"DirectCall{KeyType,TimeType,TreeType}()\n\nDirectCall is responsible for sampling among Exponential distributions. It samples using the Direct method. In this case, there is no optimization to that Direct method, so we call it DirectCall because it recalculates everything every time you call it.\n\nThe algorithm for the Direct Method relies heavily on what data structure it uses to maintain a list of hazard rates, such that it can know the sum of those hazards and index into them using a random value. This struct has a default constructor that chooses a data structure for you, but there are several options.\n\nExample\n\nIf we know that our simulation will only use a small number of different clock keys, then it would make sense to use a data structure that disables clocks by zeroing them out, instead of removing them from the list. This will greatly reduce memory churn. We can do that by changing the underlying data structure.\n\nprefix_tree = BinaryTreePrefixSearch{T}()\nkeyed_prefix_tree = KeyedKeepPrefixSearch{K,typeof(prefix_tree)}(prefix_tree)\nsampler_noremove = DirectCall{K,T,typeof(keyed_prefix_tree)}(keyed_prefix_tree)\n\n\n\n\n\n","category":"type"},{"location":"reference/#CompetingClocks.CombinedNextReaction","page":"Samplers","title":"CompetingClocks.CombinedNextReaction","text":"CombinedNextReaction{KeyType,TimeType}()\n\nThis combines Next Reaction Method and Modified Next Reaction Method. The Next Reaction Method is from Gibson and Bruck in their 2000 paper called \"Efficient Exact Stochastic Simulation of Chemical Systems with Many Species and Many Channels\".  The Modified Next Reaction Method is from David F. Anderson's 2007 paper,  \"A modified Next Reaction Method for simulating chemical systems with time dependent propensities and delays\".  Both methods reuse draws of random numbers. The former works by accumulating  survival of a distribution in a linear space and the latter works by accumulating  survival of a distribution in a log space.\n\nEach enabled clock specifies a univariate distribution from the Distributions package. Every distribution is more precise being sampled in the manner of the Next Reaction method (linear space) or the manner of the Modified Next Reaction method (log space). This sampler chooses which space to use depending on the type of the UnivariateDistribution and based on performance timings that are done during package testing. Defaults are set for those distributions included in the Distributions.jl package. If you want to add a distribution, then define:\n\nsampling_space(::MyDistribution) = LogSampling\n\nIf you want to override a choice in the library, then create a sub-type of the given distribution, and specify its sampling space.\n\nstruct LinearGamma <: Distributions.Gamma end\nsampling_space(::LinearGamma) = LinearSampling\n\nIf you want to test a distribution, look at tests/nrmetric.jl to see how distributions are timed.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Sampling-Helpers","page":"Samplers","title":"Sampling Helpers","text":"","category":"section"},{"location":"reference/#CompetingClocks.CommonRandomRecorder","page":"Samplers","title":"CompetingClocks.CommonRandomRecorder","text":"Common random variates, also called common random numbers (CRN), are a technique for reducing variance when repeating runs of simulations with different parameters. The idea is to record the randomness of one simulation and replay the same choices in subsequent runs. This particular implementation does this by saving the state of the random number generator every time it's used by a sampler.\n\nThe Xoshiro sampler has a relatively small state (32 bytes), which is saved every time the sampler uses random numbers. This CRN recorder saves data in memory, but we could save that to a memory-mapped file so that the operating system will optimize transfer of that memory to disk.\n\nWhat happens when replays of simulation runs use more draws than the first, recorded simulation? Those simulations draw from a fresh random number generator. This is not an exact approach.\n\nExample\n\nThe goal is to run the simulation with ten different parameter sets and measure how much different parameters change the mean of some quantity determined by the trajectories.\n\nusing Random: Xoshiro\nusing CompetingClocks\nexample_clock = (3, 7)  # We will use clock IDs that are a tuple of 2 integers.\nsampler = FirstToFire{typeof(example_clock)}()\ncrn_sampler = CommonRandomRecorder(sampler, typeof(example_clock), Xoshiro)\nfor trial_idx in 1:100\n    run_simulation(model, crn_sampler)\n    reset!(crn_sampler)\nend\nfor param_idx in 1:10\n    each_model = modify_model!(model, param_idx)\n    run_simulation(each_model, crn_sampler)\n    reset!(crn_sampler)\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#CompetingClocks.freeze","page":"Samplers","title":"CompetingClocks.freeze","text":"freeze(cr::CommonRandomRecorder)::FrozenCommonRandomRecorder\n\nThe CommonRandomRecorder records every time it sees a clock request random number generation. It continues to do that every time it runs, which is a problem if you run simulations for comparison on multiple threads. If you want to use CRN and to use multiple threads for subsequent simulation runs, then first run the simulation a bunch of times on one thread. Then freeze the simulation, and then the frozen version will stop remembering new threads.\n\nThere is one part of the frozen recorder that will be mutable because it's useful for debugging, the record of missed clocks. Freeze a recorder for each thread, and each thread will track its own misses. They will all work from the same copy of the recorded random number generator states.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.haskey","page":"Samplers","title":"Base.haskey","text":"haskey(sampler, key)\n\nReturn a boolean.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CompetingClocks.misscount","page":"Samplers","title":"CompetingClocks.misscount","text":"misscount(recorder::CommonRandomRecorder)\n\nThe common random recorder watches a simulation and replays the states of the random number generator on subsequent runs. This counts the number of times during the most recent run that a clock event happened that could not be replayed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CompetingClocks.misses","page":"Samplers","title":"CompetingClocks.misses","text":"misses(recorder::CommonRandomRecorder)\n\nThis iterates over pairs of misses in the common random recorder during the most recent simulation run, where the start of a simulation run was marked by calling reset!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CompetingClocks.MultiSampler","page":"Samplers","title":"CompetingClocks.MultiSampler","text":"MultiSampler{SamplerKey,Key,Time}(which_sampler::Chooser) <: SSA{Key,Time}\n\nA sampler returns the soonest event, so we can make a hierarchical sampler that returns the soonest event of the samplers it contains. This is useful because the performance of a sampler depends on the type of the event. For instance, some simulations have a few fast events and a lot of slow ones, so it helps to split them into separate data structures.\n\nThe SamplerKey is the type of an identifier for the samplers that this MultiSampler contains. The which_sampler argument is a strategy object that decides which event is sampled by which contained sampler. There is an example of this below.\n\nOnce a clock is first enabled, it will always go to the same sampler. This sampler remembers the associations, which could increase memory for simulations with semi-infinite clocks.\n\nExamples\n\nLet's make one sampler for exponential distributions, one for a few clocks we know will be fast and one for slower clocks. We can name them with symbols. The trick is that we need to direct each kind of distribution to the correct sampler. Use a Float64 for time and each clock can be identified with an Int64.\n\nusing CompetingClocks\nusing Distributions: Exponential, UnivariateDistribution\n\nstruct ByDistribution <: SamplerChoice{Int64,Symbol} end\n\nfunction CompetingClocks.choose_sampler(\n    chooser::ByDistribution, clock::Int64, distribution::Exponential\n    )::Symbol\n    return :direct\nend\nfunction CompetingClocks.choose_sampler(\n    chooser::ByDistribution, clock::Int64, distribution::UnivariateDistribution\n    )::Symbol\n    if clock < 100\n        return :fast\n    else\n        return :slow\n    end\nend\nsampler = MultiSampler{Symbol,Int64,Float64}(ByDistribution())\nsampler[:direct] = OptimizedDirect{Int64,Float64}()\nsampler[:fast] = FirstToFire{Int64,Float64}()\nsampler[:slow] = FirstToFire{Int64,Float64}()\n\n\n\n\n\n","category":"type"},{"location":"reference/#CompetingClocks.ChatReaction","page":"Samplers","title":"CompetingClocks.ChatReaction","text":"This sampler can help if it's the first time you're trying a model. It checks all of the things and uses Julia's logger to communicate them. It samples using the first reaction algorithm.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CompetingClocks.Petri","page":"Samplers","title":"CompetingClocks.Petri","text":"Petri{KeyType,TimeType}()\n\nIf you want to test a simulation, it can be helpful to test unlikely events. This sampler adopts the Petri net rule for which clock fires next: it's randomly chosen among all enabled events. The returned time is always the previous time plus one.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CompetingClocks.DebugWatcher","page":"Samplers","title":"CompetingClocks.DebugWatcher","text":"DebugWatcher()\n\nFor debugging, it helps to have visibility into the simulation. This Watcher records everything that is enabled or disabled as a list of all enables and all disabled. It's the complete event history, and you can think of it as the filtration for the process going forward.\n\nwatcher = DebugWatcher{String}()\n# enable and disable some things.\n(watcher.enabled[1].clock,\nwatcher.enabled[1].distribution,\nwatcher.enabled[1].te,\nwatcher.enabled[1].when)\n\n\n\n\n\n","category":"type"},{"location":"reference/#CompetingClocks.TrackWatcher","page":"Samplers","title":"CompetingClocks.TrackWatcher","text":"TrackWatcher{K,T}()\n\nThis Watcher doesn't sample. It records everything enabled. You can iterate over enabled clocks with a for-loop. If we think of the model as providing changes in which transitions are enabled or disabled, this Watcher accumulates those changes to provide a consistent list of all enabled transitions. Together, a model and this Watcher provide the Semi-Markov core matrix, or the row of it that is currently known.\n\nfor entry in tracker\n    entry.clock\n    entry.distribution\n    entry.te\n    entry.when\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#CompetingClocks.consume_survival","page":"Samplers","title":"CompetingClocks.consume_survival","text":"This updates the survival for a transition in the linear space, according to Gibson and Bruck. Transition was enabled between time record t0 and tn. Divide the survival by the conditional survival between t0 and tn. te can be before t0, at t0, between t0 and tn, or at tn, or after t_n.\n\nu=expleft(-int_t_e^t_nlambda_0(s-t_e)dsright)expleft(-int_t_n^taulambda_n(s-t_e)dsright)\n\n\n\n\n\nThis updates the survival for a transition in log space, according to Anderson's method.\n\nln u=-int_t_e^t_nlambda_0(s-t_e)ds - int_t_n^taulambda_n(s-t_e)ds\n\n\n\n\n\n","category":"function"},{"location":"reference/#CompetingClocks.sampling_space","page":"Samplers","title":"CompetingClocks.sampling_space","text":"This function decides whether a particular distribution can be sampled faster and more accurately using its cumulative distribution function or using the log of its cumulative distribution function, also called the integrated hazard. The former is used for the Next Reaction method by Gibson and Bruck. The latter is used by the Modified Next Reaction method of Anderson. We are calling the first a linear space and the second a logarithmic space.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CompetingClocks.steploglikelihood","page":"Samplers","title":"CompetingClocks.steploglikelihood","text":"steploglikelihood(tw::TrackWatcher, now, when, which_fires)\n\nCalculate the log-likelihood of a single step in which the which_fires transition fires next. now is the current time. when is the time when which_fires happens so when > now. You have to call this before the transition fires so that it is before transitions are enabled and disabled from the previous step.\n\n\n\n\n\n","category":"function"},{"location":"distrib/#Notation-for-Distributions","page":"Notation for Distributions","title":"Notation for Distributions","text":"","category":"section"},{"location":"distrib/","page":"Notation for Distributions","title":"Notation for Distributions","text":"This defines notation for subsequent sections.","category":"page"},{"location":"distrib/#Notation","page":"Notation for Distributions","title":"Notation","text":"","category":"section"},{"location":"distrib/","page":"Notation for Distributions","title":"Notation for Distributions","text":"First, let's affix notation. The cumulative distribution function of every regular distribution can be written as an integral over its hazard rate, lambda","category":"page"},{"location":"distrib/","page":"Notation for Distributions","title":"Notation for Distributions","text":"F(t)=1-e^-int_0^t lambda(s)ds","category":"page"},{"location":"distrib/","page":"Notation for Distributions","title":"Notation for Distributions","text":"All algorithms for stochastic simulation treat distributions as being defined in absolute time, specified as an enabling time, t_e,","category":"page"},{"location":"distrib/","page":"Notation for Distributions","title":"Notation for Distributions","text":"F(t t_e)=1-e^-int_0^t-t_e lambda(s)ds","category":"page"},{"location":"distrib/","page":"Notation for Distributions","title":"Notation for Distributions","text":"Working with distributions in absolute time is a simple shift of the time scale and will be ignored in further discussions, although the enabling time, t_e, will certainly appear in code.","category":"page"},{"location":"distrib/","page":"Notation for Distributions","title":"Notation for Distributions","text":"The density function is the derivative of the cumulative distribution function,","category":"page"},{"location":"distrib/","page":"Notation for Distributions","title":"Notation for Distributions","text":"f(t)=fracdF(t)dt=lambda(t)e^-int_0^t lambda(s)ds","category":"page"},{"location":"distrib/","page":"Notation for Distributions","title":"Notation for Distributions","text":"The survival is","category":"page"},{"location":"distrib/","page":"Notation for Distributions","title":"Notation for Distributions","text":"G(t)=1-F(t)=e^-int_0^t lambda(s)ds","category":"page"},{"location":"distrib/","page":"Notation for Distributions","title":"Notation for Distributions","text":"Because survival is multiplicative, we further label the survival from time t_0 to t_1 as","category":"page"},{"location":"distrib/","page":"Notation for Distributions","title":"Notation for Distributions","text":"G(t_0 t_1)=fracG(t_1)G(t_0)=e^-int_t_0^t_1 lambda(s)ds","category":"page"},{"location":"distrib/#Using-Julia's-Distributions","page":"Notation for Distributions","title":"Using Julia's Distributions","text":"","category":"section"},{"location":"distrib/","page":"Notation for Distributions","title":"Notation for Distributions","text":"Julia's continuous univariate distributions support a common interface.","category":"page"},{"location":"distrib/","page":"Notation for Distributions","title":"Notation for Distributions","text":"In this table, d is the distribution, t is the time, and q is a quantile.","category":"page"},{"location":"distrib/","page":"Notation for Distributions","title":"Notation for Distributions","text":"Julia call Notation\ncdf(d,t) F(t)\nquantile(d,q) F^-1(q)\nlogcdf(d,t) ln(F(t))\nccdf(d,t) G(t)\nlogccdf(d,t) -int_0^t lambda(s)ds\nquantile(d,q) F^-1(q)\ncquantile(d,q) F^-1(1-q)=G^-1(q)\ninvlogcdf(d,lp) F^-1(e^l_p)\ninvlogccdf(d,lp) G^-1(e^l_p) or -int_0^t(l_p)lambda(s)ds=l_p\nrandexp(rng) -ln(1-U)","category":"page"},{"location":"algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Many samplers depend on data structures to allow efficient querying of clocks ordered with respect to some value, usually the firing time. These types and methods implement them for CompetingClocks.","category":"page"},{"location":"algorithms/#CompetingClocks.CumSumPrefixSearch","page":"Algorithms","title":"CompetingClocks.CumSumPrefixSearch","text":"CumSumPrefixSearch{T}()\n\nThis stores hazard rates in order to make it easier for the Direct method to sample them. This version is the dumbest possible, but it can be faster when there are few hazards enabled. It uses a simple array and, each time the Direct method samples, this evaluates the cumulative sum of the array.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#CompetingClocks.BinaryTreePrefixSearch","page":"Algorithms","title":"CompetingClocks.BinaryTreePrefixSearch","text":"BinaryTreePrefixSearch{T}(N=32)\n\nThis stores hazard rates to make them faster for the Direct method to sample. This is a binary tree where the leaves are values and the nodes are sums of those values. It is meant to make it easier to find the leaf such that the sum of it and all previous leaves is greater than a given value.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#CompetingClocks.KeyedKeepPrefixSearch","page":"Algorithms","title":"CompetingClocks.KeyedKeepPrefixSearch","text":"This decorator turns a Prefix Search algorithm into one that works for arbitrary keys. This version only adds entries, so disabling a clock sets its hazard to zero without removing it. If a simulation re-enables the same set of clocks, this is the faster choice.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#CompetingClocks.KeyedRemovalPrefixSearch","page":"Algorithms","title":"CompetingClocks.KeyedRemovalPrefixSearch","text":"This decorator turns a Prefix Search algorithm into one that works for arbitrary keys. This version reuses entries in the prefix search after their clocks have been disabled. If the simulation moves through a large key space, this will use less memory.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#CompetingClocks.choose","page":"Algorithms","title":"CompetingClocks.choose","text":"choose(pst::BinaryTreePrefixSearch, value)\n\nFind the minimum index such that the prefix is greater than the given value.\n\nPrecondition: The value must be strictly less than the total for the tree.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#Base.setindex!","page":"Algorithms","title":"Base.setindex!","text":"setindex!(A, X, inds...)\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#Base.rand","page":"Algorithms","title":"Base.rand","text":"rand(rng, sampler::SamplerTrivial{BinaryTreePrefixSearch})\n\nThis method overload allows the machinery of Random to generate random variates from the BinaryTreePrefixSearch set of values.\n\n\n\n\n\nrand(rng, sampler::SamplerTrivial{CumSumPrefixSearch})\n\nThis method overload allows the machinery of Random to generate random variates from the CumSumPrefixSearch set of values.\n\n\n\n\n\nDrawing a random number from a left-truncated exponential is particularly simple.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#CompetingClocks.set_multiple!","page":"Algorithms","title":"CompetingClocks.set_multiple!","text":"If there are multiple values to enter, then present them at once as pairs of tuples, (index, value).\n\n\n\n\n\n","category":"function"},{"location":"objects/#Objects-in-CompetingClocks","page":"Objects in CompetingClocks","title":"Objects in CompetingClocks","text":"","category":"section"},{"location":"objects/","page":"Objects in CompetingClocks","title":"Objects in CompetingClocks","text":"This describes the kinds of objects in CompetingClocks in order to explain how they work together.","category":"page"},{"location":"objects/#Distribution","page":"Objects in CompetingClocks","title":"Distribution","text":"","category":"section"},{"location":"objects/","page":"Objects in CompetingClocks","title":"Objects in CompetingClocks","text":"At the heart of simulations are probability distributions. When this code refers to a distribution, it means a probability distribution function in time. When we sample a distribution, we randomly draw a time at which an event will happen.","category":"page"},{"location":"objects/","page":"Objects in CompetingClocks","title":"Objects in CompetingClocks","text":"Let's take a Gamma distribution as an example. For the Gamma distribution, the probability distribution function, as you see it in Wikipedia's description,","category":"page"},{"location":"objects/","page":"Objects in CompetingClocks","title":"Objects in CompetingClocks","text":"f(x) = fracbeta^alphaGamma(alpha)x^alpha - 1e^-beta x","category":"page"},{"location":"objects/","page":"Objects in CompetingClocks","title":"Objects in CompetingClocks","text":"For a simulation, we think of the distribution as being over time, and it's over the time since it was first possible for the event to happen, called t_e. We can write the Gamma distribution for t-t_e.","category":"page"},{"location":"objects/","page":"Objects in CompetingClocks","title":"Objects in CompetingClocks","text":"f(t-t_e) = fracbeta^alphaGamma(alpha)(t-t_e)^alpha - 1e^-beta (t-t_e)","category":"page"},{"location":"objects/","page":"Objects in CompetingClocks","title":"Objects in CompetingClocks","text":"In Julia, the univariate distributions don't carry their enabling time as a parameter, so we store it separately.","category":"page"},{"location":"objects/#Competing-Clocks","page":"Objects in CompetingClocks","title":"Competing Clocks","text":"","category":"section"},{"location":"objects/","page":"Objects in CompetingClocks","title":"Objects in CompetingClocks","text":"Let's say you make a simulation of rabbits eating kibble. A rabbit just picked up a piece of kibble, and the simulation decides there is a Gamma-distributed time at which it will be ready to eat the next bit of kibble. Meanwhile, another rabbit eats the last bit of kibble. That makes it impossible for the first rabbit to eat any kibble, so we say that its event is interrupted. That interruption was a result of the rabbits competing, but what the simulation sees is distributions competing to fire first, and we call them competing clocks.","category":"page"},{"location":"objects/","page":"Objects in CompetingClocks","title":"Objects in CompetingClocks","text":"We have a small naming problem because, while simulations use distributions in time, they sometimes turn them on or off. This combination of a known distribution (such as an Exponential or Gamma distribution) and the ability to temporarily pause it creates its own probability distribution, which we call a clock.","category":"page"},{"location":"objects/","page":"Objects in CompetingClocks","title":"Objects in CompetingClocks","text":"For example, let's make a model of a random walker on a chessboard. Given that the walker is at a grid location, (i j), that walker can move to one of four directions, (i-1 j), (i+1 j), (i j-1), or (i j+1). In order to simulate this, we might choose four Exponential distributions, one for each direction. When the walker reaches the side of the chessboard, it doesn't make sense to let it walk off the chessboard, so, at that moment, the simulation disables the ability to walk left. There is an Exponential distribution associated with walking left, but its hazard rate will be zero while the piece is at the side of the chessboard. The simulation considers \"move left\" a clock with an Exponential distribution whose firing is disabled.","category":"page"},{"location":"objects/#Sampler","page":"Objects in CompetingClocks","title":"Sampler","text":"","category":"section"},{"location":"objects/","page":"Objects in CompetingClocks","title":"Objects in CompetingClocks","text":"The main responsibility of CompetingClocks.jl is to provide samplers of competing clocks. Given a list of enabled distributions, decide which one is next to fire and when it will fire.","category":"page"},{"location":"objects/","page":"Objects in CompetingClocks","title":"Objects in CompetingClocks","text":"In order to decide which clock fires next, a sampler needs some information.","category":"page"},{"location":"objects/#Initialization","page":"Objects in CompetingClocks","title":"Initialization","text":"","category":"section"},{"location":"objects/","page":"Objects in CompetingClocks","title":"Objects in CompetingClocks","text":"The sampler may have a constructor to configure its memory usage or other resources.","category":"page"},{"location":"objects/#Update-Clock-State","page":"Objects in CompetingClocks","title":"Update Clock State","text":"","category":"section"},{"location":"objects/","page":"Objects in CompetingClocks","title":"Objects in CompetingClocks","text":"For a continuous-time simulation, each event happens at a distinct time. Right after an event happens, the simulation is changed, and there are three possible ways clocks are affected.","category":"page"},{"location":"objects/","page":"Objects in CompetingClocks","title":"Objects in CompetingClocks","text":"A clock may be disabled. For instance, if the event was crashing a car, you can no longer crash a crashed car.\nA clock may be enabled. For instance, once a person is infected, they can now infect all neighboring people.\nThe rate of a clock may change. We discussed moves on a chessboard earlier. Maybe there's now a breeze so that the rate to move right is greater than the rate to move left. The Exponential distributions would change accordingly.","category":"page"},{"location":"gsmp/#Generalized-Semi-Markov-processes","page":"GSMP","title":"Generalized Semi-Markov processes","text":"","category":"section"},{"location":"gsmp/#Definition","page":"GSMP","title":"Definition","text":"","category":"section"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"We said that a semi-Markov process is a set of random variables representing states and times of a system, X_iT_i. For each state at time T_i, the probability of the next state and time is some distribution, PX_i+1T_i+1X_iT_i. A generalized semi-Markov process (GSMP) also has the same states and times an the same distribution of next states and times, but it's more specific about how to calculate the probability.","category":"page"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"For a GSMP, every change in state of the system, from X_i to X_i+1, is the result of an event E_j. Each event is associated with a distribution of event times, also called firing times, and those times are distributed as f_j(tau) where tau=t-T_i. The probability of the next state and time is determined by the minimum firing time of all events enabled at (X_iT_i). The distributions of these events are our competing clocks. When one event fires, it changes the state of the system, and, as a result, some events may be disabled and new events may be enabled.","category":"page"},{"location":"gsmp/#Considerations","page":"GSMP","title":"Considerations","text":"","category":"section"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"Once we create this separate object, the event, it raises questions about corner cases. If two events change the state in the same way, then they are the same as one event whose hazard rate is the sum of the two events. If an event does not change the state, then this is like a self-loop in a Markov chain, and it complicates how we count states. As with the semi-Markov process, there remains the question of events which are immediate. If an event can happen at T_i+1=T_i, then it is possible for a system to fail to progress to a later time, and that's a problem.","category":"page"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"The GSMP is a specific form of a semi-Markov process that requires PT_i+1X_iT_i (note the X_i+1 isn't on the left side) be determined by the minimum time to the next event, so it is determined solely by the f_j(tau). Each event is also defined by how it changes the state. If events change the state in a deterministic way, such that there is some function X_i+1=chi_j(X_i), then the likelihood of the system is the product of PX_i+1T_i+1X_iT_i for each time step, determined by the mimimum of event times. It is traditional to define generalized stochastic Petri nets [Haas:2002] this way, and Anderson and Kurtz's excellent short manuscript presents GSMP in the same light using counting processes [Anderson:2015]. However, Haas describes GSMP as allowing events to be stochastic. This means the likelihood has two terms, PE_jT_i+1X_iT_iPX_i+1E_j T_i+1 X_iT_i.","category":"page"},{"location":"gsmp/#Events-and-Physical-State","page":"GSMP","title":"Events and Physical State","text":"","category":"section"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"Glynn presented GSMP by distinguishing the physical state of the system from the clock state [Glynn:1989], and Shedler is known for having the clearest presentation [Shedler:1987]. He represented the physical state as a set of states p=(p_1p_2p_3). Then each event, E_j, is defined in relation to those physical states:","category":"page"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"An event is enabled by an enabling function which depends on a subset of physical states. This is a function e(p_lT_i)rightarrow textbool. In this notation, the curly bracked  indicate a \"set of\" something.\nWhen the event is not enabled, it is disabled.\nThe distribution of event times for an event is determined by a subset of physical states. This is a function f(p_mT_i)rightarrow textpdf.\nAn event creates a new state by changing some subset of the physical state, and that function can depend on another subset of the physical state, which isn't changed. This is a function chi(p_jp_kT_iT_i+1)rightarrow p_j.","category":"page"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"Look at all the subsets. There is a subset for enabling, transition rates, modified state, and catalyst state (which affects the action but isn't modified). If we think of the physical state as nodes in a graph and the events as nodes in a graph, then each subset associated with an event forms a different kind of edge in a bipartite graph.","category":"page"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"The state of the system at any time is more than the physical state. It's the physical state plus the history of when each event clock was enabled. It is even reasonable to include in the state of the system every past event that fired and the time it fired, which is called the filtration of the stochastic process.","category":"page"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"The idea behind introducing the notion of physical state and subsets of the physical state is to help think about a semi-Markov process where events live longer than a single time step. Glynn wanted to attach those long-lived competing processes to some state because, in practice, there is something about the state of the world that remains the same at each time step. The brilliance of Anderson and Kurtz's monograph is that they start their model as a set of counting processes [Anderson:2015]. Any state of the system is a predictable function of the filtration (event history) of the counting processes.","category":"page"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"In the nomenclature of the GSMP, an event defines a change to substates, and every possible pair of states (X_i+1X_i) defines a transition. In general, the number of possible transitions is combinatorially larger than the number of possible events, as Haas covers in detail [Haas:2002].","category":"page"},{"location":"gsmp/#Formalisms-of-GSMP","page":"GSMP","title":"Formalisms of GSMP","text":"","category":"section"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"There are many frameworks for simulation where the simulation is in continuous-time and the next event is determined by competition among clocks.","category":"page"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"Simulations of chemical reactions. Here, the physical state is chemical components and simulations are usually, but not always, Exponentially-distributed.\nQueueing theory models of networks, production, and computation. Here, the state is in queues and the events are reprsented by servers.\nEpidemiological models of disease spread among individuals. These models are often hand-coded, but they look a lot like chemical simulation with non-Exponential distributions.\nVector-addition systems are an older form of simulation where the state is a vector of integers and every event gives or takes from the vector of integers. Again, it looks a lot like chemical simulation.\nGeneralized stochastic Petri nets are what happens when engineers use GSMP. There is a strong vocabulary used to define the state as marking and places, but they conform to what is described above.","category":"page"},{"location":"gsmp/#Extensions-to-GSMP","page":"GSMP","title":"Extensions to GSMP","text":"","category":"section"},{"location":"gsmp/#Atomic-Hazards-and-Differential-Equations","page":"GSMP","title":"Atomic Hazards and Differential Equations","text":"","category":"section"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"Most presentations of GSMP assume that the distribution times of events are continuous distributions that are well-behaved, but the structure of the stochastic process remains well-defined if we allow distributions that have jumps. Examples of such distributions are delta functions. We could for instance, say that an event has a 1/3 chance of happening in 2 minutes an a 2/3 chance of happening in 5 minutes.","category":"page"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"More commonly, what if the next step in a simulation were determined by an ordinary differential equation (ODE) that depends on the current state and time? A simulation could, at the enabling time, integrate the ODE to find when it predicts the next event and then enable a distribution that is a delta function centered at that predicted time.","category":"page"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"The caveat for atomic hazards it's possible for two atomic hazards to happen at exactly the same time. CompetingClocks doesn't have a way to guarantee which of those events happen first. It certainly doesn't have a way to randomly select which event should happen from a configurable probability distribution. This is a feature specific to samplers that allow instantaneous and simultaneous events. The way we handle the possiblility of simultaneous events is to schedule atomic events relative to continuous-time events or to ensure that there is only one atomic hazard in a whole simulation.","category":"page"},{"location":"gsmp/#Markov-Decision-Process","page":"GSMP","title":"Markov Decision Process","text":"","category":"section"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"In reinforcement learning, there is a model for how the world changes and a model for how to make decisions that depend on the world's history. For a GSMP-based decision process, there are two terms in the likelihood for the next state and time.","category":"page"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"PX_i+1T_i+1X_iT_iPA_j","category":"page"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"The additional stochastic variable A_j is the decision at each step.","category":"page"},{"location":"gsmp/#Piecewise-deterministic-Markov-Process","page":"GSMP","title":"Piecewise-deterministic Markov Process","text":"","category":"section"},{"location":"gsmp/#References","page":"GSMP","title":"References","text":"","category":"section"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"[Anderson:2015] Anderson, David F., and Thomas G. Kurtz. Stochastic analysis of biochemical systems. Vol. 674. Berlin, Germany: Springer International Publishing, 2015.","category":"page"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"[Haas:2002] P. J. Haas, Stochastic Petri Nets: Modelling, Stability, Simulation, Springer-Verlag, New York, New York, USA, 2002.","category":"page"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"[Glynn:1989] P. Glynn, A GSMP formalism for discrete event systems, Proceedings of the IEEE 77 (1) (1989) 14– 23, ISSN 00189219, URL.","category":"page"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"[Shedler:1987] Shedler, Gerald S. Regeneration and networks of queues. Vol. 3. Springer Science & Business Media, 1987.","category":"page"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"","category":"page"},{"location":"gsmp/","page":"GSMP","title":"GSMP","text":"This page was generated using Literate.jl.","category":"page"},{"location":"memory/#Transitions-with-Memory","page":"Transitions with Memory","title":"Transitions with Memory","text":"","category":"section"},{"location":"memory/","page":"Transitions with Memory","title":"Transitions with Memory","text":"Some transitions can be paused and restarted. These transitions are said to have memory [Zimmerman:2007]. For instance, let's say there is an industrial process that takes a Gamma-distributed amount of time.","category":"page"},{"location":"memory/","page":"Transitions with Memory","title":"Transitions with Memory","text":"using Distributions\nusing Plots\nbottler = Gamma(7.5, 1.0)\nx = 0.0:0.05:12.0\nplot(x, pdf.(bottler, x), xlims=(0.0, 12.0))","category":"page"},{"location":"memory/","page":"Transitions with Memory","title":"Transitions with Memory","text":"<img src=\"data:image/png;base64,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\" />","category":"page"},{"location":"memory/","page":"Transitions with Memory","title":"Transitions with Memory","text":"Then that process is interrupted, maybe because the machinery is required for a different process with higher priority, and then we restart the industrial process. What is the distribution of the restarted process, assuming it picks up where it left off? It's shifted to the left. Shifting the distribution doesn't just translate the pdf. It rescales the pdf so that the area under the curve is one and also changes the shape.","category":"page"},{"location":"memory/","page":"Transitions with Memory","title":"Transitions with Memory","text":"survival = ccdf\nhazard(dist, x) = pdf(dist, x) / survival(dist, x)\nconditional_survival(dist, intermediate, x) = survival(dist, x) / survival(dist, intermediate)\nshiftpdf(dist, intermediate, x) = hazard(dist, x + intermediate) * conditional_survival(dist, intermediate, x + intermediate)\nremembered_age = 5.1\nplot(x, shiftpdf.(bottler, remembered_age, x), xlims=(0.0, 12.0))","category":"page"},{"location":"memory/","page":"Transitions with Memory","title":"Transitions with Memory","text":"<img src=\"data:image/png;base64,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\" />","category":"page"},{"location":"memory/","page":"Transitions with Memory","title":"Transitions with Memory","text":"Another way to think about transitions with memory is that the zero-time of the process is now in the past. For CompetingClocks, that zero-time is called the enabling time. When we enable a transition, we give the enabling time as an absolute time in the simulation.","category":"page"},{"location":"memory/","page":"Transitions with Memory","title":"Transitions with Memory","text":"enablingtime = currenttime - remembered_age\nenable!(sampler, clock, distribution, enablingtime, currenttime, RNG)`","category":"page"},{"location":"memory/","page":"Transitions with Memory","title":"Transitions with Memory","text":"If a simulation wants to include transitions that have memory, that simulation needs to store the total time a transition has been enabled and then use that to set the enabling time when it restarts a transtition.","category":"page"},{"location":"memory/#References","page":"Transitions with Memory","title":"References","text":"","category":"section"},{"location":"memory/","page":"Transitions with Memory","title":"Transitions with Memory","text":"[Zimmerman:2007] Zimmermann, Armin. Stochastic discrete event systems. Springer, Berlin Heidelberg New York, 2007.","category":"page"},{"location":"memory/","page":"Transitions with Memory","title":"Transitions with Memory","text":"","category":"page"},{"location":"memory/","page":"Transitions with Memory","title":"Transitions with Memory","text":"This page was generated using Literate.jl.","category":"page"},{"location":"background/#Markov-Processes","page":"Markov Processes","title":"Markov Processes","text":"","category":"section"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"This addresses two main points, how to specify a model for the library using distributions defined by hazards and why such a specification, with its initial conditions, is sufficient to define the trajectory for a model.","category":"page"},{"location":"background/#The-Hazard-from-Survival-Analysis","page":"Markov Processes","title":"The Hazard from Survival Analysis","text":"","category":"section"},{"location":"background/#Discrete-case","page":"Markov Processes","title":"Discrete case","text":"","category":"section"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"The discrete case is much easier to understand than the continuous case because it can be explained without employing any results from calculus. Throughout this section, bfX will be assumed to real-valued random variable. For example, bfX could represent latent periods for measles.","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"It frequently happens that random samples of the real valued variables such as bfX are actually analyzed on a discrete scale. For example Stocks' data on latent periods of measles in latent_period is based on daily visits by patients [Stocks:1931].","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"The (cumulative) distribution of bfX is defined as","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"F_X(k) = mathcalPx le k","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"assuming F_X(infty) = 1. The density can be expressed as the difference in adjacent values of the distribution","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"beginaligned\nf_X(k)  =  mathcalPX=k \n          =  mathcalPXle k - mathcalPX le k-1  \n      =  F_X(k) - F_X(k-1)\nendaligned","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"For Stocks' data in latent_period, the density at day k should be interpreted as the probability of the appearance of symptoms since the previous visit on day k-1.","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"The hazard is defined as the conditional probability that the value of a random selection from bfX equals k given it this value is already known to exceed k-1. Using the usual rules for computing conditional probabilities, the hazard is given by the following ratio","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"beginaligned\nh_X(k)  =  mathcalPX=k  k-1X \n          =  fracf_X(k)1 - F_X(k-1)\nendaligned","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"In the case of Stocks' data, the hazards shown in latent_period_hazard would correspond to the probability of symptoms appearing at day k given that the patient had not displayed symptoms at any previous visit. As time goes on, patients who have already developed symptoms effectively reduce the pool of patients in the study who are still in a state where they might first present symptoms on day k. This is the origin of the term in the denominator.","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"(Image: Figure 2. Estimated hazards of latent periods for measles in London circa 1931)","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"On any given day, the hazard for latent periods can be interpreted as the rate of appearance of symptoms per asymptomatic (infected but not yet symptomatic) patient per day. For example, the hazard inferred from the Weibull distribution is approximately 015 on day 10. In other words, 15% of the patients that are asymptomatic on day 9 will present symptoms when examined on day 10.","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"(Image: Figure 3. Each participant of the Stocks study could either become symptomatic or leave the study. Focusing on the hazard accounts for the effect of those who leave.)","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"This interpretation is extremely important because it connects a hazard with a rate for a specific process, and that rate has well defined units of measurement. In addition, it clarifies how rate parameters should be estimated from observational data. Failure to account for the shrinking pool over time is commonplace. In this case it would lead to a systematic errors in the estimation of process rates, especially at long times when the depletion effect is most pronounced.","category":"page"},{"location":"background/#Continuous-case","page":"Markov Processes","title":"Continuous case","text":"","category":"section"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"The random variable bfX is again assumed to be a real-valued, but the measurements will not be binned as above. The cumulative distribution not an integer k but a continuous time interval, tau.","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"F_X(tau)=Pxletau","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"assuming F_X(infty)=1. The density is the derivative of the cumulative distribution. The concept of the hazard is part of survival analysis, where survival is G_X(tau)=1-F_X(tau), and represents the probability the random variable, a time interval, is longer than tau. One expression for the hazard is that the density of the random variable is equal to the probability it survives to a time tau multiplied by the hazard rate for firing at time tau, or, in probabilities,","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"Ptauxletau+dtaudtau=PtauxPtauxletau+dtau+dtautaux","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"Writing this same equation with its almost-sure equivalents defines the continuous hazard, lambda_X(tau),","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"f_X(tau)=G_X(tau)lambda_X(tau)","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"This is a rearrangement away from the definition of the discrete case.","category":"page"},{"location":"background/#Finite-State-Machines-Generate-Trajectories","page":"Markov Processes","title":"Finite State Machines Generate Trajectories","text":"","category":"section"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"This library accepts a specification of a model in terms of hazards, an initial condition, and produces trajectories. This set of high-level steps to simulation (specify, initialize, step) has a well-defined abstraction called a finite state machine. It isn't the finite state machine familiar to programmers but a mathematical model, coming from category theory, for a particularly simple class of computing systems. At a conceptual level, a finite state machine can be considered a black box that receives a sequence of input signal and produces an output signal for each input signal. Internally, the black box maintains a state -- some sort of finite summary representation of the sequence of input signals encountered so far. For each input signal, the box performs two operations. In both cases, the decision depends on the current internal state and the identity of the input signal just received.","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"Chose next state\nGenerate output token","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"It is helpful to view the finite state machine layer as a mechanism to simulate a Markov chain or Markov process.","category":"page"},{"location":"background/#Markov-Chain-for-Discrete-Time-Trajectories","page":"Markov Processes","title":"Markov Chain for Discrete-Time Trajectories","text":"","category":"section"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"Roughly speaking, a Markov chain, bfX, is a probabilistic system that makes random jumps among a finite set of distinct states, s_0 s_1 s_2 ldots s_N such that the probability of choosing the next state, X_n+1 depends only on the current state, X_n. In mathematical terms, the conditional probabilities for state transitions must satisfy","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"mathcalPX_n+1 = s_l  X_0=s_i X_1=s_j ldots X_n=s_k =\nmathcalPX_n+1 = s_l  X_n=s_k","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"Since more distant history does not affect future behavior, Markov chains are sometimes characterized as memoryless.","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"This relation can be iterated to compute the conditional probabilities for multiple time steps","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"mathcalPX_n+2 = s_m  X_n=s_k = sum_l mathcalPX_n+2 = s_m \nX_n+1=s_l mathcalPX_n+1 = s_l  X_n=s_k","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"Note, the transition probabilities mathcalPX_n+1 = s_l  X_n=s_k may depend on time (through the index n). These so-called time-inhomogeneous Markov chains arise when the system of interest is driven by external entities. Chains with time-independent conditional transition probabilities are called time-homogeneous. The dynamics of a time-homogeneous Markov chain is completely determined by the initial state and the transition probabilities. All processes considered in this document are time-homogeneous.","category":"page"},{"location":"background/#Markov-Process-for-Continuous-Time-Trajectories","page":"Markov Processes","title":"Markov Process for Continuous-Time Trajectories","text":"","category":"section"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"A Markov process is a generalization of the Markov chain such that time is viewed as continuous rather than discrete. As a result, it makes sense to record the times at which the transitions occur as part of the process itself.","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"The first step in this generalization is to define a stochastic process bfY that includes the transition times as well as the state, Y_n = (s_jt_n).","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"The second step is to treat time on a truly continuous basis by defining a new stochastic process, bfZ, from bfY by the rule Z_t = s_k in the time interval t_n le t  t_n+1 given Y_n = (s_k t_n) . In other words, bfZ_t is a piecewise constant version of bfY as shown in piecewise_Z.","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"(Image: Figure 4. **Realization of a continuous time stochastic process and associated Markov chain.**)","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"A realization of the process bfY is defined by the closed diamonds (left end points) alone. Similarly, a realization of the process bfZ_t is illustrated by the closed diamonds and line segments. The closed and open diamonds at the ends of the line segment indicate that the segments include the left but not the right end points.","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"The memoryless property for Markov processes is considerably more delicate than in the case of Markov chain because the time variable is continuous rather than discrete. In the case of bfY, the conditional probabilities for state transitions of must satisfy","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"mathcalPY_n+1 = (s_lt_n+1)  Y_0=(s_i t_0) Y_1=(s_j t_1)\nldots Y_n=(s_k t_n) =\nmathcalPY_n+1 = (s_l t_n+1)  Y_n=(s_k t_n)","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"The proper generalization of the requirement of time-homeogeneity stated previously for Markov chains is that joint probability be unchanged by uniform shifts in time","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"mathcalPZ_t+tau  Z_s+tau = mathcalPZ_t  Z_s ","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"for 0st and tau  0. Stochastic processes with shift invariant state transition probabilities are called stationary.","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"When we examined hazard rates above, we were examining the rate of transitions for a Markov process. The overall probability of the next state of the Markov process is called the core matrix,","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"mathcalPZ_t  Z_s =Q_ij(t_n+1-t_n)","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"indicating a state change between the states (s_is_j). The derivative of this is a rate,","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"q_ij(t_n+1-t_n)=fracdQ_ij(t_n+1-t_n)dt","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"which is a joint distribution over states and time intervals. Normalization for this quantity sums over possible states and future times,","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"1=int_0^infty sum_j  q_ij(s)ds","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"The survival, in terms of the core matrix, is","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"G_i(tau)=1-int_0^tau sum_k  q_ik(s)ds","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"This means our hazard is","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"lambda_ij(tau)=fracq_ij(tau)1-int_0^tau sum_k  q_ik(s)ds","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"For the measles example, the set of future states j of each individual include symptomatic and all the possible other ways an individual leaves the study, so you can think of j=mboxleft town. In practice, we build a hazard in two steps. First, count the probability over all time for any one eventual state j. This is the same stochastic probability pi_ij that is seen in Markov chains. Second, measure the distribution of times at which intervals enter each new state j, given that they are headed to that state. This is called the holding time, h_ij(tau), and is a conditional probability. Together, these two give us the core matrix,","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"q_ij(tau)=pi_ijh_ij(tau)","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"Note that h_ij(tau) is a density whose integral H_ij(tau) is a cumulative distribution. If we write the same equation in terms of probabilities, we see that it amounts to separating the Markov process into a marginal and conditional distribution.","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"beginaligned\nq_ij(tau)=fracddtauPZ_tZ_s \n=fracddtauPs_js_it_nPt_n-1-t_nletaus_is_jt_n \n   =  Ps_js_it_nfracddtauPt_n-1-t_nletaus_is_jt_n \n   =  pi_ijfracddtauH_ij(tau) \n   =  pi_ijh_ij(tau)\nendaligned","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"Choosing the other option for the marginal gives us the waiting time formulation for the core matrix. It corresponds to asking first what is the distribution of times at which the next event happens, no matter which event, and then asking which events are more likely given the time of the event.","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"beginaligned\nq_ij(tau)=fracddtauPZ_tZ_s \n=fracddtauPs_js_it_nt_n+1Pt_n-1-t_nletaus_it_n \n   =  fracddtau(Pi_ij(tau)W_i(tau)) \n   =  pi_ij(tau)fracddtauW_i(tau) \n   =  pi_ij(tau)w_i(tau)\nendaligned","category":"page"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"While the waiting time density w_i(tau), is the derivative of the waiting time, we won't end up needing to relation pi_ij(tau) to Pi_ij(tau) when finding trajectories or computing hazards, so the more complicated relationship won't be a problem.","category":"page"},{"location":"background/#References","page":"Markov Processes","title":"References","text":"","category":"section"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"[Stocks:1931]\tP. Stocks, “Incubation period of measles,” British Medical Journal 1(3655): p. 157.","category":"page"},{"location":"background/#Acknowledgement","page":"Markov Processes","title":"Acknowledgement","text":"","category":"section"},{"location":"background/","page":"Markov Processes","title":"Markov Processes","text":"This section comes was created by the Analytical Framework for Infectious Disease Dynamics (AFIDD) group at Cornell University in conjunction with the USDA Agricultural Research Service. This work was supported by the Science & Technology Directorate, Department of Homeland Security via interagency agreement no. HSHQDC-10-X-00138.","category":"page"},{"location":"#CompetingClocks","page":"Home","title":"CompetingClocks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CompetingClocks is a Julia library that samples distributions for discrete event systems (DES) in continuous time. It supports Exponential and non-Exponential distributions for events.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Many kinds of discrete event simulations need an efficient way to choose the next event in a simulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simulations of chemical reactions.\nQueueing theory models of networks, production, and computation.\nEpidemiological models of disease spread among individuals.\nVector-addition systems.\nGeneralized stochastic Petri nets.\nGeneralized semi-Markov Processes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This library supports these kinds of simulations by optimizing the choice of the next event in the system. In statistical terms, this library is a sampler for generalized semi-Markov processes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: CompetingClocks chooses the next transition but the simulation tracks state and changes to state.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The background work for this library comes from Continuous-time, discrete-event simulation from counting processes, by Andrew Dolgert, 2016.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The library provides you with samplers. Each sampler has the same interface. Here, a distribution is a Distributions.ContinuousUnivariateDistribution, RNG is a random number generator, the key is some identifier (maybe an integer) for the event, and an enabling time is a zero-time for the given distribution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"enable!(sampler, key, distribution, enabling time, current time, RNG)) - to start the clock on when an event will fire next.\ndisable!(sampler, key, current time) - to turn off an event so it can't fire.\nnext(sampler, current time, RNG) - to ask this library who fires next.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Different samplers are specialized for sampling more quickly and accurately for different applications. For instance, some applications have very few events enabled at once, while some have many. Some applications use only exponentially-distributed events, while some have a mix of distribution types. Because continuous-time discrete event systems can fire many events, the literature has focused on reducing the number of CPU instructions required to sample each event, and this library reflects that focus.","category":"page"},{"location":"#Why-Use-This?","page":"Home","title":"Why Use This?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If I make a quick simulation for myself, I sample distributions the moment an event is enabled and store the firing times in a priority queue. When would I switch to this library?","category":"page"},{"location":"","page":"Home","title":"Home","text":"I want to evaluate the effect of changing simulation parameters by comparing multiple runs with common random numbers.\nI'm looking at rare events, so I want to use splitting techniques and importance sampling.\nPerformance matters (which it often doesn't), so I would like to try different samplers on my problem.\nI want to focus on developing and testing my model not my simulation algorithm; CompetingClocks is designed and tested with care to ensure correctness.","category":"page"},{"location":"rules/#Rules-and-Guidelines","page":"Rules and Guidelines","title":"Rules and Guidelines","text":"","category":"section"},{"location":"rules/","page":"Rules and Guidelines","title":"Rules and Guidelines","text":"Even though this library is just handling a bag of event clocks, there are some rules for how to call the interface so that those clocks remain consistent. There are rules that keep the simulation running, and there are rules that guarantee repeatable simulations that have the correct statistical likelihood.","category":"page"},{"location":"rules/","page":"Rules and Guidelines","title":"Rules and Guidelines","text":"Some simulations treat events as maybe changing state, maybe not changing state.\nSome simulations think of an event as probabilistically changing state.\nFor a simulation in continuous time, only one event can happen at any time.","category":"page"},{"location":"samplers/#Understanding-Samplers","page":"Understanding Samplers","title":"Understanding Samplers","text":"","category":"section"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"From the perspective of someone who uses samplers in a simulation the features are important.","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"Does this sampler work only for Exponential distributions or also non-Exponential distributions?\nDoes it support using atomic distributions, such as delta functions?\nDoes it take advantage of a GPU?\nDoes it put any restrictions on clock keys, such as requirements that they be sequential integers or that there be few keys?\nDoes it support variance reduction techniques, such as\nCommon random numbers\nantithetic variates\nimportance sampling\ncontrol variates?\nDoes it maintain accuracy for extreme distribution parameters or extreme draws?","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"Answers to these questions come from understanding how samplers are built. A modern description of samplers is in Marchetti [Marchetti:2019].","category":"page"},{"location":"samplers/#Series-of-choices","page":"Understanding Samplers","title":"Series of choices","text":"","category":"section"},{"location":"samplers/#Split-into-marginal-and-conditional","page":"Understanding Samplers","title":"Split into marginal and conditional","text":"","category":"section"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"CompetingClocks supports sampling from generalized semi-Markov processes (GSMP). Every sampler of GSMP is sampling a joint space of which clock event is next, E, and which time is next, T. The clock event is a discrete choice, and the time is a continuous choice. The first step to making a GSMP sampler is to split that joint distribution into marginals and conditionals.","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"The reason to split the joint distribution is that, to sample any joint distribution, the usual method is to sample from the marginal of one random variable and then, given that value, sample the conditional of the other random variable. There are three ways to split a GSMP's joint distribution.","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"beginaligned\nPET  = PEPTE \n = PETPT \n = min(PT_i)quad forall i\nendaligned","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"The first split is rarely, if ever, used because we specify GSMP simulations by the probability in time that each clock will have an event. It takes some work to calculate the marginal over events. If we use notation where lambda is the hazard, S is the survival, and t_0 is the current simulation time, then the equation an integral over a product including all enabled survivals.","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"PE = int_t_0^infty lambda_i(t)prod_i S_i(t) dt","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"Instead, the second split is used all of the time for Exponential distributions. It's the choice that leads to the class of Direct methods. That's because the marginal over time is easy to calculate for exponentials.","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"PT = 1 - expleft(-sum_i int_t_0^t lambda_i(s)dsright)","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"For exponential distributions, the hazard is constant, which makes the integral trivial. But note that Gillespie's first two papers on exact stochastic simulation included a derivation of this direct method for non-exponential distributions. As with the Exponential distribution, this can be done analytically for the Weibull distribution. For general distributions, the code just has to integrate the right-hand side of the above equation. This is the kind of operation GPUs love.","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"The third split is a  way to sample the joint distribution by sampling from the conditional distribution of every enabled clock, which we call competing clocks. Define a random variate that is the minimum of those clocks, which defines the time to fire. This split matches our instinct that clocks are competing to fire next, and the first one wins.","category":"page"},{"location":"samplers/#Sampling-strategy","page":"Understanding Samplers","title":"Sampling strategy","text":"","category":"section"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"Now that we've chosen what random variables to sample, in what order, we choose a sampling strategy. By strategy, I mean one of","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"sampling by inversion, also known as inverse transform sampling\nsampling by rejection, also known as an acceptance-rejection method","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"These are broad methods for sampling, each of which has specific variants for particular distributions or, in the case of GSMP, for random variables defined by sets of competing distributions.","category":"page"},{"location":"samplers/#Specialize-for-the-distribution","page":"Understanding Samplers","title":"Specialize for the distribution","text":"","category":"section"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"Here, we would specialize, for instance, for having all Exponential distributions or all Weibull distributions. Stochastic simulation also introduces another wrinkle in sampling univariate distributions.","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"In a simulation, it is often the case that a clock is disabled and enabled again, or that a clock that was enabled with one rate is re-enabled with a different rate because it depends on the state of the system, and that state has changed. As a result, we frequently sample clocks that are shifted left. A clock is shifted left when the traditional zero-time for the distribution is in the past. In this case, we have options for how we modify sampling the distribution.","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"We could use a rejection method, where we sample the distribution and reject samples that are times in the past. We could sample by inversion and select random variates that correspond only to future times. We could sample by rejection and choose a known distribution whose hazard always exceeds that of the shifted distribution. There are lots of options, but none are built into the Julia Distributions package as ways to sample shifted distributions. It's a small complication that applies to stochastic simulation, and we handle it in the code.","category":"page"},{"location":"samplers/#Data-structures-and-algorithms","page":"Understanding Samplers","title":"Data structures and algorithms","text":"","category":"section"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"The next concern is how to express these sampling methods in code. Many of the well-known exact stochastic simulation (SSA) algorithms for chemical simulation are variations, not on how to sample the distribution, but on what data structures and algorithms to use for accelerating that sampling method.","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"For instance, if we are sampling a simulation using only Exponential distributions, then the Direct method has many named variants. The first step for the Direct method is to sample a time. The time comes from inverting the survival of the system. Here, we denote a random variate between [0,1] by U.","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"U = expleft(-sum_i lambda_i tright)","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"The simulation is more effecient if we can maintain sum_i lambda_i as a partial sum, so that we can index into it with log U. Further, every time there is a next event in the simulation, the list of enabled hazards changes, so we want to modify that list after each event, while maintaining the sum. For this purpose, there have been many data structures proposed. The general problem is known, in computer science as the prefix sum or prefix scan. An early attempt was an interesting structure called a Fenwick tree. The state of the art for this class of approaches was the optimized direct method, which is really just one of the prefix scan algorithms applied to the Direct method.","category":"page"},{"location":"samplers/#Examples","page":"Understanding Samplers","title":"Examples","text":"","category":"section"},{"location":"samplers/#First-to-fire","page":"Understanding Samplers","title":"First to fire","text":"","category":"section"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"The simplest way to sample a GSMP is to sample each clock the moment it's enabled. I don't know that there is a common name for this, so I'm calling it \"first to fire.\" This is a competing clocks split of the joint distribution. For each clock, it can ask the Julia library to sample that clock's distribution in whatever way it sees fit. This is helpful for both speed and accuracy because distributions have methods that are specialized for that distribution and, often, for particular ranges of distribution parameters. For example, it seems easy to sample an exponential using inversion. Here, U is a uniform variate between [0,1], and t is the sample time.","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"t = (1lambda) log U","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"However, every mathematical library uses the Ziggurat method because it is at least twice as fast. There might be a downside if you want to use automatic differentiation on the code.","category":"page"},{"location":"samplers/#Next-reaction-method","page":"Understanding Samplers","title":"Next reaction method","text":"","category":"section"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"The next reaction method also samples each clock, but it samples in such a way that it reduces usage of random number generation. Random number generation used to be slow, but it is now no longer a concern. (There's a funny paper about this that I'm having trouble finding.) Nevertheless, there are some reasons to use this method.","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"When a clock is first enabled, the next reaction method samples a uniform variate in [0,1], and then it finds a putative next event time for that clock using inversion. The original random variate is considered the total survival for this clock. The interesting move is that, if that same clock is disabled, this method saves some measure of how far the clock has gotten. That is, it measures the survival of the clock and subtracts that survival from the total survival. If the clock is ever enabled again, its new firing time is determined by the remaining survival.","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"Is that allowed? The authors of the Next Reaction sort of prove it in \"Efficient Exact Stochastic Simulation of Chemical Systems with Many Species and Many Channels\", but they can fortunately can rely on the work of Kurtz [Kurtz:1970], which I don't quite see in their references. Nevertheless, Anderson and Kurtz amended this work with \"Continuous time markov chain models for chemical reaction methods\".","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"In Anderson and Kurtz, they take the same approach as the next reaction method. It's still split by the conditional firing times. It's still sampling by inversion, but they change to a log-space for the sampling of individual distributions. That's the whole change. Instead of storing the total survival, U, they store the log of that quantity, which turns out to be much more efficient for exponentials and Weibulls, which are used most frequently.","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"In CompetingClocks, you'll see a single sampler that uses a combination of the next reaction method (Gibson and Bruck) and the modified next reaction method (Anderson and Kurtz). Based on the particular univariate distribution, the code uses a lookup into a performance table to choose either a linear space or log space. It's the best of both worlds, and it's just a matter of changing data structures a little bit.","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"Why do people like the next reaction method when the first to fire is much less fussy and will use the appropriate sampler for the distribution, every time? It's about features. The next reaction method stores data that helps calculate importance samples. It also makes it easy to implement common random numbers. Finally, the next reaction method always samples from U=01 or from an exponential distribution, and then it transforms that value into the sample of the particular clock's distribution. This is called pathwise sampling, and it enables a simple method for taking derivatives of distributions.","category":"page"},{"location":"samplers/#Direct-method-for-exponentials","page":"Understanding Samplers","title":"Direct method for exponentials","text":"","category":"section"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"The Direct method is really quite solved, as described above. However, there is one complication that has to do with clock keys. Literature about prefix scans assumes that there are integer indices into an ordered, fixed list of integers. That is, you will use the integers 1-100 for the whole simulation. It seems so useful to have clock keys that can be strings, tuples, or other immutable types, so CompetingClocks uses a prefix scan that maintains a dictionary of keys.","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"If the prefix scan has a dictionary of keys, then it could remember the keys forever or it could forget them. If you have a long-running simulation that uses an ever-growing number of event keys, then it's important to remove keys that are no longer in use. If you have a simulation that uses a fixed set of keys, it's easier to keep them in the dictionary.","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"It would be interesting to ask whether we could create a data structure that is a keyed prefix sum, instead of using a dictionary that indexes into a prefix sum.","category":"page"},{"location":"samplers/#References","page":"Understanding Samplers","title":"References","text":"","category":"section"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"[Kurtz:1970] Kurtz, Thomas G. \"Solutions of ordinary differential equations as limits of pure jump Markov processes.\" Journal of applied Probability 7.1 (1970): 49-58.","category":"page"},{"location":"samplers/","page":"Understanding Samplers","title":"Understanding Samplers","text":"[Marchetti:2019] Marchetti, Luca, Corrado Priami, and Vo Hong Thanh. Simulation algorithms for computational systems biology. Vol. 1. Berlin, Germany, 2019.","category":"page"}]
}
