<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Understanding Samplers · CompetingClocks.jl</title><meta name="title" content="Understanding Samplers · CompetingClocks.jl"/><meta property="og:title" content="Understanding Samplers · CompetingClocks.jl"/><meta property="twitter:title" content="Understanding Samplers · CompetingClocks.jl"/><meta name="description" content="Documentation for CompetingClocks.jl."/><meta property="og:description" content="Documentation for CompetingClocks.jl."/><meta property="twitter:description" content="Documentation for CompetingClocks.jl."/><meta property="og:url" content="https://adolgert.github.io/CompetingClocks.jl/samplers/"/><meta property="twitter:url" content="https://adolgert.github.io/CompetingClocks.jl/samplers/"/><link rel="canonical" href="https://adolgert.github.io/CompetingClocks.jl/samplers/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CompetingClocks.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../guide/">Competing Clocks</a></li><li><a class="tocitem" href="../mainloop/">Sample Main Loop</a></li><li><a class="tocitem" href="../distributions/">Non-exponential Simulation</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../distrib/">Notation for Distributions</a></li><li><a class="tocitem" href="../background/">Markov Processes</a></li><li><a class="tocitem" href="../gsmp/">GSMP</a></li><li class="is-active"><a class="tocitem" href>Understanding Samplers</a><ul class="internal"><li><a class="tocitem" href="#Series-of-choices"><span>Series of choices</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../hierarchical/">Hierarchical Samplers</a></li><li><a class="tocitem" href="../memory/">Transitions with Memory</a></li><li><a class="tocitem" href="../commonrandom/">Common Random Numbers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../constant_birth/">Birth-death Process</a></li><li><a class="tocitem" href="../sir/">SIR Model</a></li><li><a class="tocitem" href="../reliability/">Reliability</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../interface/">Interface</a></li><li><a class="tocitem" href="../reference/">Samplers</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Understanding Samplers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Understanding Samplers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/adolgert/CompetingClocks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/adolgert/CompetingClocks.jl/blob/main/docs/src/samplers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Understanding-Samplers"><a class="docs-heading-anchor" href="#Understanding-Samplers">Understanding Samplers</a><a id="Understanding-Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Understanding-Samplers" title="Permalink"></a></h1><p>From the perspective of someone who uses samplers in a simulation the features are important.</p><ul><li>Does this sampler work only for Exponential distributions or also non-Exponential distributions?</li><li>Does it support using atomic distributions, such as delta functions?</li><li>Does it take advantage of a GPU?</li><li>Does it put any restrictions on clock keys, such as requirements that they be sequential integers or that there be few keys?</li><li>Does it support variance reduction techniques, such as<ul><li>Common random numbers</li><li>antithetic variates</li><li>importance sampling</li><li>control variates?</li></ul></li><li>Does it maintain accuracy for extreme distribution parameters or extreme draws?</li></ul><p>Answers to these questions come from understanding how samplers are built. A modern description of samplers is in Marchetti [Marchetti:2019].</p><h2 id="Series-of-choices"><a class="docs-heading-anchor" href="#Series-of-choices">Series of choices</a><a id="Series-of-choices-1"></a><a class="docs-heading-anchor-permalink" href="#Series-of-choices" title="Permalink"></a></h2><h3 id="Split-into-marginal-and-conditional"><a class="docs-heading-anchor" href="#Split-into-marginal-and-conditional">Split into marginal and conditional</a><a id="Split-into-marginal-and-conditional-1"></a><a class="docs-heading-anchor-permalink" href="#Split-into-marginal-and-conditional" title="Permalink"></a></h3><p>CompetingClocks supports sampling from generalized semi-Markov processes (GSMP). Every sampler of GSMP is sampling a joint space of which clock event is next, <span>$E$</span>, and which time is next, <span>$T$</span>. The clock event is a discrete choice, and the time is a continuous choice. The first step to making a GSMP sampler is to split that joint distribution into marginals and conditionals.</p><p>The reason to split the joint distribution is that, to sample any joint distribution, the usual method is to sample from the marginal of one random variable and then, given that value, sample the conditional of the other random variable. There are three ways to split a GSMP&#39;s joint distribution.</p><p class="math-container">\[\begin{aligned}
P[E,T] &amp; = P[E]P[T|E] \\
&amp; = P[E|T]P[T] \\
&amp; = min(P[T_i])\quad \forall i
\end{aligned}\]</p><p>The first split is rarely, if ever, used because we specify GSMP simulations by the probability in time that each clock will have an event. It takes some work to calculate the marginal over events. If we use notation where <span>$\lambda$</span> is the hazard, <span>$S$</span> is the survival, and <span>$t_0$</span> is the current simulation time, then the equation an integral over a product including all enabled survivals.</p><p class="math-container">\[P[E] = \int_{t_0}^\infty \lambda_i(t)\prod_i S_i(t) dt\]</p><p>Instead, the second split is used all of the time for Exponential distributions. It&#39;s the choice that leads to the class of <strong>Direct methods.</strong> That&#39;s because the marginal over time is easy to calculate for exponentials.</p><p class="math-container">\[P[T] = 1 - \exp\left(-\sum_i \int_{t_0}^t \lambda_i(s)ds\right)\]</p><p>For exponential distributions, the hazard is constant, which makes the integral trivial. But note that Gillespie&#39;s first two papers on exact stochastic simulation included a derivation of this direct method for non-exponential distributions. As with the Exponential distribution, this can be done analytically for the Weibull distribution. For general distributions, the code just has to integrate the right-hand side of the above equation. This is the kind of operation GPUs love.</p><p>The third split is a  way to sample the joint distribution by sampling from the conditional distribution of every enabled clock, which we call <strong>competing clocks.</strong> Define a random variate that is the minimum of those clocks, which defines the time to fire. This split matches our instinct that clocks are competing to fire next, and the first one wins.</p><h3 id="Sampling-strategy"><a class="docs-heading-anchor" href="#Sampling-strategy">Sampling strategy</a><a id="Sampling-strategy-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-strategy" title="Permalink"></a></h3><p>Now that we&#39;ve chosen what random variables to sample, in what order, we choose a sampling strategy. By strategy, I mean one of</p><ul><li>sampling by inversion, also known as <a href="https://en.wikipedia.org/wiki/Inverse_transform_sampling">inverse transform sampling</a></li><li>sampling by rejection, also known as an <a href="https://en.wikipedia.org/wiki/Rejection_sampling">acceptance-rejection method</a></li></ul><p>These are broad methods for sampling, each of which has specific variants for particular distributions or, in the case of GSMP, for random variables defined by sets of competing distributions.</p><h3 id="Specialize-for-the-distribution"><a class="docs-heading-anchor" href="#Specialize-for-the-distribution">Specialize for the distribution</a><a id="Specialize-for-the-distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Specialize-for-the-distribution" title="Permalink"></a></h3><p>Here, we would specialize, for instance, for having all Exponential distributions or all Weibull distributions. Stochastic simulation also introduces another wrinkle in sampling univariate distributions.</p><p>In a simulation, it is often the case that a clock is disabled and enabled again, or that a clock that was enabled with one rate is re-enabled with a different rate because it depends on the state of the system, and that state has changed. As a result, we frequently sample clocks that are shifted left. A clock is shifted left when the traditional zero-time for the distribution is in the past. In this case, we have options for how we modify sampling the distribution.</p><p>We could use a rejection method, where we sample the distribution and reject samples that are times in the past. We could sample by inversion and select random variates that correspond only to future times. We could sample by rejection and choose a known distribution whose hazard always exceeds that of the shifted distribution. There are lots of options, but none are built into the Julia Distributions package as ways to sample shifted distributions. It&#39;s a small complication that applies to stochastic simulation, and we handle it in the code.</p><h3 id="Data-structures-and-algorithms"><a class="docs-heading-anchor" href="#Data-structures-and-algorithms">Data structures and algorithms</a><a id="Data-structures-and-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Data-structures-and-algorithms" title="Permalink"></a></h3><p>The next concern is how to express these sampling methods in code. Many of the well-known exact stochastic simulation (SSA) algorithms for chemical simulation are variations, not on how to sample the distribution, but on what data structures and algorithms to use for accelerating that sampling method.</p><p>For instance, if we are sampling a simulation using only Exponential distributions, then the Direct method has many named variants. The first step for the Direct method is to sample a time. The time comes from inverting the survival of the system. Here, we denote a random variate between [0,1] by <span>$U$</span>.</p><p class="math-container">\[U = \exp\left(-\sum_i \lambda_i t\right)\]</p><p>The simulation is more effecient if we can maintain <span>$\sum_i \lambda_i$</span> as a partial sum, so that we can index into it with <span>$\log U$</span>. Further, every time there is a next event in the simulation, the list of enabled hazards changes, so we want to modify that list after each event, while maintaining the sum. For this purpose, there have been many data structures proposed. The general problem is known, in computer science as the <a href="https://en.wikipedia.org/wiki/Prefix_sum">prefix sum or prefix scan</a>. An early attempt was an interesting structure called a <a href="https://en.wikipedia.org/wiki/Fenwick_tree">Fenwick tree</a>. The state of the art for this class of approaches was the <a href="https://pubmed.ncbi.nlm.nih.gov/15332951/">optimized direct method</a>, which is really just one of the prefix scan algorithms applied to the Direct method.</p><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><h3 id="First-to-fire"><a class="docs-heading-anchor" href="#First-to-fire">First to fire</a><a id="First-to-fire-1"></a><a class="docs-heading-anchor-permalink" href="#First-to-fire" title="Permalink"></a></h3><p>The simplest way to sample a GSMP is to sample each clock the moment it&#39;s enabled. I don&#39;t know that there is a common name for this, so I&#39;m calling it &quot;first to fire.&quot; This is a competing clocks split of the joint distribution. For each clock, it can ask the Julia library to sample that clock&#39;s distribution in whatever way it sees fit. This is helpful for both speed and accuracy because distributions have methods that are specialized for that distribution and, often, for particular ranges of distribution parameters. For example, it seems easy to sample an exponential using inversion. Here, <span>$U$</span> is a uniform variate between [0,1], and <span>$t$</span> is the sample time.</p><p class="math-container">\[t = (1/\lambda) \log U\]</p><p>However, every mathematical library uses the <a href="https://en.wikipedia.org/wiki/Ziggurat_algorithm">Ziggurat method</a> because it is at least twice as fast. There might be a downside if you want to use automatic differentiation on the code.</p><h3 id="Next-reaction-method"><a class="docs-heading-anchor" href="#Next-reaction-method">Next reaction method</a><a id="Next-reaction-method-1"></a><a class="docs-heading-anchor-permalink" href="#Next-reaction-method" title="Permalink"></a></h3><p>The next reaction method also samples each clock, but it samples in such a way that it reduces usage of random number generation. Random number generation used to be slow, but it is now no longer a concern. (There&#39;s a funny paper about this that I&#39;m having trouble finding.) Nevertheless, there are some reasons to use this method.</p><p>When a clock is first enabled, the next reaction method samples a uniform variate in [0,1], and then it finds a putative next event time for that clock using inversion. The original random variate is considered the <strong>total survival for this clock.</strong> The interesting move is that, if that same clock is disabled, this method saves some measure of how far the clock has gotten. That is, it measures the survival of the clock and subtracts that survival from the total survival. If the clock is ever enabled again, its new firing time is determined by the remaining survival.</p><p>Is that allowed? The authors of the Next Reaction sort of prove it in <a href="https://pubs.acs.org/doi/full/10.1021/jp993732q">&quot;Efficient Exact Stochastic Simulation of Chemical Systems with Many Species and Many Channels&quot;</a>, but they can fortunately can rely on the work of Kurtz [Kurtz:1970], which I don&#39;t quite see in their references. Nevertheless, Anderson and Kurtz amended this work with <a href="https://link.springer.com/chapter/10.1007/978-1-4419-6766-4_1">&quot;Continuous time markov chain models for chemical reaction methods&quot;</a>.</p><p>In Anderson and Kurtz, they take the same approach as the next reaction method. It&#39;s still split by the conditional firing times. It&#39;s still sampling by inversion, but they change to a log-space for the sampling of individual distributions. That&#39;s the whole change. Instead of storing the total survival, <span>$U$</span>, they store the log of that quantity, which turns out to be much more efficient for exponentials and Weibulls, which are used most frequently.</p><p>In CompetingClocks, you&#39;ll see a single sampler that uses a combination of the next reaction method (Gibson and Bruck) and the modified next reaction method (Anderson and Kurtz). Based on the particular univariate distribution, the code uses a lookup into a performance table to choose either a linear space or log space. It&#39;s the best of both worlds, and it&#39;s just a matter of changing data structures a little bit.</p><p>Why do people like the next reaction method when the first to fire is much less fussy and will use the appropriate sampler for the distribution, every time? It&#39;s about features. The next reaction method stores data that helps calculate importance samples. It also makes it easy to implement common random numbers. Finally, the next reaction method always samples from <span>$U=[0,1]$</span> or from an exponential distribution, and then it transforms that value into the sample of the particular clock&#39;s distribution. This is called pathwise sampling, and it enables a simple method for taking derivatives of distributions.</p><h3 id="Direct-method-for-exponentials"><a class="docs-heading-anchor" href="#Direct-method-for-exponentials">Direct method for exponentials</a><a id="Direct-method-for-exponentials-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-method-for-exponentials" title="Permalink"></a></h3><p>The Direct method is really quite solved, as described above. However, there is one complication that has to do with clock keys. Literature about prefix scans assumes that there are integer indices into an ordered, fixed list of integers. That is, you will use the integers 1-100 for the whole simulation. It seems so useful to have clock keys that can be strings, tuples, or other immutable types, so CompetingClocks uses a prefix scan that maintains a dictionary of keys.</p><p>If the prefix scan has a dictionary of keys, then it could remember the keys forever or it could forget them. If you have a long-running simulation that uses an ever-growing number of event keys, then it&#39;s important to remove keys that are no longer in use. If you have a simulation that uses a fixed set of keys, it&#39;s easier to keep them in the dictionary.</p><p>It would be interesting to ask whether we could create a data structure that is a keyed prefix sum, instead of using a dictionary that indexes into a prefix sum.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>[Kurtz:1970] Kurtz, Thomas G. &quot;Solutions of ordinary differential equations as limits of pure jump Markov processes.&quot; Journal of applied Probability 7.1 (1970): 49-58.</p><p>[Marchetti:2019] Marchetti, Luca, Corrado Priami, and Vo Hong Thanh. Simulation algorithms for computational systems biology. Vol. 1. Berlin, Germany, 2019.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gsmp/">« GSMP</a><a class="docs-footer-nextpage" href="../hierarchical/">Hierarchical Samplers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 29 May 2024 15:47">Wednesday 29 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
