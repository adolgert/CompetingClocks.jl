<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Low-level Sampler Interface · CompetingClocks.jl Documentation</title><meta name="title" content="Low-level Sampler Interface · CompetingClocks.jl Documentation"/><meta property="og:title" content="Low-level Sampler Interface · CompetingClocks.jl Documentation"/><meta property="twitter:title" content="Low-level Sampler Interface · CompetingClocks.jl Documentation"/><meta name="description" content="Documentation for CompetingClocks.jl Documentation."/><meta property="og:description" content="Documentation for CompetingClocks.jl Documentation."/><meta property="twitter:description" content="Documentation for CompetingClocks.jl Documentation."/><meta property="og:url" content="https://adolgert.github.io/CompetingClocks.jl/low_level_interface/"/><meta property="twitter:url" content="https://adolgert.github.io/CompetingClocks.jl/low_level_interface/"/><link rel="canonical" href="https://adolgert.github.io/CompetingClocks.jl/low_level_interface/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CompetingClocks.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../quickstart/">Quickstart</a></li><li><a class="tocitem" href="../mainloop/">Sample Main Loop</a></li><li><a class="tocitem" href="../choosing_sampler/">Choosing a Sampler</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../integration-guide/">Integration Guide</a></li><li class="is-active"><a class="tocitem" href>Low-level Sampler Interface</a><ul class="internal"><li><a class="tocitem" href="#Common-Interface-to-Low-level-Samplers"><span>Common Interface to Low-level Samplers</span></a></li><li><a class="tocitem" href="#Individual-Samplers"><span>Individual Samplers</span></a></li><li><a class="tocitem" href="#Hierarchical-Sampling"><span>Hierarchical Sampling</span></a></li><li><a class="tocitem" href="#Helper-Classes"><span>Helper Classes</span></a></li></ul></li><li><a class="tocitem" href="../samplers/">Understanding Samplers</a></li><li><a class="tocitem" href="../delayed/">Delayed Clocks</a></li><li><a class="tocitem" href="../guide/">Competing Clocks</a></li><li><a class="tocitem" href="../distributions/">Non-exponential Simulation</a></li><li><a class="tocitem" href="../hierarchical/">Hierarchical Samplers</a></li><li><a class="tocitem" href="../debugging/">Debugging a Simulation that Uses CompetingClocks</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../reliability/">Reliability</a></li><li><a class="tocitem" href="../sir/">SIR Model</a></li><li><a class="tocitem" href="../constant_birth/">Birth-death Process</a></li><li><a class="tocitem" href="../memory/">Transitions with Memory</a></li><li><a class="tocitem" href="../gene_expression/">Gene Expression</a></li></ul></li><li><span class="tocitem">Statistical Methods</span><ul><li><a class="tocitem" href="../commonrandom/">Common Random Numbers</a></li><li><a class="tocitem" href="../importance_skills/">Importance Sampling for Simulation</a></li><li><a class="tocitem" href="../hamiltonianmontecarlo/">Hamiltonian Monte Carlo</a></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">Gen.jl Integration</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../gen/overview/">Gen.jl and CompetingClocks.jl</a></li><li><a class="tocitem" href="../gen/distribution/">CompetingClocks as a Gen Distribution</a></li><li><a class="tocitem" href="../gen/generative_function/">CompetingClocks as a Gen Generative Function</a></li><li><a class="tocitem" href="../gen/observation_likelihood/">Observation Likelihood for Event Data</a></li><li><a class="tocitem" href="../gen/importance_mixture/">Importance Sampling with Mixture Proposals</a></li><li><a class="tocitem" href="../gen/hmc_paths/">HMC over Event Paths with Gen.jl</a></li></ul></li><li><a class="tocitem" href="../gen/turing_dist/">Bayesian Inference with Turing.jl</a></li><li><a class="tocitem" href="../gen/survival_snippet/">Integration with Survival.jl</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../contextinterface/">Context Interface</a></li><li><a class="tocitem" href="../reference/">Samplers</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Low-level Sampler Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Low-level Sampler Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/adolgert/CompetingClocks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/adolgert/CompetingClocks.jl/blob/main/docs/src/low_level_interface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Low-level-Sampler-Interface"><a class="docs-heading-anchor" href="#Low-level-Sampler-Interface">Low-level Sampler Interface</a><a id="Low-level-Sampler-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-Sampler-Interface" title="Permalink"></a></h1><p>The main interface to the package is the <a href="../contextinterface/#CompetingClocks.SamplingContext-Union{Tuple{R}, Tuple{T}, Tuple{K}, Tuple{Type{K}, Type{T}, R}} where {K, T, R&lt;:AbstractRNG}"><code>SamplingContext</code></a>. The <code>SamplingContext</code> contains sampling algorithms and other helper classes. This describes the interface to underlying sampling algorithms, which differ slightly:</p><ul><li>They don&#39;t hold a random number generator internally so it is passed as an argument.</li><li>All input times are absolute, so the enabling time of a distribution is given in absolute time.</li></ul><h2 id="Common-Interface-to-Low-level-Samplers"><a class="docs-heading-anchor" href="#Common-Interface-to-Low-level-Samplers">Common Interface to Low-level Samplers</a><a id="Common-Interface-to-Low-level-Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Interface-to-Low-level-Samplers" title="Permalink"></a></h2><h3 id="Use-a-Sampler"><a class="docs-heading-anchor" href="#Use-a-Sampler">Use a Sampler</a><a id="Use-a-Sampler-1"></a><a class="docs-heading-anchor-permalink" href="#Use-a-Sampler" title="Permalink"></a></h3><p>Low-level sampler interface. Most users should use <a href="../contextinterface/#CompetingClocks.SamplingContext-Union{Tuple{R}, Tuple{T}, Tuple{K}, Tuple{Type{K}, Type{T}, R}} where {K, T, R&lt;:AbstractRNG}"><code>SamplingContext</code></a> instead, which is documented in <a href="../contextinterface/#Context-Interface">Context Interface</a>.</p><article><details class="docstring" open="true"><summary id="CompetingClocks.SSA"><a class="docstring-binding" href="#CompetingClocks.SSA"><code>CompetingClocks.SSA</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SSA{KeyType,TimeType}</code></pre><p>This abstract type represents a stochastic simulation algorithm (SSA). It is parametrized by the clock ID, or key, and the type used for the time, which is typically a Float64. The type of the key can be anything you would use as a dictionary key. This excludes mutable values but includes a wide range of identifiers useful for simulation. For instance, it could be a <code>String</code>, but it could be a <code>Tuple{Int64,Int64,Int64}</code>, so that it indexes into a complicated simulation state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L8-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.enable!-Union{Tuple{T}, Tuple{K}, Tuple{SSA{K, T}, K, UnivariateDistribution, T, T, AbstractRNG}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.enable!-Union{Tuple{T}, Tuple{K}, Tuple{SSA{K, T}, K, UnivariateDistribution, T, T, AbstractRNG}} where {K, T}"><code>CompetingClocks.enable!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enable!(sampler, clock, distribution, enablingtime, currenttime, RNG)</code></pre><p>Tell the sampler to start a clock.</p><ul><li><code>sampler::SSA{KeyType,TimeType}</code> - The sampler to tell.</li><li><code>clock::KeyType</code> - The ID of the clock. Can be a string, integer, tuple, etc.</li><li><code>distribution::Distributions.UnivariateDistribution</code></li><li><code>enablingtime::TimeType</code> - The zero time for the clock&#39;s distribution, in absolute time. Usually equal to <code>when</code>.</li><li><code>when::TimeType</code> - The current time of the simulation.</li><li><code>rng::AbstractRNG</code> - A random number generator.</li></ul><p>These times are <strong>absolute</strong> since the start of the simulation. The current time should be <code>when</code>. If you want to shift the distribution so that this event cannot happen for a little while then choose <code>enablingtime &gt; when</code>. If you want to modify the distribution by shifting it left, then choose <code>enablingtime &lt; when</code>. Usually, <code>enablingtime == when</code>. It is also possible to always use <code>enablingtime == when</code> and use the <code>truncated()</code> function to modify distributions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L22-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.reset!-Union{Tuple{SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.reset!-Union{Tuple{SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}"><code>CompetingClocks.reset!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reset!(sampler)</code></pre><p>After a sampler is used for a simulation run, it has internal state. This function resets that internal state to the initial value in preparation for another sample run.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L52-L58">source</a></section><section><div><pre><code class="language-julia hljs">reset!(sampling)</code></pre><p>Clear all enabled clocks (and delayed state if present) and reset time to the fixed start time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L507-L512">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.disable!-Union{Tuple{T}, Tuple{K}, Tuple{SSA{K, T}, K, T}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.disable!-Union{Tuple{T}, Tuple{K}, Tuple{SSA{K, T}, K, T}} where {K, T}"><code>CompetingClocks.disable!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">disable!(sampler, clock, when)</code></pre><p>Tell the sampler to forget a clock. We include the current simulation time because some Next Reaction methods use this to optimize sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L102-L107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.next-Union{Tuple{T}, Tuple{K}, Tuple{SSA{K, T}, T, AbstractRNG}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.next-Union{Tuple{T}, Tuple{K}, Tuple{SSA{K, T}, T, AbstractRNG}} where {K, T}"><code>CompetingClocks.next</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">next(sampler, when, rng)</code></pre><p>Ask the sampler for what happens next, in the form of <code>(when, which)::Tuple{TimeType,KeyType}</code>. <code>rng</code> is a random number generator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L112-L117">source</a></section></details></article><h3 id="Query-a-Sampler"><a class="docs-heading-anchor" href="#Query-a-Sampler">Query a Sampler</a><a id="Query-a-Sampler-1"></a><a class="docs-heading-anchor-permalink" href="#Query-a-Sampler" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="CompetingClocks.timetype-Union{Tuple{SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.timetype-Union{Tuple{SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}"><code>CompetingClocks.timetype</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">timetype(sampler)</code></pre><p>Return the type of clock times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L162-L166">source</a></section><section><div><pre><code class="language-julia hljs">timetype(sampling)</code></pre><p>Time type <code>T</code>, usually <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L614-L618">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.enabled-Union{Tuple{SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.enabled-Union{Tuple{SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}"><code>CompetingClocks.enabled</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enabled(sampler)</code></pre><p>Returns a read-only set of currently-enabled clocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L180-L184">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.length-Tuple{SSA}"><a class="docstring-binding" href="#Base.length-Tuple{SSA}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">length(sampler)::Int64</code></pre><p>Return the number of stored clocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L144-L148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Union{Tuple{T}, Tuple{K}, Tuple{SSA{K, T}, K}} where {K, T}"><a class="docstring-binding" href="#Base.getindex-Union{Tuple{T}, Tuple{K}, Tuple{SSA{K, T}, K}} where {K, T}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getindex(sampler, clock::KeyType)</code></pre><p>Return stored state for a particular clock. If the clock does not exist, a <code>KeyError</code> will be thrown. Different samplers have <strong>different stored state.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L123-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.keys-Tuple{SSA}"><a class="docstring-binding" href="#Base.keys-Tuple{SSA}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">keys(sampler)</code></pre><p>Return all stored clocks as a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L134-L138">source</a></section></details></article><h3 id="Copies-of-Samplers"><a class="docs-heading-anchor" href="#Copies-of-Samplers">Copies of Samplers</a><a id="Copies-of-Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Copies-of-Samplers" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="CompetingClocks.clone-Union{Tuple{SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.clone-Union{Tuple{SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}"><code>CompetingClocks.clone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">clone(sampler)</code></pre><p>Given an existing sampler, make a copy that has the same type and same constructor options but has no data in it. Use this to initialize an array of samplers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L77-L83">source</a></section><section><div><pre><code class="language-julia hljs">clone(ds::DelayedState)</code></pre><p>Deep copy of a <code>DelayedState</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/delayed_state.jl#L64-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.copy_clocks!-Union{Tuple{SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.copy_clocks!-Union{Tuple{SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}"><code>CompetingClocks.copy_clocks!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">copy_clocks!(destination_sampler, source_sampler)</code></pre><p>This copies the state of the source sampler to the destination sampler, replacing the current state of the destination sampler. This is useful for splitting techniques where you make copies of a simulation and restart it with different random number generators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L64-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.jitter!-Union{Tuple{T}, Tuple{K}, Tuple{SSA{K, T}, T, AbstractRNG}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.jitter!-Union{Tuple{T}, Tuple{K}, Tuple{SSA{K, T}, T, AbstractRNG}} where {K, T}"><code>CompetingClocks.jitter!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">jitter!(sampler, when, rng)</code></pre><p>Takes a sampler that is at a statistically-valid stopping time (this is a technical term) and resamples all clocks currently-enabled so that this copy of the sampler will yield different results from another copy of the sampler despite its internal cache of clock data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L89-L96">source</a></section></details></article><h2 id="Individual-Samplers"><a class="docs-heading-anchor" href="#Individual-Samplers">Individual Samplers</a><a id="Individual-Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Individual-Samplers" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="CompetingClocks.CombinedNextReaction"><a class="docstring-binding" href="#CompetingClocks.CombinedNextReaction"><code>CompetingClocks.CombinedNextReaction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CombinedNextReaction{KeyType,TimeType}()</code></pre><p>This combines Next Reaction Method and Modified Next Reaction Method. The Next Reaction Method is from Gibson and Bruck in their 2000 paper called <a href="https://doi.org/10.1021/jp993732q">&quot;Efficient Exact Stochastic Simulation of Chemical Systems with Many Species and Many Channels&quot;</a>.  The Modified Next Reaction Method is from David F. Anderson&#39;s 2007 paper,  <a href="https://doi.org/10.1063/1.2799998">&quot;A modified Next Reaction Method for simulating chemical systems with time dependent propensities and delays&quot;</a>.  Both methods reuse draws of random numbers. The former works by accumulating  survival of a distribution in a linear space and the latter works by accumulating  survival of a distribution in a log space.</p><p>Each enabled clock specifies a univariate distribution from the <code>Distributions</code> package. Every distribution is more precise being sampled in the manner of the Next Reaction method (linear space) or the manner of the Modified Next Reaction method (log space). This sampler chooses which space to use depending on the type of the <code>UnivariateDistribution</code> and based on performance timings that are done during package testing. Defaults are set for those distributions included in the <code>Distributions.jl</code> package. If you want to add a distribution, then define:</p><pre><code class="language-julia hljs">sampling_space(::MyDistribution) = LogSampling</code></pre><p>If you want to override a choice in the library, then create a sub-type of the given distribution, and specify its sampling space.</p><pre><code class="language-julia hljs">struct LinearGamma &lt;: Distributions.Gamma end
sampling_space(::LinearGamma) = LinearSampling</code></pre><p>If you want to test a distribution, look at <code>tests/nrmetric.jl</code> to see how distributions are timed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/combinednr.jl#L97-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.DirectCall"><a class="docstring-binding" href="#CompetingClocks.DirectCall"><code>CompetingClocks.DirectCall</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DirectCall{KeyType,TimeType,TreeType}()</code></pre><p>DirectCall is responsible for sampling among Exponential distributions. It samples using the Direct method. In this case, there is no optimization to that Direct method, so we call it DirectCall because it recalculates everything every time you call it.</p><p>The algorithm for the Direct Method relies heavily on what data structure it uses to maintain a list of hazard rates, such that it can know the sum of those hazards and index into them using a random value. This struct has a default constructor that chooses a data structure for you, but there are several options.</p><p><strong>Example</strong></p><p>If we know that our simulation will only use a small number of different clock keys, then it would make sense to use a data structure that disables clocks by zeroing them out, instead of removing them from the list. This will greatly reduce memory churn. We can do that by changing the underlying data structure.</p><pre><code class="language-julia hljs">prefix_tree = BinaryTreePrefixSearch{T}()
keyed_prefix_tree = KeyedKeepPrefixSearch{K,typeof(prefix_tree)}(prefix_tree)
sampler_noremove = DirectCall{K,T,typeof(keyed_prefix_tree)}(keyed_prefix_tree)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/direct.jl#L7-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.FirstReaction"><a class="docstring-binding" href="#CompetingClocks.FirstReaction"><code>CompetingClocks.FirstReaction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FirstReaction{KeyType,TimeType}()</code></pre><p>This is the classic first reaction method for general distributions.  Every time you sample, this goes to each distribution and asks when it would fire. Then it takes the soonest and throws out the rest of the sampled times until the next sample. It can also be very fast when there are only a few clocks to sample.</p><p>One interesting property of this sampler is that you can call <code>next()</code> multiple times in order to get a distribution of next firing clocks and their times to fire.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/firstreaction.jl#L8-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.FirstToFire"><a class="docstring-binding" href="#CompetingClocks.FirstToFire"><code>CompetingClocks.FirstToFire</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FirstToFire{KeyType,TimeType}()</code></pre><p>This sampler is often the fastest for non-exponential distributions. When a clock is first enabled, this sampler asks the clock when it would fire and saves that time in a sorted heap of future times. Then it works through the heap, one by one. When a clock is disabled, its future firing time is removed from the list. There is no memory of previous firing times.</p><p>This uses a <code>DataStructures.MutableBinaryMinHeap</code> which is a Fibonacci heap. It has been tested against many other heaps and rarely loses by more than a few percent, so we are sticking with it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/firsttofire.jl#L13-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.PSSACR"><a class="docstring-binding" href="#CompetingClocks.PSSACR"><code>CompetingClocks.PSSACR</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PSSACR{KeyType,TimeType}(; ngroups::Int=64)</code></pre><p>Exact, continuous-time sampler using composition–rejection over groups.</p><p>Assumptions:</p><ul><li>Each enabled clock is Exponential with rate λ (i.e., distribution <code>Exponential(θ)</code> where λ=1/θ).</li><li>The sampler maintains group-wise sums and maxima of rates.</li><li>Time to next event is drawn from <code>Exp(∑λ)</code>, and the firing key is drawn by a two-stage selection: group by probability ∝ group-sum, then within-group by rejection from a uniform proposal with acceptance <code>λ/λ_max_group</code>.</li></ul><p><strong>Performance notes:</strong></p><ul><li>Choose <code>ngroups</code> so that groups remain small and rate magnitudes similar. If you possess &quot;owner&quot; metadata (partial-propensity style), call <code>assign_group!</code> <em>before</em> <code>enable!</code> to place clocks with common owners into the same group.</li></ul><p><strong>References:</strong></p><ul><li>R. Ramaswamy &amp; I. F. Sbalzarini, &quot;A partial-propensity variant of the composition-rejection SSA&quot;, J. Chem. Phys. 132, 044102 (2010).</li><li>A. Slepoy, A. P. Thompson, S. J. Plimpton, &quot;A constant-time kinetic Monte Carlo algorithm...&quot;, J. Chem. Phys. 128, 205101 (2008).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/pssa_cr.jl#L63-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.RSSA"><a class="docstring-binding" href="#CompetingClocks.RSSA"><code>CompetingClocks.RSSA</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RSSA{KeyType,TimeType}(; bound_factor=1.05)</code></pre><p>Rejection-based SSA with global Fenwick tree for candidate selection. This is for exponential distributions only not time-dependent rates.</p><ul><li><code>bound_factor</code> ≥ 1.0 controls default upper bounds: \bar a<em>i ← max(\bar a</em>i, bound<em>factor * a</em>i). Set to 1.0 for no rejections (reduces to direct-method timing with tree selection).</li></ul><p><strong>Algorithmic core:</strong></p><ul><li>Maintain per-clock <em>true</em> rate a<em>i and a certified upper bound ar a</em>i &gt;= a_i.</li><li>Maintain Ā = sum<em>i ar a</em>i and a Fenwick tree over { ar a_i } for O(log N) sampling.</li><li>Draw candidate times from Exp(Ā). Select candidate clock i by Categorical(ar a_i/Ā).</li><li>Accept with probability a<em>i / ar a</em>i; otherwise reject and continue thinning.</li></ul><p>Exactness: standard thinning of a Poisson process with rate Ā, with acceptance a<em>i/ar a</em>i, yields the target Markov jump process (homogeneous propensities). See Thanh et al. (2014, 2015).</p><p>Notes:</p><ul><li>This implementation targets time-homogeneous propensities (Exponential only). For time-dependent rates (tRSSA), you need piecewise-time envelopes and an integral sampler; these can be added as a thin extension without changing the public interface.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/rssa.jl#L11-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.Petri"><a class="docstring-binding" href="#CompetingClocks.Petri"><code>CompetingClocks.Petri</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Petri{KeyType,TimeType}()</code></pre><p>If you want to test a simulation, it can be helpful to test unlikely events. This sampler adopts the Petri net rule for which clock fires next: it&#39;s randomly chosen among all enabled events. The returned time is always the previous time plus one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/petri.jl#L3-L10">source</a></section></details></article><h2 id="Hierarchical-Sampling"><a class="docs-heading-anchor" href="#Hierarchical-Sampling">Hierarchical Sampling</a><a id="Hierarchical-Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Hierarchical-Sampling" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="CompetingClocks.MultipleDirect"><a class="docstring-binding" href="#CompetingClocks.MultipleDirect"><code>CompetingClocks.MultipleDirect</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MultipleDirect{SamplerKey,K,Time,Chooser} &lt;: SSA{K,Time}</code></pre><p>MultipleDirect is a sampler that contains multiple prefix-search data structures. Here SamplerKey is an identifier for the sampler. K is the type of the Clock key. Time is a Float64 or other clock time. Chooser is a function that selects a prefix-search given a clock key. This differs from a <a href="#CompetingClocks.MultiSampler"><code>MultiSampler</code></a> because this works only for exponential distributions, and it combines them by summing propensities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/multiple_direct.jl#L4-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.MultiSampler"><a class="docstring-binding" href="#CompetingClocks.MultiSampler"><code>CompetingClocks.MultiSampler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MultiSampler{SamplerKey,Key,Time}(which_sampler::Chooser) &lt;: SSA{Key,Time}</code></pre><p>A sampler returns the soonest event, so we can make a hierarchical sampler that returns the soonest event of the samplers it contains. This is useful because the performance of a sampler depends on the type of the event. For instance, some simulations have a few fast events and a lot of slow ones, so it helps to split them into separate data structures.</p><p>The <code>SamplerKey</code> is the type of an identifier for the samplers that this <code>MultiSampler</code> contains. The <code>which_sampler</code> argument is a strategy object that decides which event is sampled by which contained sampler. There is an example of this below.</p><p>Once a clock is first enabled, it will always go to the same sampler. This sampler remembers the associations, which could increase memory for simulations with semi-infinite clocks.</p><p><strong>Examples</strong></p><p>Let&#39;s make one sampler for exponential distributions, one for a few clocks we know will be fast and one for slower clocks. We can name them with symbols. The trick is that we need to direct each kind of distribution to the correct sampler. Use a Float64 for time and each clock can be identified with an Int64.</p><pre><code class="language-julia hljs">using CompetingClocks
using Distributions: Exponential, UnivariateDistribution

struct ByDistribution &lt;: SamplerChoice{Int64,Symbol} end

function CompetingClocks.choose_sampler(
    chooser::ByDistribution, clock::Int64, distribution::Exponential
    )::Symbol
    return :direct
end
function CompetingClocks.choose_sampler(
    chooser::ByDistribution, clock::Int64, distribution::UnivariateDistribution
    )::Symbol
    if clock &lt; 100
        return :fast
    else
        return :slow
    end
end
sampler = MultiSampler{Symbol,Int64,Float64}(ByDistribution())
sampler[:direct] = OptimizedDirect{Int64,Float64}()
sampler[:fast] = FirstToFire{Int64,Float64}()
sampler[:slow] = FirstToFire{Int64,Float64}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/sampler.jl#L16-L67">source</a></section></details></article><h2 id="Helper-Classes"><a class="docs-heading-anchor" href="#Helper-Classes">Helper Classes</a><a id="Helper-Classes-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-Classes" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="CompetingClocks.DebugWatcher"><a class="docstring-binding" href="#CompetingClocks.DebugWatcher"><code>CompetingClocks.DebugWatcher</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DebugWatcher()</code></pre><p>For debugging, it helps to have visibility into the simulation. This Watcher records everything that is enabled or disabled as a list of all enables and all disabled. It&#39;s the complete event history, and you can think of it as the filtration for the process going forward.</p><pre><code class="language-julia hljs">watcher = DebugWatcher{String}()
# enable and disable some things.
(watcher.enabled[1].clock,
watcher.enabled[1].distribution,
watcher.enabled[1].te,
watcher.enabled[1].when)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/trace/debug.jl#L6-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.TrackWatcher"><a class="docstring-binding" href="#CompetingClocks.TrackWatcher"><code>CompetingClocks.TrackWatcher</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TrackWatcher{K,T}()</code></pre><p>This Watcher doesn&#39;t sample. It records everything enabled. You can iterate over enabled clocks with a for-loop. If we think of the model as providing changes in which transitions are enabled or disabled, this Watcher accumulates those changes to provide a consistent list of all enabled transitions. Together, a model and this Watcher provide the Semi-Markov core matrix, or the row of it that is currently known.</p><pre><code class="language-julia hljs">for entry in tracker
    entry.clock
    entry.distribution
    entry.te
    entry.when
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/trace/track.jl#L44-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.TrajectoryWatcher"><a class="docstring-binding" href="#CompetingClocks.TrajectoryWatcher"><code>CompetingClocks.TrajectoryWatcher</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TrajectoryWatcher{K,T}</code></pre><p>This doesn&#39;t sample but calculates the likelihood of the path of samples from start to finish. It has many of the same interface functions as a sampler, but the core value is in the <a href="../contextinterface/#CompetingClocks.pathloglikelihood"><code>pathloglikelihood</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/trace/trajectory.jl#L3-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.PathLikelihoods"><a class="docstring-binding" href="#CompetingClocks.PathLikelihoods"><code>CompetingClocks.PathLikelihoods</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PathLikelihoods{K,T}</code></pre><p>Calculates the likelihood of one path of events and times according to a vector of different distributions. This accepts a vector of distributions in each <code>enable!</code> call. This can be useful for tuning distribution parameters, but its main use is for importance sampling with mixtures of distribution parameters in order to stabilize importance sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/trace/path_likelihoods.jl#L11-L19">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../integration-guide/">« Integration Guide</a><a class="docs-footer-nextpage" href="../samplers/">Understanding Samplers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 28 November 2025 20:25">Friday 28 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
