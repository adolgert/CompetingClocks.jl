<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Design · CompetingClocks.jl Documentation</title><meta name="title" content="Design · CompetingClocks.jl Documentation"/><meta property="og:title" content="Design · CompetingClocks.jl Documentation"/><meta property="twitter:title" content="Design · CompetingClocks.jl Documentation"/><meta name="description" content="Documentation for CompetingClocks.jl Documentation."/><meta property="og:description" content="Documentation for CompetingClocks.jl Documentation."/><meta property="twitter:description" content="Documentation for CompetingClocks.jl Documentation."/><meta property="og:url" content="https://adolgert.github.io/CompetingClocks.jl/develop/"/><meta property="twitter:url" content="https://adolgert.github.io/CompetingClocks.jl/develop/"/><link rel="canonical" href="https://adolgert.github.io/CompetingClocks.jl/develop/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CompetingClocks.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../guide/">Competing Clocks</a></li><li><a class="tocitem" href="../mainloop/">Sample Main Loop</a></li><li><a class="tocitem" href="../distributions/">Non-exponential Simulation</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../distrib/">Notation for Distributions</a></li><li><a class="tocitem" href="../background/">Markov Processes</a></li><li><a class="tocitem" href="../gsmp/">GSMP</a></li><li><a class="tocitem" href="../samplers/">Understanding Samplers</a></li><li><a class="tocitem" href="../hierarchical/">Hierarchical Samplers</a></li><li><a class="tocitem" href="../memory/">Transitions with Memory</a></li><li><a class="tocitem" href="../commonrandom/">Common Random Numbers</a></li><li><a class="tocitem" href="../debugging/">Debugging a Simulation that Uses CompetingClocks</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../constant_birth/">Birth-death Process</a></li><li><a class="tocitem" href="../sir/">SIR Model</a></li><li><a class="tocitem" href="../reliability/">Reliability</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../interface/">Interface</a></li><li><a class="tocitem" href="../reference/">Samplers</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Design</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Design</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/adolgert/CompetingClocks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/adolgert/CompetingClocks.jl/blob/main/docs/src/develop.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Design"><a class="docs-heading-anchor" href="#Design">Design</a><a id="Design-1"></a><a class="docs-heading-anchor-permalink" href="#Design" title="Permalink"></a></h1><p>The scope of this is that I want to make a continuous-time simulation that is rooted in stochastic processes and as fast as they can be. The state will be the simplest, a vector of integers. Transitions, however, can be non-Exponential distributions. I&#39;d like to exercise all of the top sampling methods. This code asks how to set up a best-practices continuous-time simulation in Julia. The fastest method for sampling is to use a hierarchical setup, where different sets of transitions get the samplers that are most efficient for their distributions.</p><p>The main research question is how to hook the state and transitions of the stochastic process to the sampler algorithm. The mathematical work I&#39;ve seen does sometimes discuss hierarchical sampling, but it doesn&#39;t discuss algorithms for how best to connect a transition with its appropriate sampler. How do we specify it that connection? There&#39;s nothing in the math about distributions having a name or an indexing key.</p><p>While we normally simulate, there are some other ways to use simulation code, and those other ways give a clue about how to separate functions.</p><ul><li>Fire transitions in a given order without sampling them. Work through a trace.</li><li>Construct a state by specifying an initial state and sequence of transitions.</li><li>Measure likelihood of a state without sampling. This is used for MCMC.</li></ul><h2 id="Vector-addition-systems"><a class="docs-heading-anchor" href="#Vector-addition-systems">Vector addition systems</a><a id="Vector-addition-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-addition-systems" title="Permalink"></a></h2><p>A vector addition system (VAS) defines the state as a vector of non-negative integers. Transitions are two matrices of shape (transition x state). One indicates how large the state vector has to be for that transition to be enabled. Together, they define values removed and added to the state vector when a transition fires.</p><p>In practice, vector addition systems aren&#39;t implemented with vectors. The professional versions are defined on bipartite graphs where the state is one node type and transitions are the other node type.</p><h2 id="Semi-Markov-Vector-Addition-System"><a class="docs-heading-anchor" href="#Semi-Markov-Vector-Addition-System">Semi-Markov Vector Addition System</a><a id="Semi-Markov-Vector-Addition-System-1"></a><a class="docs-heading-anchor-permalink" href="#Semi-Markov-Vector-Addition-System" title="Permalink"></a></h2><p>We&#39;ll make one little change to the VAS. Instead of having only exponential distributions, it can have general distribution types. That adds complexity to the sampler, but the samplers will handle that. For the VAS, it adds some state and adds burden to specification. The state now needs to track the time at which each transition was enabled, known as <span>$t_e$</span>. We&#39;ll call the main part of the state its physical state, which is the vector of integers in this case.</p><p>In order to specify a Markov VAS, you need to give a rate for each transition. A chemical simulation has a very particular function to determine the rate of transitions. For chemicals, the rate is a function of the number of possible combinations of the chemicals. For a Semi-Markov VAS, which we&#39;re making, we&#39;ll let the state be any function of the state of the system.</p><p>There&#39;s one other wrinkle to specifying a Semi-Markov VAS. The Zimmerman simulation book points out that non-Exponential transitions can have memory or be memoryless. He means that, if a transition is enabled and disabled, we need to decide whether that affects its rate the next time it&#39;s enabled. If the transition were emptying a bathtub, and we put in the stopper plug, then taking out that plug depends on the previous enabling. It must have memory. If it were the time a robot needs to put a gas cap on an assmebly-line car, it would need to begin from scratch during a restart.</p><h2 id="Core-responsibilities"><a class="docs-heading-anchor" href="#Core-responsibilities">Core responsibilities</a><a id="Core-responsibilities-1"></a><a class="docs-heading-anchor-permalink" href="#Core-responsibilities" title="Permalink"></a></h2><ol><li><p>The state of the system is dictated by stochastic processes theory: a. Physical state, which can be a vector of integers for this version. b. Enabling times. This is the time at which each transition was, or wasn&#39;t enabled. c. The last time any transition fired.</p></li><li><p>Sampling depends only on distributions, not any other information about each transition. All optimized samplers keep a cache of the distributions of enabled transitions and modify that cache with each firing.</p></li></ol><h2 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h2><p>Most samplers optimize their work by tracking what transitions were last enabled. They treat newly-enabled and newly-disabled transitions as a modification to the likelihood of the next sample. Some samplers don&#39;t store any state. First-reaction method is this way, as is the original Direct method. These are naive samplers, and I don&#39;t think it&#39;s worth optimizing for them. I would, instead, assume that all samplers track which transitions were last enabled. I&#39;ll add that as a layer on the first-reaction and direct methods.</p><h2 id="Sequence"><a class="docs-heading-anchor" href="#Sequence">Sequence</a><a id="Sequence-1"></a><a class="docs-heading-anchor-permalink" href="#Sequence" title="Permalink"></a></h2><p>The simulation inner loop is critical for efficient simulation. For continuous-time simulation, it&#39;s a game of clock-cycles, so we should get this right. This inner loop can have a lot of different kinds of calculations to do, and those calculations benefit from good cache use, right near the processor on L1. As a consequence, we want to design the parts of the inner loop so that they interleave work that operates on the same data.</p><p>If we think of a single transition as a consecutive set of steps, each of which has a different function, then those functions traverse state updates, transitions calculations, and sampling decisions.</p><ol><li>Fire a transition.</li><li>Modify state.</li><li>Calculate changes to transitions.</li><li>Update sampler information.</li><li>Sample for next transition.</li></ol><p>However, the state and transitions will be stored on a graph for the most efficient simulations. We&#39;d like to make the most efficient simulations possible. When state and transitions are stored on a graph, it helps to perform all operations on graph data while doing a <em>single traversal of the graph.</em></p><pre><code class="nohighlight hljs">Fire a transition
For each [state changed]
    Update a single state
    For each [transition depending on that state]
        Calculate the hazard rate for that transition.
        Update the sampler about that updated hazard.</code></pre><p>The goal, then, is to make code where firing, finding affected transitions, and sampling those transitions, is all separate, but they get called nicely in order within a single loop.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 20 August 2025 13:19">Wednesday 20 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
