<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Context Interface · CompetingClocks.jl Documentation</title><meta name="title" content="Context Interface · CompetingClocks.jl Documentation"/><meta property="og:title" content="Context Interface · CompetingClocks.jl Documentation"/><meta property="twitter:title" content="Context Interface · CompetingClocks.jl Documentation"/><meta name="description" content="Documentation for CompetingClocks.jl Documentation."/><meta property="og:description" content="Documentation for CompetingClocks.jl Documentation."/><meta property="twitter:description" content="Documentation for CompetingClocks.jl Documentation."/><meta property="og:url" content="https://adolgert.github.io/CompetingClocks.jl/contextinterface/"/><meta property="twitter:url" content="https://adolgert.github.io/CompetingClocks.jl/contextinterface/"/><link rel="canonical" href="https://adolgert.github.io/CompetingClocks.jl/contextinterface/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CompetingClocks.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../quickstart/">Quickstart</a></li><li><a class="tocitem" href="../mainloop/">Sample Main Loop</a></li><li><a class="tocitem" href="../choosing_sampler/">Choosing a Sampler</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../integration-guide/">Integration Guide</a></li><li><a class="tocitem" href="../low_level_interface/">Low-level Sampler Interface</a></li><li><a class="tocitem" href="../samplers/">Understanding Samplers</a></li><li><a class="tocitem" href="../guide/">Competing Clocks</a></li><li><a class="tocitem" href="../distributions/">Non-exponential Simulation</a></li><li><a class="tocitem" href="../hierarchical/">Hierarchical Samplers</a></li><li><a class="tocitem" href="../debugging/">Debugging a Simulation that Uses CompetingClocks</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../reliability/">Reliability</a></li><li><a class="tocitem" href="../sir/">SIR Model</a></li><li><a class="tocitem" href="../constant_birth/">Birth-death Process</a></li><li><a class="tocitem" href="../memory/">Transitions with Memory</a></li><li><a class="tocitem" href="../gene_expression/">Gene Expression</a></li></ul></li><li><span class="tocitem">Statistical Methods</span><ul><li><a class="tocitem" href="../commonrandom/">Common Random Numbers</a></li><li><a class="tocitem" href="../importance_skills/">Importance Sampling for Simulation</a></li><li><a class="tocitem" href="../hamiltonianmontecarlo/">Hamiltonian Monte Carlo</a></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">Gen.jl Integration</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../gen/overview/">Gen.jl and CompetingClocks.jl</a></li><li><a class="tocitem" href="../gen/distribution/">CompetingClocks as a Gen Distribution</a></li><li><a class="tocitem" href="../gen/generative_function/">CompetingClocks as a Gen Generative Function</a></li><li><a class="tocitem" href="../gen/observation_likelihood/">Observation Likelihood for Event Data</a></li><li><a class="tocitem" href="../gen/importance_mixture/">Importance Sampling with Mixture Proposals</a></li><li><a class="tocitem" href="../gen/hmc_paths/">HMC over Event Paths with Gen.jl</a></li></ul></li><li><a class="tocitem" href="../gen/turing_dist/">Bayesian Inference with Turing.jl</a></li><li><a class="tocitem" href="../gen/survival_snippet/">Integration with Survival.jl</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li class="is-active"><a class="tocitem" href>Context Interface</a><ul class="internal"><li><a class="tocitem" href="#Building-a-Context"><span>Building a Context</span></a></li><li><a class="tocitem" href="#Choosing-Sampler-Methods"><span>Choosing Sampler Methods</span></a></li><li><a class="tocitem" href="#Using-a-Context"><span>Using a Context</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Samplers</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Context Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Context Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/adolgert/CompetingClocks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/adolgert/CompetingClocks.jl/blob/main/docs/src/contextinterface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Context-Interface"><a class="docs-heading-anchor" href="#Context-Interface">Context Interface</a><a id="Context-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Context-Interface" title="Permalink"></a></h1><h2 id="Building-a-Context"><a class="docs-heading-anchor" href="#Building-a-Context">Building a Context</a><a id="Building-a-Context-1"></a><a class="docs-heading-anchor-permalink" href="#Building-a-Context" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="CompetingClocks.SamplingContext-Union{Tuple{R}, Tuple{T}, Tuple{K}, Tuple{Type{K}, Type{T}, R}} where {K, T, R&lt;:AbstractRNG}"><a class="docstring-binding" href="#CompetingClocks.SamplingContext-Union{Tuple{R}, Tuple{T}, Tuple{K}, Tuple{Type{K}, Type{T}, R}} where {K, T, R&lt;:AbstractRNG}"><code>CompetingClocks.SamplingContext</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SamplingContext(::Type{K}, ::Type{T}, rng::AbstractRNG;
    step_likelihood=false,
    path_likelihood=false,
    debug=false,
    recording=false,
    common_random=false,
    method=nothing,
    start_time::T,
    likelihood_cnt::Int
    )</code></pre><p>The SamplingContext is responsible for doing a perfect forwarding to multiple components that implement the desired features in a sampler.</p><p>It uses a Context pattern where each type parameter is either present or Nothing, and the compiler knows to optimize-away the Nothing. We keep the internal logic simple. If something is present, call it.</p><ul><li><p>memory</p></li><li><p>delayed transitions</p></li><li><p>hierarchical samplers</p></li><li><p><code>K</code> and <code>T</code> are the clock type and time type.</p></li><li><p><code>step_likelihood</code> - whether you will call <code>steploglikelihood</code> before each <code>fire!</code></p></li><li><p><code>path_likelihood</code> - whether you will call <code>pathloglikelihood</code>  at the end of a simulation run.</p></li><li><p><code>debug</code> - Print log messages at the debug level. Enabling this stores every enabling and disabling event so don&#39;t leave it on.</p></li><li><p><code>recording</code> - Store every enable and disable for later examination.</p></li><li><p><code>common_random</code> - Use common random numbers during sampling.</p></li><li><p><code>method</code> - If you want a single, particular sampler, put its <code>SamplerSpec</code> here. It will create a group called <code>:all</code> that has this sampling method.</p></li><li><p><code>start_time</code> - Sometimes a simulation shouldn&#39;t start at zero.</p></li><li><p><code>likelihood_cnt</code> - The number of likelihoods to compute, corresponds to number of distributions in <code>enable!</code> calls. This turns on <code>path_likelihood</code>.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">builder = SamplerBuilder(Tuple,Float64)
add_group!(builder, :sparky =&gt; (x,d) -&gt; x[1] == :recover, method=NextReaction())
add_group!(builder, :forthright=&gt;(x,d) -&gt; x[1] == :infect)
context = SamplingContext(builder, rng)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L54-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.SamplingContext-Union{Tuple{R}, Tuple{SamplerBuilder, R}} where R&lt;:AbstractRNG"><a class="docstring-binding" href="#CompetingClocks.SamplingContext-Union{Tuple{R}, Tuple{SamplerBuilder, R}} where R&lt;:AbstractRNG"><code>CompetingClocks.SamplingContext</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SamplingContext(builder::SamplerBuilder, rng)</code></pre><p>Uses the <a href="#CompetingClocks.SamplerBuilder"><code>SamplerBuilder</code></a> to make a SamplingContext.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L18-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.SamplerBuilder"><a class="docstring-binding" href="#CompetingClocks.SamplerBuilder"><code>CompetingClocks.SamplerBuilder</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SamplerBuilder(::Type{K}, ::Type{T};
    step_likelihood=false,
    path_likelihood=false,
    debug=false,
    recording=false,
    common_random=false,
    method=nothing,
    start_time::T,
    likelihood_cnt::Int
    )</code></pre><p>A SamplerBuilder is responsible for recording a user&#39;s requirements and building an initial sampler.</p><ul><li><code>K</code> and <code>T</code> are the clock type and time type.</li><li><code>step_likelihood</code> - whether you will call <code>steploglikelihood</code> before each <code>fire!</code></li><li><code>path_likelihood</code> - whether you will call <code>pathloglikelihood</code>  at the end of a simulation run.</li><li><code>debug</code> - Print log messages at the debug level. Enabling this stores every enabling and disabling event so don&#39;t leave it on.</li><li><code>recording</code> - Store every enable and disable for later examination.</li><li><code>common_random</code> - Use common random numbers during sampling.</li><li><code>method</code> - If you want a single, particular sampler, put its <code>SamplerSpec</code> here. It will create a group called <code>:all</code> that has this sampling method.</li><li><code>start_time</code> - Sometimes a simulation shouldn&#39;t start at zero.</li><li><code>likelihood_cnt</code> - The number of likelihoods to compute, corresponds to number of distributions in <code>enable!</code> calls. This turns on <code>path_likelihood</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">builder = SamplerBuilder(Tuple,Float64)
add_group!(builder, :sparky =&gt; (x,d) -&gt; x[1] == :recover, method=NextReaction())
add_group!(builder, :forthright=&gt;(x,d) -&gt; x[1] == :infect)
context = SamplingContext(builder, rng)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/sampler_builder.jl#L36-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.add_group!"><a class="docstring-binding" href="#CompetingClocks.add_group!"><code>CompetingClocks.add_group!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>The <code>selector</code> defines the group of clocks that go to this sampler using an inclusion rule, so it&#39;s a function from a clock key and distribution to a Bool.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/sampler_builder.jl#L97-L100">source</a></section></details></article><h2 id="Choosing-Sampler-Methods"><a class="docs-heading-anchor" href="#Choosing-Sampler-Methods">Choosing Sampler Methods</a><a id="Choosing-Sampler-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-Sampler-Methods" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="CompetingClocks.NextReactionMethod"><a class="docstring-binding" href="#CompetingClocks.NextReactionMethod"><code>CompetingClocks.NextReactionMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NextReactionMethod()</code></pre><p>Uses Anderson&#39;s Modified Next Reaction method for distributions in an Exponential class (Exponential, Weibull, Erlang) and the Next Reaction method for other distributions. Yes, these two methods are mixed into one sampler because Julia&#39;s holy traits pattern makes it efficient to use the fastest sampler on a distribution-by-distribution basis. Because it reuses draws, this is the best choice if you want to do variance reduction with Common Random Numbers.</p><p>See <a href="../low_level_interface/#CompetingClocks.CombinedNextReaction"><code>CombinedNextReaction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/samplerspec.jl#L12-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.DirectMethod"><a class="docstring-binding" href="#CompetingClocks.DirectMethod"><code>CompetingClocks.DirectMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DirectMethod()
DirectMethod(memory::Symbol, search::Symbol)
DirectMethod(:keep, :scan)
DirectMethod(:keep, :tree)
DirectMethod(:remove, :scan)
DirectMethod(:remove, :tree)</code></pre><p>Use this to specify any Direct method for Exponential distributions. Defaults to <code>memory=:remove</code> so it limits memory growth over time but <code>memory=:keep</code> will be faster if the space of clock keys is limited. Defaults to <code>search=:tree</code> for best performance for many enabled clocks but <code>search=:scan</code> is faster for small numbers of clocks. The different kinds of methods, like &quot;Optimized Direct Methods&quot; amount to using different computer science techniques for scanning sums of hazard rates, and that&#39;s what the <code>search</code> algorithm lets you choose.</p><p>See <a href="../low_level_interface/#CompetingClocks.DirectCall"><code>DirectCall</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/samplerspec.jl#L28-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.FirstReactionMethod"><a class="docstring-binding" href="#CompetingClocks.FirstReactionMethod"><code>CompetingClocks.FirstReactionMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FirstReactionMethod()</code></pre><p>The classic sampler that draws every clock at every time step. Very fast for very small numbers of enabled clocks and returns a new <code>next()</code> every time it is called which helps when resampling paths. Other samplers return the same value every time you call <code>next()</code> unless you <code>jitter!</code> them, which is expensive.</p><p>See <a href="../low_level_interface/#CompetingClocks.FirstReaction"><code>FirstReaction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/samplerspec.jl#L78-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.FirstToFireMethod"><a class="docstring-binding" href="#CompetingClocks.FirstToFireMethod"><code>CompetingClocks.FirstToFireMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FirstToFireMethod()</code></pre><p>The simplest and fastest sampler. When you <code>enable!()</code> a clock, this draws the firing time and saves it in a queue.</p><p>See <a href="../low_level_interface/#CompetingClocks.FirstToFire"><code>FirstToFire</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/samplerspec.jl#L92-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.PartialPropensityMethod"><a class="docstring-binding" href="#CompetingClocks.PartialPropensityMethod"><code>CompetingClocks.PartialPropensityMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PartialPropensityMethod()</code></pre><p>Exact, continuous-time sampler using composition-rejection over groups. Only for exponential distributions. This variant of partial-propensity composition-rejection implements the sampler but not the reaction network. The reaction-network can be implemented outside of the sampler.</p><p>See <a href="../low_level_interface/#CompetingClocks.PSSACR"><code>PSSACR</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/samplerspec.jl#L121-L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.PetriMethod"><a class="docstring-binding" href="#CompetingClocks.PetriMethod"><code>CompetingClocks.PetriMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PetriMethod()
PetriMethod(dt)</code></pre><p>Samples by picking at random ignoring distributions. Good for testing rare cases in simulations. Increments time <code>dt=1.0</code> by default. It&#39;s called &quot;Petri&quot; because a Petri net model always chooses the next event at random.</p><p>See <a href="../low_level_interface/#CompetingClocks.Petri"><code>Petri</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/samplerspec.jl#L138-L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.RejectionMethod"><a class="docstring-binding" href="#CompetingClocks.RejectionMethod"><code>CompetingClocks.RejectionMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RejectionMethod(bound_factor=1.05)</code></pre><p>A rejection-based algorithm. Only for exponential distributions, this may be the fastest for large simulations. The <code>bound_factor&gt;= 1.0</code> controls the default upper bounds. Set to 1.0 for no rejections, which reduces this to the direct method.</p><p>See <a href="../low_level_interface/#CompetingClocks.RSSA"><code>RSSA</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/samplerspec.jl#L104-L113">source</a></section></details></article><h2 id="Using-a-Context"><a class="docs-heading-anchor" href="#Using-a-Context">Using a Context</a><a id="Using-a-Context-1"></a><a class="docs-heading-anchor-permalink" href="#Using-a-Context" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="CompetingClocks.enable!-Union{Tuple{T}, Tuple{K}, Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}, K, Any, T}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.enable!-Union{Tuple{T}, Tuple{K}, Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}, K, Any, T}} where {K, T}"><code>CompetingClocks.enable!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enable!(sampler, clock, distribution, relative_te)</code></pre><p>Tell the sampler to start a clock with a time shift to the left or right.</p><ul><li><code>sampler::SSA{KeyType,TimeType}</code> - The sampler to tell.</li><li><code>clock::KeyType</code> - The ID of the clock. Can be a string, integer, tuple, etc.</li><li><code>distribution::Distributions.UnivariateDistribution</code></li><li><code>relative_te::TimeType</code> - The zero-point of the distribution relative to the current simulation time. A <code>-0.1</code> shifts the distribution to the left. A <code>0.1</code> says the clock cannot fire until after <code>0.1</code> units of time have passed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L212-L224">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.enable!-Union{Tuple{T}, Tuple{K}, Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}, K, Any}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.enable!-Union{Tuple{T}, Tuple{K}, Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}, K, Any}} where {K, T}"><code>CompetingClocks.enable!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enable!(sampler, clock, distribution)</code></pre><p>Tell the sampler to start a clock.</p><ul><li><code>sampler::SSA{KeyType,TimeType}</code> - The sampler to tell.</li><li><code>clock::KeyType</code> - The ID of the clock. Can be a string, integer, tuple, etc.</li><li><code>distribution::Distributions.UnivariateDistribution</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L240-L250">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.enable!-Union{Tuple{T}, Tuple{K}, Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}, K, Vector, T}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.enable!-Union{Tuple{T}, Tuple{K}, Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}, K, Vector, T}} where {K, T}"><code>CompetingClocks.enable!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enable!(sampler, clock, distribution::Vector, relative_te)</code></pre><p>Vectorized version of enable! for multiple-distributions in likelihood. This will sample times from the first distribution in the vector unless <code>sample_from_distribution!</code> is set. All distributions are used to calculate a path likelihood for importance sampling.</p><ul><li><code>sampler::SSA{KeyType,TimeType}</code> - The sampler to tell.</li><li><code>clock::KeyType</code> - The ID of the clock. Can be a string, integer, tuple, etc.</li><li><code>distribution::Vector{Distributions.UnivariateDistribution}</code></li><li><code>relative_te::TimeType</code> - The zero-point of the distribution relative to the current simulation time. A <code>-0.1</code> shifts the distribution to the left. A <code>0.1</code> says the clock cannot fire until after <code>0.1</code> units of time have passed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L256-L271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.enable!-Union{Tuple{T}, Tuple{K}, Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}, K, Vector}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.enable!-Union{Tuple{T}, Tuple{K}, Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}, K, Vector}} where {K, T}"><code>CompetingClocks.enable!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enable!(sampler, clock, distribution::Vector)</code></pre><p>Vectorized version of enable! for multiple-distributions in likelihood. This will sample times from the first distribution in the vector unless <code>sample_from_distribution!</code> is set. All distributions are used to calculate a path likelihood for importance sampling.</p><ul><li><code>sampler::SSA{KeyType,TimeType}</code> - The sampler to tell.</li><li><code>clock::KeyType</code> - The ID of the clock. Can be a string, integer, tuple, etc.</li><li><code>distribution::Vector{Distributions.UnivariateDistribution}</code></li></ul><p>This version enables the clock with no time-shifting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L291-L304">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.disable!-Union{Tuple{T}, Tuple{K}, Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}, K}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.disable!-Union{Tuple{T}, Tuple{K}, Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}, K}} where {K, T}"><code>CompetingClocks.disable!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">disable!(sampler, clock)</code></pre><p>Tell the sampler to forget a clock. The clock will be disabled at the time set by the last call to <code>fire!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L310-L315">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.next-Union{Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.next-Union{Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}"><code>CompetingClocks.next</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">next(ctx::SamplingContext)</code></pre><p>Return <code>(when, clock-key)</code> for the next event. This does NOT fire the event. You can check if <code>when</code> is past the end time of the simulation and choose not to fire that event. For samplers like <code>FirstReactionMethod</code>, you could call this many times to generate many possible events.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L324-L331">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.fire!-Union{Tuple{T}, Tuple{K}, Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}, K, T}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.fire!-Union{Tuple{T}, Tuple{K}, Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}, K, T}} where {K, T}"><code>CompetingClocks.fire!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fire!(ctx::SamplingContext, clock, when)</code></pre><p>Decide the next <code>clock</code> key to fire and the time at which it fires. This sets the internal time of the simulation to the new time <code>when</code>. It also disables the given <code>clock</code> key.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L337-L343">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.reset!-Union{Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.reset!-Union{Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}"><code>CompetingClocks.reset!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reset!(sampler)</code></pre><p>After a sampler is used for a simulation run, it has internal state. This function resets that internal state to the initial value in preparation for another sample run.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/sample/interface.jl#L52-L58">source</a></section><section><div><pre><code class="language-julia hljs">reset!(sampling)</code></pre><p>Clears all clock values in a <code>SamplingContext</code> at the top of a loop over simulations. Call this instead of allocating a new sampler for each iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L352-L357">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.copy_clocks!-Union{Tuple{T}, Tuple{K}, Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}, SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.copy_clocks!-Union{Tuple{T}, Tuple{K}, Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}, SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}}} where {K, T}"><code>CompetingClocks.copy_clocks!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">copy_clocks!(dst::SamplingContext, src::SamplingContext)</code></pre><p>Used for splitting a simulation near a rare event. You keep a vector of samplers and once your current sampler reaches a simulation state, copy its state into the vector of samplers and pick up where it left off. The destination <code>SamplingContext</code> has its own random number generator which will not be overwritten. The destination sampler will be jittered so that it will return different <code>next()</code> samples from the same set of enabled clocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L366-L375">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.split!-Union{Tuple{S}, Tuple{T}, Tuple{K}, Tuple{AbstractVector{S}, SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}}} where {K, T, S&lt;:SamplingContext}"><a class="docstring-binding" href="#CompetingClocks.split!-Union{Tuple{S}, Tuple{T}, Tuple{K}, Tuple{AbstractVector{S}, SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}}} where {K, T, S&lt;:SamplingContext}"><code>CompetingClocks.split!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">split!(dst::AbstractVector{S&lt;:SamplingContext}, src::SamplingContext{K,T})</code></pre><p>If the <code>src</code> sampler has gotten to a good spot in the simulation, split it into multiple copies in the destination vector. Update the <code>split_weight</code> member of each destination copy by <code>1/length(dst)</code>. The destination can be a view of a vector that was created with <code>clone()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L386-L393">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.Libc.time-Tuple{SamplingContext}"><a class="docstring-binding" href="#Base.Libc.time-Tuple{SamplingContext}"><code>Base.Libc.time</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">time(sampling)</code></pre><p>Get the current simulation time. Simulation times are incremented by each call to <code>fire!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L147-L152">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.sample_from_distribution!-Tuple{SamplingContext, Any}"><a class="docstring-binding" href="#CompetingClocks.sample_from_distribution!-Tuple{SamplingContext, Any}"><code>CompetingClocks.sample_from_distribution!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sample_from_distribution!(sampling, index)</code></pre><p>If you created a <code>SamplerBuilder</code> with <code>likelihood_cnt &gt; 1</code>, then you are going to call <code>enable!</code> for some or all clocks using a vector of distributions. In that case, the <code>SamplingContext</code> will default to using the first distribution to decide which event comes next. That way you get a sample from distribution 1 and likelihoods from distributions <code>(1, 2, and so on)</code>. For doing mixed importance sampling, you will sample from several distributions and calculate a weighted average. This functions lets you choose which of the enabled distribution vector to sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L156-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.clone-Union{Tuple{Dbg}, Tuple{CRN}, Tuple{Like}, Tuple{RNG}, Tuple{Sampler}, Tuple{T}, Tuple{K}, Tuple{SamplingContext{K, T, Sampler, RNG, Like, CRN, Dbg}, RNG}} where {K, T, Sampler, RNG, Like, CRN, Dbg}"><a class="docstring-binding" href="#CompetingClocks.clone-Union{Tuple{Dbg}, Tuple{CRN}, Tuple{Like}, Tuple{RNG}, Tuple{Sampler}, Tuple{T}, Tuple{K}, Tuple{SamplingContext{K, T, Sampler, RNG, Like, CRN, Dbg}, RNG}} where {K, T, Sampler, RNG, Like, CRN, Dbg}"><code>CompetingClocks.clone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">clone(sampling, rng)</code></pre><p>Given a <code>SamplingContext</code>, make a copy as though you had called the constructor again. This is useful for creating a vector of <code>SamplingContext</code> for multi-threading or for splitting paths. This clone will clone every part of the object. Note that the random number generator is copied, and you will want that to be unique for each clone.</p><p>You need to give each sampler its own random number generator, <code>rng</code>. If you were making parallel RNGs with the <code>Random123</code> package, it might look like:</p><p><code>julia master_seed = (0xd897a239, 0x77ff9238) rng = Philox4x((0, 0, 0, 0), master_seed) Key = Int64 sampler = SamplingContext(SamplerBuilder(Key,Float64; path_likelihood=true), rng) observation_weight = zeros(Float64, particle_cnt) total_weight = zeros(Float64, particle_cnt) samplers = Vector{typeof(sampler)}(undef, particle_cnt) for init_idx in 1:particle_cnt     rng = Philox4x((0, 0, 0, init_idx), master_seed)     samplers[init_idx] = clone(sampler, rng)     init!(state[init_idx], samplers[init_idx]) # For some initialization of state. end</code>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L105-L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.freeze_crn!-Tuple{SamplingContext}"><a class="docstring-binding" href="#CompetingClocks.freeze_crn!-Tuple{SamplingContext}"><code>CompetingClocks.freeze_crn!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">freeze_crn!(ctx::SamplingContext)</code></pre><p>After running the simulation to collect random draws, call this function to stop collection of new draws and solely replay the draws that were collected, using only fresh draws for clocks that weren&#39;t seen before.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L179-L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.reset_crn!-Tuple{SamplingContext}"><a class="docstring-binding" href="#CompetingClocks.reset_crn!-Tuple{SamplingContext}"><code>CompetingClocks.reset_crn!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reset_crn!(ctx::SamplingContext)</code></pre><p>This resets a sampler including erasing its stored common random numbers. Using a simple <code>reset!(sampler)</code> won&#39;t erase the saved CRN draws.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L196-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.enabled-Tuple{SamplingContext}"><a class="docstring-binding" href="#CompetingClocks.enabled-Tuple{SamplingContext}"><code>CompetingClocks.enabled</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enabled(sampling)</code></pre><p>Returns a set of enabled clock keys. This will aggregate enabled clock keys across hierarchical samplers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L404-L409">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.enabled_history-Tuple{SamplingContext}"><a class="docstring-binding" href="#CompetingClocks.enabled_history-Tuple{SamplingContext}"><code>CompetingClocks.enabled_history</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enabled_history(ctx::SamplingContext)</code></pre><p>Returns a <code>Vector{EnablingEntry{K,T}}</code> that has every time a clock was enabled.</p><p>See <a href="#CompetingClocks.EnablingEntry"><code>CompetingClocks.EnablingEntry</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L416-L422">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.disabled_history-Tuple{SamplingContext}"><a class="docstring-binding" href="#CompetingClocks.disabled_history-Tuple{SamplingContext}"><code>CompetingClocks.disabled_history</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">disabled_history(ctx::SamplingContext)</code></pre><p>Returns a <code>Vector{DisablingEntry{K,T}}</code> that has every time a clock was enabled.</p><p>See <a href="#CompetingClocks.DisablingEntry"><code>CompetingClocks.DisablingEntry</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L431-L437">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.EnablingEntry"><a class="docstring-binding" href="#CompetingClocks.EnablingEntry"><code>CompetingClocks.EnablingEntry</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EnablingEntry{K,T}(clock::K, distribution, te::T, when::T)</code></pre><p>Records that <code>clock</code> is enabled at time <code>when</code> with an enabling time <code>te</code> (in absolute time) that sets the zero of the <code>distribution</code>.</p><p><strong>Fields</strong></p><ul><li><code>clock::K</code>: The key for the event/clock/transition.</li><li><code>distribution::Distributions.UnivariateDistribution</code>, a distribution of clock firing times.</li><li><code>te::T</code> - An absolute time to use as the zero-time for the distribution. Usually the same as <code>when</code>.</li><li><code>when::T</code> - The time this clock was enabled.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/trace/track.jl#L7-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.DisablingEntry"><a class="docstring-binding" href="#CompetingClocks.DisablingEntry"><code>CompetingClocks.DisablingEntry</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DisablingEntry{K,T}(clock::K, when::T)</code></pre><p>Records that <code>clock</code> is disabled at time <code>when</code>.</p><p><strong>Fields</strong></p><ul><li><code>clock::K</code>: The key for the event/clock/transition.</li><li><code>when::T</code> - The time this clock was enabled.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/trace/track.jl#L27-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.length-Tuple{SamplingContext}"><a class="docstring-binding" href="#Base.length-Tuple{SamplingContext}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">length(sampling)</code></pre><p>The total number of enabled clocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L446-L450">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.isenabled-Union{Tuple{K}, Tuple{SamplingContext{K, T, Sampler} where {T, Sampler&lt;:SSA{K, T}}, K}} where K"><a class="docstring-binding" href="#CompetingClocks.isenabled-Union{Tuple{K}, Tuple{SamplingContext{K, T, Sampler} where {T, Sampler&lt;:SSA{K, T}}, K}} where K"><code>CompetingClocks.isenabled</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isenabled(sampling, clock)</code></pre><p>Boolean for whether this clock key is currently enabled, checked across hierarchical samplers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L457-L462">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.keytype-Union{Tuple{SamplingContext{K, T, Sampler} where {T, Sampler&lt;:SSA{K, T}}}, Tuple{K}} where K"><a class="docstring-binding" href="#Base.keytype-Union{Tuple{SamplingContext{K, T, Sampler} where {T, Sampler&lt;:SSA{K, T}}}, Tuple{K}} where K"><code>Base.keytype</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">keytype(sampler)</code></pre><p>Return the type of clock keys.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/sample/interface.jl#L154-L158">source</a></section><section><div><pre><code class="language-julia hljs">keytype(sampling)</code></pre><p>The type for the clock key. If you can use a concrete type, that helps performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L468-L473">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.timetype-Union{Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}"><a class="docstring-binding" href="#CompetingClocks.timetype-Union{Tuple{SamplingContext{K, T, Sampler} where Sampler&lt;:SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}"><code>CompetingClocks.timetype</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">timetype(sampler)</code></pre><p>Return the type of clock times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/sample/interface.jl#L162-L166">source</a></section><section><div><pre><code class="language-julia hljs">timetype(sampling)</code></pre><p>The type for the time, usually a <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L476-L480">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.steploglikelihood-Tuple{SamplingContext, Any, Any}"><a class="docstring-binding" href="#CompetingClocks.steploglikelihood-Tuple{SamplingContext, Any, Any}"><code>CompetingClocks.steploglikelihood</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">steploglikelihood(sampling, when, which)</code></pre><p>If the next event had clock key <code>which</code> and happened at time <code>when</code>, what would be the log-likelihood of that event conditioned on the last event? This calculates relative to the last call to <code>fire!()</code>. If you were to integrate this value over all enabled events, from the last firing time to <code>Inf</code> with the <code>QuadGK</code> package, it would sum to one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L484-L492">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.pathloglikelihood-Tuple{SamplingContext, Any}"><a class="docstring-binding" href="#CompetingClocks.pathloglikelihood-Tuple{SamplingContext, Any}"><code>CompetingClocks.pathloglikelihood</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pathloglikelihood(sampling, endtime)</code></pre><p>Calculates the log-likelihood across all events since the start of the simulation and up to the given end time. We include the end time because some statistics are normalized not to the last event but to a specific time, so this includes the probability that no event fired before the given end time.</p><p>This value can be used to weight paths for importance sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/1c9af5b4e3050ce3269584f87c01ad0b57a0dc05/src/context.jl#L507-L516">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gen/survival_snippet/">« Integration with Survival.jl</a><a class="docs-footer-nextpage" href="../reference/">Samplers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 28 November 2025 16:58">Friday 28 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
