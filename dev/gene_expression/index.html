<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gene Expression · CompetingClocks.jl Documentation</title><meta name="title" content="Gene Expression · CompetingClocks.jl Documentation"/><meta property="og:title" content="Gene Expression · CompetingClocks.jl Documentation"/><meta property="twitter:title" content="Gene Expression · CompetingClocks.jl Documentation"/><meta name="description" content="Documentation for CompetingClocks.jl Documentation."/><meta property="og:description" content="Documentation for CompetingClocks.jl Documentation."/><meta property="twitter:description" content="Documentation for CompetingClocks.jl Documentation."/><meta property="og:url" content="https://adolgert.github.io/CompetingClocks.jl/gene_expression/"/><meta property="twitter:url" content="https://adolgert.github.io/CompetingClocks.jl/gene_expression/"/><link rel="canonical" href="https://adolgert.github.io/CompetingClocks.jl/gene_expression/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CompetingClocks.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../quickstart/">Quickstart</a></li><li><a class="tocitem" href="../mainloop/">Sample Main Loop</a></li><li><a class="tocitem" href="../choosing_sampler/">Choosing a Sampler</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../integration-guide/">Integration Guide</a></li><li><a class="tocitem" href="../low_level_interface/">Low-level Sampler Interface</a></li><li><a class="tocitem" href="../samplers/">Understanding Samplers</a></li><li><a class="tocitem" href="../delayed/">Delayed Clocks</a></li><li><a class="tocitem" href="../guide/">Competing Clocks</a></li><li><a class="tocitem" href="../distributions/">Non-exponential Simulation</a></li><li><a class="tocitem" href="../hierarchical/">Hierarchical Samplers</a></li><li><a class="tocitem" href="../debugging/">Debugging a Simulation that Uses CompetingClocks</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../reliability/">Reliability</a></li><li><a class="tocitem" href="../sir/">SIR Model</a></li><li><a class="tocitem" href="../constant_birth/">Birth-death Process</a></li><li><a class="tocitem" href="../memory/">Transitions with Memory</a></li><li class="is-active"><a class="tocitem" href>Gene Expression</a><ul class="internal"><li><a class="tocitem" href="#Importance-sampling"><span>Importance sampling</span></a></li><li><a class="tocitem" href="#State-of-the-system"><span>State of the system</span></a></li><li><a class="tocitem" href="#Events-in-the-system"><span>Events in the system</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><span class="tocitem">Statistical Methods</span><ul><li><a class="tocitem" href="../commonrandom/">Common Random Numbers</a></li><li><a class="tocitem" href="../importance_skills/">Importance Sampling for Simulation</a></li><li><a class="tocitem" href="../hamiltonianmontecarlo/">Hamiltonian Monte Carlo</a></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">Gen.jl Integration</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../gen/overview/">Gen.jl and CompetingClocks.jl</a></li><li><a class="tocitem" href="../gen/distribution/">CompetingClocks as a Gen Distribution</a></li><li><a class="tocitem" href="../gen/generative_function/">CompetingClocks as a Gen Generative Function</a></li><li><a class="tocitem" href="../gen/observation_likelihood/">Observation Likelihood for Event Data</a></li><li><a class="tocitem" href="../gen/importance_mixture/">Importance Sampling with Mixture Proposals</a></li><li><a class="tocitem" href="../gen/hmc_paths/">HMC over Event Paths with Gen.jl</a></li></ul></li><li><a class="tocitem" href="../gen/turing_dist/">Bayesian Inference with Turing.jl</a></li><li><a class="tocitem" href="../gen/survival_snippet/">Integration with Survival.jl</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../contextinterface/">Context Interface</a></li><li><a class="tocitem" href="../reference/">Samplers</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Gene Expression</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gene Expression</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/adolgert/CompetingClocks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/adolgert/CompetingClocks.jl/blob/main/docs/src/gene_expression.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Stochastic-Gene-Expression"><a class="docs-heading-anchor" href="#Stochastic-Gene-Expression">Stochastic Gene Expression</a><a id="Stochastic-Gene-Expression-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-Gene-Expression" title="Permalink"></a></h1><p>This is a long example to demonstrate the use of path likelihoods to do importance sampling. The goal of the example is to estimate the probability of a transcriptional burst.</p><p>DNA becomes proteins in a three-step process.</p><ol><li>DNA can replicate itself.</li><li>Transcription changes a gene in DNA into RNA.</li><li>Translation turns RNA into protein.</li></ol><p>We will account for the changing states of the system.</p><ul><li><p>A <strong>gene</strong> can be ON or OFF. When it&#39;s ON, it can make RNA. We are looking for the case where the switch stays on longer.</p></li><li><p>The gene has startup time to transcribe its first RNA. One possibile hazard rate comes from the LogNormal distribution.</p></li><li><p>mRNA degrades. Different parts of the mRNA are degrading individually with constant rates until they reach a threshold. The time to the threshold is described by a Gamma distribution.</p></li><li><p>Each mRNA makes proteins until it degrades.</p></li></ul><h2 id="Importance-sampling"><a class="docs-heading-anchor" href="#Importance-sampling">Importance sampling</a><a id="Importance-sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Importance-sampling" title="Permalink"></a></h2><p>The main challenge of simulating transcriptional bursts is that large bursts are rare. This is a good case for using importance sampling. Importance sampling is a way to simulate from a biased set of distributions, in this case distributions weighted towards making more large bursts, but to account for that bias in your final estimate.</p><p>The usual way to use simulations to estimate a quantity is to sum the outcome across trajectories.</p><p class="math-container">\[E_p[f(X)] \approx \frac{1}{N}\sum_{i=1}^N f(x_i)\]</p><p>That sum is an approximation of a statistical expectation of <span>$f$</span> over the probability distribution <span>$p$</span>.</p><p class="math-container">\[E_p[f(X)] = \int f(x)p(x)dx\]</p><p>The events in a simulation and their distributions determine the probability <span>$p(x)$</span> for each trajectory <span>$x$</span>, and for rare events that probability is very small, so we will bias it.</p><p>We bias it by picking different distributions for our events. Let&#39;s call the biased space <span>$q$</span>. If we work backwards from the statistical expression, we will see that we can undo the bias when we do our sum over trajectories.</p><p class="math-container">\[E_p[f(x)] = \int f(x)\frac{p(x)}{q(x)}dx = E_q[f(X)\frac{p(X)}{q(X)}].\]</p><p>Here <span>$X$</span> is a sample under the distribution <span>$q$</span>. That means we draw from <span>$q$</span> and at the end sum with a weight on each trajectory.</p><p class="math-container">\[\hat{\mu} = \frac{1}{N}\sum_{i=1}^N f(X_i)w(X_i)\]</p><p>Here the importance weight is <span>$w(x)=p(x)/q(x)$</span>. This package&#39;s samplers will calculate that weigth for you as a path log-likelihood, which is <span>$\log w(x)$</span>.</p><p>Let&#39;s give this a try for gene expression. We can use an intuitive bias shift.</p><p>We&#39;re going to rely on standard Julia distributions with one extra one, imported from the file <code>genedist.jl</code> which expresses the initial slowness of MRNA production using a time-varying rate.</p><pre><code class="language-julia hljs">using CompetingClocks
using Distributions
using Logging
using Random
using Printf
include(&quot;genedist.jl&quot;)</code></pre><pre><code class="nohighlight hljs">Base.rand</code></pre><h2 id="State-of-the-system"><a class="docs-heading-anchor" href="#State-of-the-system">State of the system</a><a id="State-of-the-system-1"></a><a class="docs-heading-anchor-permalink" href="#State-of-the-system" title="Permalink"></a></h2><p>We start the system when the promoter turns ON and stop the simulation when the promoter turns OFF.</p><ol><li>Vector of MRNA. Each one was created at a certain time and is enabled/disabled.</li><li>Count of total proteins created.</li></ol><h2 id="Events-in-the-system"><a class="docs-heading-anchor" href="#Events-in-the-system">Events in the system</a><a id="Events-in-the-system-1"></a><a class="docs-heading-anchor-permalink" href="#Events-in-the-system" title="Permalink"></a></h2><ol><li><code>(:on, 0)</code>, Turn on the promoter. We use this to start the simulation.</li><li><code>(:transcribe, 0)</code> - When this fires, the promoter creates an MRNA.</li><li><code>(:translate, 0)</code> - The rate of translation is proportional to the number of MRNA that currently exist.</li><li><code>(:degrade, mrna_id)</code> - A particular MRNA will degrade, turning it off.</li></ol><pre><code class="language-julia hljs">Time = Float64
Epoch = Int
mutable struct GeneExpression
    mrna::Vector{Tuple{Time,Bool}}
    protein::Int
    θ::Dict{Symbol,NTuple{2,Float64}}
    function GeneExpression(params)
        mrna = Tuple{Time,Bool}[]
        sizehint!(mrna, 2000)
        new(mrna, 0, params)
    end
end
Base.empty!(ge::GeneExpression) = (empty!(ge.mrna); ge.protein = 0; nothing)</code></pre><p>You will see in the simulation that we initialize two distributions for each event. The first is used to determine the likelihood of the event. The second distribution is used to sample for the next time. These two can be the same, or they can differ if we want to use importance sampling.</p><p>When we turn the promoter on, it turns on slowly and ramps up. This is reflected in a custom distribution called <code>TranscriptionRate</code>.</p><pre><code class="language-julia hljs">function turn_promoter_on(model, sampler, individual, when, θ)
    enable!(sampler, (:off, 0), [Exponential(inv(θ[:promoter_off][1])), Exponential(inv(θ[:promoter_off][2]))])
    rate1 = TranscriptionRate(θ[:transcribe_max][1], θ[:transcribe_remodel][1])
    rate2 = TranscriptionRate(θ[:transcribe_max][2], θ[:transcribe_remodel][2])
    enable!(sampler, (:transcribe, 0), [rate1, rate2])
end</code></pre><pre><code class="nohighlight hljs">turn_promoter_on (generic function with 1 method)</code></pre><p>Turning the promoter off doesn&#39;t stop the system. We count every protein created until all MRNA degrade.</p><pre><code class="language-julia hljs">turn_promoter_off(model, sampler, individual, when, θ) = disable!(sampler, (:transcribe, 0))</code></pre><pre><code class="nohighlight hljs">turn_promoter_off (generic function with 1 method)</code></pre><p>The transcription rate depends on the number of MRNA present as a total, but each MRNA can degrade individually with a Gamma distribution that starts it&#39;s clock when that particular MRNA is produced. The Gamma distribution is the same distribution we use to model how a person recovers from the flu.</p><pre><code class="language-julia hljs">function transcribe_mrna(model, sampler, individual, when, θ)
    pre_event_total = count(x -&gt; x[2], model.mrna)
    total = pre_event_total
    mrna_id = length(model.mrna) + 1
    push!(model.mrna, (when, true))
    time_offset = when - 0  # The 0 is when the promoter turned on.
    rate1 = TranscriptionRate(θ[:transcribe_max][1], θ[:transcribe_remodel][1]; t0=time_offset)
    rate2 = TranscriptionRate(θ[:transcribe_max][2], θ[:transcribe_remodel][2]; t0=time_offset)
    enable!(sampler, (:transcribe, 0), [rate1, rate2])
    total = count(x -&gt; x[2], model.mrna)
    transrate1 = Exponential(inv(θ[:translate][1] * total))
    transrate2 = Exponential(inv(θ[:translate][2] * total))
    pre_event_total &gt; 0 &amp;&amp; disable!(sampler, (:translate, 0))
    enable!(sampler, (:translate, 0), [transrate1, transrate2])
    gamma1 = Gamma(θ[:degrade_k][1], inv(θ[:degrade_theta][1]))
    gamma2 = Gamma(θ[:degrade_k][2], inv(θ[:degrade_theta][2]))
    enable!(sampler, (:degrade, mrna_id), [gamma1, gamma2])
end</code></pre><pre><code class="nohighlight hljs">transcribe_mrna (generic function with 1 method)</code></pre><p>Degrading an MRNA will turn off protein production for that MRNA, but if it turns off the <em>last</em> MRNA, then it turns of all translation.</p><pre><code class="language-julia hljs">function degrade_mrna(model, sampler, individual, when, θ)
    pre_event_total = count(x -&gt; x[2], model.mrna)
    total = pre_event_total
    model.mrna[individual] = (zero(Time), false)
    pre_event_total &gt; 0 &amp;&amp; disable!(sampler, (:translate, 0))
    total = count(x -&gt; x[2], model.mrna)
    if total &gt; 0
        transrate1 = Exponential(inv(θ[:translate][1] * total))
        transrate2 = Exponential(inv(θ[:translate][2] * total))
        enable!(sampler, (:translate, 0), [transrate1, transrate2])
    end
end</code></pre><pre><code class="nohighlight hljs">degrade_mrna (generic function with 1 method)</code></pre><p>When translation happens, it isn&#39;t a one-time event. The same event can happen again, so we re-enable it.</p><pre><code class="language-julia hljs">function translate_protein(model, sampler, individual, when, θ)
    pre_event_total = count(x -&gt; x[2], model.mrna)
    model.protein += 1
    if pre_event_total &gt; 0
        transrate1 = Exponential(inv(θ[:translate][1] * pre_event_total))
        transrate2 = Exponential(inv(θ[:translate][2] * pre_event_total))
        enable!(sampler, (:translate, 0), [transrate1, transrate2])
    end
end</code></pre><pre><code class="nohighlight hljs">translate_protein (generic function with 1 method)</code></pre><p>Our central dynamics calls the appropriate function above when its event fires.</p><pre><code class="language-julia hljs">function step_gene!(model, sampler, which, when)
    event, individual = which
    Dict(
        :on =&gt; turn_promoter_on,
        :off =&gt; turn_promoter_off,
        :transcribe =&gt; transcribe_mrna,
        :degrade =&gt; degrade_mrna,
        :translate =&gt; translate_protein,
    )[event](model, sampler, individual, when, model.θ)
end</code></pre><pre><code class="nohighlight hljs">step_gene! (generic function with 1 method)</code></pre><p>The CompetingClocks.jl package does the sampling, but you create the mainloop.</p><pre><code class="language-julia hljs">function one_epoch(model, sampler)
    step_gene!(model, sampler, (:on, 0), time(sampler))
    when, which = next(sampler)
    while !isnothing(which)
        fire!(sampler, which, when)
        step_gene!(model, sampler, which, when)
        when, which = next(sampler)
    end
    basal, weighted = pathloglikelihood(sampler, time(sampler))
    logimportance = basal - weighted
    return (model.protein, logimportance)
end</code></pre><pre><code class="nohighlight hljs">one_epoch (generic function with 1 method)</code></pre><p>This runs the simulation many times with chosen parameters.</p><pre><code class="language-julia hljs">function run_epochs(epoch_cnt, use_importance, rng)
    # We define two sets of parameters. The first biases the simulation towards
    # producing a rare event and the second is the basal rate we use to evaluate
    # the importance of those events.
    params = Dict(
        :promoter_off =&gt; (0.6, 0.2), # per minute
        :transcribe_max =&gt; (10.0, 10.0), # mRNA/min
        :transcribe_remodel =&gt; (1.0, 1.0), # per minute, rate of chromatin opening.
        :degrade_k =&gt; (4.0, 4.0),  # k for Gamma
        :degrade_theta =&gt; (4 * 4 / 30, 4 * 4 / 30), # theta for Gamma
        :translate =&gt; (1.00, 1.05), # proteins/min/mRNA
    )
    protein = zeros(Int, epoch_cnt)
    importance = zeros(Float64, epoch_cnt)
    model = GeneExpression(params)
    builder = SamplerBuilder(
        Tuple{Symbol,Int}, Float64;
        method=FirstToFireMethod(),
        path_likelihood=true,
        likelihood_cnt=2,
    )
    sampler = SamplingContext(builder, rng)
    sample_from_distribution!(sampler, use_importance ? 2 : 1)
    for epoch_idx in eachindex(protein)
        (cnt, weight) = one_epoch(model, sampler)
        protein[epoch_idx] = cnt
        importance[epoch_idx] = weight
        empty!(model)
        reset!(sampler)
    end
    return protein, importance
end
function show_observed(observed)
    bins = 100 * collect(1:10)
    gt_bin = [sum(observed .&gt; bin) for bin in bins]
    for idx in eachindex(bins)
        println(&quot;bin $(bins[idx]) count $(gt_bin[idx])&quot;)
    end
    println(&quot;total $(length(observed))&quot;)
end</code></pre><pre><code class="nohighlight hljs">show_observed (generic function with 1 method)</code></pre><p>Let&#39;s do one run without importance sampling and print the results to see how  often the rare event happens. We&#39;ll see it&#39;s fairly rare.</p><pre><code class="language-julia hljs">with_logger(ConsoleLogger(stdout, Logging.Info)) do
    observed, importance = run_epochs(100, false, Xoshiro(324923))
    show_observed(observed)
end</code></pre><pre><code class="nohighlight hljs">bin 100 count 24
bin 200 count 10
bin 300 count 4
bin 400 count 3
bin 500 count 1
bin 600 count 0
bin 700 count 0
bin 800 count 0
bin 900 count 0
bin 1000 count 0
total 100
</code></pre><p>If we run it ten times with importance sampling, we can see how good the statistics get. I&#39;m keepign the sample count low here because this is just documentation.</p><pre><code class="language-julia hljs">function variations(var_cnt, N)
    prob_over_1000 = zeros(Float64, var_cnt)
    fraction_over = zeros(Float64, var_cnt)
    rng = Xoshiro(234291022)
    for pidx in eachindex(prob_over_1000)
        observed, Δ = run_epochs(N, true, rng)
        # Use log-space trick to avoid summing a bunch of zeros and extremely small numbers.
        importance = exp.(Δ .- maximum(Δ))
        # This is the self-normalized estimator.
        prob_over_1000[pidx] = sum((observed .&gt;= 1000) .* importance) / sum(importance)
        # The unbiased estimator uses 1/N.
        # prob_over_1000[pidx] = sum((observed .&gt;= 1000) .* importance) / N
        fraction_over[pidx] = count(x -&gt; x &gt; 1000, observed) / length(observed)
        println(&quot;mean weight $(mean(importance))&quot;)
        println(&quot;ESS $(sum(importance)^2 / sum(importance.^2))&quot;)
    end
    println(&quot;fraction_over&quot;)
    println(join([@sprintf(&quot;%.2g&quot;, x) for x in fraction_over], &quot;, &quot;))
    println(&quot;probability_over&quot;)
    println(join([@sprintf(&quot;%.2g&quot;, x) for x in prob_over_1000], &quot;, &quot;))
end
variations(10, 1_000)</code></pre><pre><code class="nohighlight hljs">mean weight 0.2566300184812529
ESS 511.9748480113073
mean weight 0.1905958987266816
ESS 506.36275649675315
mean weight 0.11366514004791889
ESS 506.2152568608388
mean weight 0.2133992871985636
ESS 480.309887500895
mean weight 0.16420703346743035
ESS 504.23611641260646
mean weight 0.22494785552831026
ESS 504.70217642446266
mean weight 0.21517063061396302
ESS 484.4704360099825
mean weight 0.22555949607782808
ESS 501.1609987939006
mean weight 0.14096564626827154
ESS 483.00195848975915
mean weight 0.23539199565011704
ESS 503.21950859650894
fraction_over
0.056, 0.061, 0.067, 0.069, 0.066, 0.068, 0.067, 0.076, 0.081, 0.071
probability_over
0.00018, 0.00021, 0.00033, 0.0003, 0.00018, 0.00037, 0.00034, 0.00022, 0.00017, 0.00031
</code></pre><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ul><li>Zong, Chenghang, Lok‐hang So, Leonardo A Sepúlveda, Samuel O Skinner, and Ido Golding. “Lysogen Stability Is Determined by the Frequency of Activity Bursts from the Fate‐determining Gene.” Molecular Systems Biology 6, no. 1 (2010): 440. https://doi.org/10.1038/msb.2010.96.</li><li>Raj, Arjun, and Alexander Van Oudenaarden. “Nature, Nurture, or Chance: Stochastic Gene Expression and Its Consequences.” Cell 135, no. 2 (2008): 216–26. https://doi.org/10.1016/j.cell.2008.09.050.</li><li>Cai, Long, Nir Friedman, and X. Sunney Xie. “Stochastic Protein Expression in Individual Cells at the Single Molecule Level.” Nature 440, no. 7082 (2006): 358–62. https://doi.org/10.1038/nature04599.</li><li>Horowitz, Jordan M, and Rahul V Kulkarni. “Stochastic Gene Expression Conditioned on Large Deviations.” Physical Biology 14, no. 3 (2017): 03LT01. https://doi.org/10.1088/1478-3975/aa6d89.</li><li>McAdams, Harley H., and Adam Arkin. “Stochastic Mechanisms in Gene Expression.” Proceedings of the National Academy of Sciences 94, no. 3 (1997): 814–19. https://doi.org/10.1073/pnas.94.3.814.</li></ul><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../memory/">« Transitions with Memory</a><a class="docs-footer-nextpage" href="../commonrandom/">Common Random Numbers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 28 November 2025 20:25">Friday 28 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
