var documenterSearchIndex = {"docs":
[{"location":"gen/hmc_paths/#HMC-over-Event-Paths-with-Gen.jl","page":"HMC over Event Paths with Gen.jl","title":"HMC over Event Paths with Gen.jl","text":"This guide shows how to perform Hamiltonian Monte Carlo (HMC) inference over event times in a continuous-time discrete-event system (CTDES), integrating CompetingClocks with Gen.jl and ForwardDiff.jl.","category":"section"},{"location":"gen/hmc_paths/#Statistical-Setup","page":"HMC over Event Paths with Gen.jl","title":"Statistical Setup","text":"Consider a CTDES with clock keys k in mathcalK where each enabled clock has a waiting-time distribution F_k(cdot theta). A trajectory is a sequence of events:\n\ntextpath = big((k_1 t_1) (k_2 t_2) ldots (k_M t_M)big) quad 0  t_1  cdots  t_M le T\n\nGiven observed data y derived from the path (e.g., a noisy completion time), the posterior over event times and parameters is:\n\nlog p(theta textpath mid y) = log p_theta(textpath) + log p(y mid textpath theta) + log p(theta) + C\n\nHMC treats the event times as a continuous vector q, introduces momenta p, and simulates Hamiltonian dynamics using gradients nabla_q log p(theta textpath mid y).\n\nTwo integration strategies with Gen.jl:\n\nExternal HMC over event times: Gen handles discrete structure and priors; a separate HMC kernel updates event times.\nGen-native gradients: Wrap the path log-likelihood as a custom Gen distribution with logpdf_grad.\n\nThis guide demonstrates approach (1).","category":"section"},{"location":"gen/hmc_paths/#Example-Model:-Two-Step-Reaction-A-B-C","page":"HMC over Event Paths with Gen.jl","title":"Example Model: Two-Step Reaction A → B → C","text":"A minimal chain reaction:\n\nAt t=0, the system is in state :A\nEvent :ab fires once with textWeibull(k_ab lambda_ab) waiting time\nAfter :ab fires, event :bc is enabled with textWeibull(k_bc lambda_bc) waiting time\nWe observe a noisy completion time y sim mathcalN(t_2 sigma_textobs^2)\n\nThe goal is posterior inference over (t_1 t_2) given y.","category":"section"},{"location":"gen/hmc_paths/#Dependencies","page":"HMC over Event Paths with Gen.jl","title":"Dependencies","text":"using Random\nusing Distributions\nusing CompetingClocks\nusing ForwardDiff\nusing LinearAlgebra\nusing Gen","category":"section"},{"location":"gen/hmc_paths/#Model-Definitions","page":"HMC over Event Paths with Gen.jl","title":"Model Definitions","text":"# Clock key for the two-step reaction\nstruct ABClock\n    kind::Symbol  # :ab or :bc\nend\n\n# Weibull parameters for both transitions\nstruct ABParams{T}\n    k_ab::T\n    lambda_ab::T\n    k_bc::T\n    lambda_bc::T\nend\n\n# Model state\nmutable struct ABModel{T}\n    t::T\n    state::Symbol\n    params::ABParams{T}\nend","category":"section"},{"location":"gen/hmc_paths/#Event-Handling","page":"HMC over Event Paths with Gen.jl","title":"Event Handling","text":"function initialize_ab!(model::ABModel{T}, sampler) where {T}\n    model.t = zero(T)\n    model.state = :A\n    p = model.params\n    enable!(sampler, ABClock(:ab), Weibull(p.k_ab, p.lambda_ab))\n    return nothing\nend\n\nfunction handle_ab_event!(model::ABModel{T}, sampler, which::ABClock, when::T) where {T}\n    model.t = when\n    p = model.params\n\n    if which.kind == :ab\n        model.state = :B\n        enable!(sampler, ABClock(:bc), Weibull(p.k_bc, p.lambda_bc))\n    elseif which.kind == :bc\n        model.state = :C\n    else\n        error(\"Unknown clock kind $(which.kind)\")\n    end\nend","category":"section"},{"location":"gen/hmc_paths/#Path-Log-Likelihood","page":"HMC over Event Paths with Gen.jl","title":"Path Log-Likelihood","text":"For this simple model, the path log-likelihood has a closed form:\n\nlog p(t_1 t_2 mid theta) = log f_ab(t_1) + log f_bc(t_2 - t_1)\n\nwhere f_ab and f_bc are the Weibull densities.\n\nfunction log_path_ab(events::AbstractVector, params::ABParams)\n    @assert length(events) == 2\n    t1 = events[1].time\n    t2 = events[2].time\n\n    dist_ab = Weibull(params.k_ab, params.lambda_ab)\n    dist_bc = Weibull(params.k_bc, params.lambda_bc)\n\n    # Use Distributions.logpdf to avoid ambiguity with Gen.logpdf\n    return Distributions.logpdf(dist_ab, t1) + Distributions.logpdf(dist_bc, t2 - t1)\nend\n\nFor validation, CompetingClocks can compute the same quantity via replay:\n\nfunction log_path_ab_cclock(events::AbstractVector, params::ABParams{Float64})\n    rng = Xoshiro(0)\n    sampler = SamplingContext(ABClock, Float64, rng; path_likelihood=true)\n\n    model = ABModel(0.0, :A, params)\n    initialize_ab!(model, sampler)\n\n    for e in events\n        fire!(sampler, e.evt, Float64(e.time))\n        handle_ab_event!(model, sampler, e.evt, Float64(e.time))\n    end\n\n    return pathloglikelihood(sampler, Float64(events[end].time))\nend\n\nnote: AD Compatibility\nThe TrajectoryWatcher inside SamplingContext currently stores loglikelihood::Float64, which prevents direct use with ForwardDiff dual numbers. For HMC, compute the path log-likelihood manually as shown in log_path_ab.","category":"section"},{"location":"gen/hmc_paths/#Unconstrained-Parameterization","page":"HMC over Event Paths with Gen.jl","title":"Unconstrained Parameterization","text":"To maintain ordered, positive event times during HMC, map unconstrained u in mathbbR^2 to times:\n\nt_1 = e^u_1 quad t_2 = t_1 + e^u_2\n\nwith log-Jacobian log J = u_1 + u_2.\n\nfunction times_from_u(u::AbstractVector)\n    @assert length(u) == 2\n    t1 = exp(u[1])\n    dt = exp(u[2])\n    t2 = t1 + dt\n    logjac = u[1] + u[2]\n    return (t1, t2, logjac)\nend","category":"section"},{"location":"gen/hmc_paths/#Log-Posterior","page":"HMC over Event Paths with Gen.jl","title":"Log Posterior","text":"function logpost_u(u::AbstractVector, params::ABParams, y_obs::Float64, sigma_obs::Float64)\n    t1, t2, logjac = times_from_u(u)\n\n    events = [\n        (evt=ABClock(:ab), time=t1),\n        (evt=ABClock(:bc), time=t2)\n    ]\n\n    lp_path = log_path_ab(events, params)\n    lp_obs = Distributions.logpdf(Normal(t2, sigma_obs), y_obs)\n\n    return lp_path + lp_obs + logjac\nend\n\n# Callable wrapper for ForwardDiff\nstruct PosteriorWrapper\n    params::ABParams{Float64}\n    y_obs::Float64\n    sigma_obs::Float64\nend\n\n(pw::PosteriorWrapper)(u) = logpost_u(u, pw.params, pw.y_obs, pw.sigma_obs)","category":"section"},{"location":"gen/hmc_paths/#HMC-Implementation","page":"HMC over Event Paths with Gen.jl","title":"HMC Implementation","text":"A basic leapfrog integrator with Metropolis accept/reject:\n\nfunction hmc_step(u_current::Vector{Float64}, logpost; epsilon::Float64=0.02, L::Int=10)\n    q = copy(u_current)\n    p = randn(length(q))\n    current_p = copy(p)\n\n    grad_logpost(x) = ForwardDiff.gradient(logpost, x)\n\n    # Leapfrog integration\n    grad = grad_logpost(q)\n    p .+= (epsilon / 2.0) .* grad\n\n    for l in 1:L\n        q .+= epsilon .* p\n        grad = grad_logpost(q)\n        if l != L\n            p .+= epsilon .* grad\n        end\n    end\n\n    p .+= (epsilon / 2.0) .* grad\n    p .= -p\n\n    # Metropolis accept/reject\n    H(q, p) = -logpost(q) + 0.5 * dot(p, p)\n    current_H = H(u_current, current_p)\n    proposed_H = H(q, p)\n\n    if log(rand()) < current_H - proposed_H\n        return q, true\n    else\n        return u_current, false\n    end\nend","category":"section"},{"location":"gen/hmc_paths/#Running-HMC","page":"HMC over Event Paths with Gen.jl","title":"Running HMC","text":"function demo_hmc()\n    true_params = ABParams(1.5, 3.0, 2.0, 1.5)\n\n    # Generate synthetic data\n    rng = MersenneTwister(42)\n    t1_true = rand(rng, Weibull(true_params.k_ab, true_params.lambda_ab))\n    t2_true = t1_true + rand(rng, Weibull(true_params.k_bc, true_params.lambda_bc))\n    sigma_obs = 0.1\n    y_obs = rand(rng, Normal(t2_true, sigma_obs))\n\n    pw = PosteriorWrapper(true_params, y_obs, sigma_obs)\n    u = [log(0.5 * y_obs), log(0.5 * y_obs)]\n\n    samples = Vector{Vector{Float64}}()\n    acc = 0\n    n_iter = 500\n\n    for iter in 1:n_iter\n        u, accepted = hmc_step(u, pw; epsilon=0.01, L=20)\n        acc += accepted ? 1 : 0\n        push!(samples, copy(u))\n    end\n\n    # Posterior summary\n    burn_in = 100\n    t1_samples = [times_from_u(s)[1] for s in samples[burn_in+1:end]]\n    t2_samples = [times_from_u(s)[2] for s in samples[burn_in+1:end]]\n\n    println(\"Acceptance rate: $(acc / n_iter)\")\n    println(\"Posterior mean t1: $(mean(t1_samples)) (true: $t1_true)\")\n    println(\"Posterior mean t2: $(mean(t2_samples)) (true: $t2_true)\")\n\n    return samples\nend","category":"section"},{"location":"gen/hmc_paths/#Gen.jl-Integration","page":"HMC over Event Paths with Gen.jl","title":"Gen.jl Integration","text":"To infer model parameters theta while marginalizing over event times, use HMC as an inner loop within Gen's inference framework.","category":"section"},{"location":"gen/hmc_paths/#Factor-Distribution","page":"HMC over Event Paths with Gen.jl","title":"Factor Distribution","text":"Gen.jl doesn't export a factor function for adding log-weights. Define a custom distribution:\n\nstruct FactorDist <: Gen.Distribution{Nothing} end\nconst factor_dist = FactorDist()\n\nGen.random(::FactorDist, logweight::Float64) = nothing\nGen.logpdf(::FactorDist, ::Nothing, logweight::Float64) = logweight\nGen.is_discrete(::FactorDist) = true\nGen.has_output_grad(::FactorDist) = false\nGen.has_argument_grads(::FactorDist) = (false,)","category":"section"},{"location":"gen/hmc_paths/#Approximate-Marginal-Likelihood","page":"HMC over Event Paths with Gen.jl","title":"Approximate Marginal Likelihood","text":"Use a short HMC run to approximate log p(y mid theta):\n\nfunction loglik_given_params(params::ABParams, y_obs::Float64, sigma_obs::Float64)\n    pw = PosteriorWrapper(params, y_obs, sigma_obs)\n    u = [log(0.5 * y_obs), log(0.5 * y_obs)]\n\n    for _ in 1:50\n        u, _ = hmc_step(u, pw; epsilon=0.01, L=10)\n    end\n\n    return pw(u)\nend","category":"section"},{"location":"gen/hmc_paths/#Gen-Model","page":"HMC over Event Paths with Gen.jl","title":"Gen Model","text":"@gen function ab_params_model()\n    delta_k_ab = @trace(normal(0.0, 0.1), :delta_k_ab)\n    delta_lambda_ab = @trace(normal(0.0, 0.1), :delta_lambda_ab)\n    delta_k_bc = @trace(normal(0.0, 0.1), :delta_k_bc)\n    delta_lambda_bc = @trace(normal(0.0, 0.1), :delta_lambda_bc)\n\n    base = ABParams(1.5, 3.0, 2.0, 1.5)\n    return ABParams(\n        base.k_ab + delta_k_ab,\n        base.lambda_ab + delta_lambda_ab,\n        base.k_bc + delta_k_bc,\n        base.lambda_bc + delta_lambda_bc\n    )\nend\n\n@gen function joint_model(y_obs::Float64, sigma_obs::Float64)\n    params = @trace(ab_params_model(), :params)\n    lp_y = loglik_given_params(params, y_obs, sigma_obs)\n    @trace(factor_dist(lp_y), :factor)\n    return params\nend","category":"section"},{"location":"gen/hmc_paths/#MCMC-over-Parameters","page":"HMC over Event Paths with Gen.jl","title":"MCMC over Parameters","text":"function run_gen_with_hmc(y_obs, sigma_obs)\n    tr, _ = generate(joint_model, (y_obs, sigma_obs))\n\n    @gen function proposal_kernel(tr)\n        {:params => :delta_k_ab} ~ normal(tr[:params => :delta_k_ab], 0.05)\n        {:params => :delta_lambda_ab} ~ normal(tr[:params => :delta_lambda_ab], 0.05)\n        {:params => :delta_k_bc} ~ normal(tr[:params => :delta_k_bc], 0.05)\n        {:params => :delta_lambda_bc} ~ normal(tr[:params => :delta_lambda_bc], 0.05)\n        return nothing\n    end\n\n    n_steps = 100\n    for i in 1:n_steps\n        tr, _ = Gen.mh(tr, proposal_kernel, ())\n    end\n\n    return tr\nend","category":"section"},{"location":"gen/hmc_paths/#Summary","page":"HMC over Event Paths with Gen.jl","title":"Summary","text":"This approach combines:\n\nCompetingClocks for defining the CTDES and computing path log-likelihoods\nForwardDiff for gradients through the log-posterior\nHMC for efficient sampling of continuous event times\nGen.jl for probabilistic programming over parameters\n\nThe key constraint is that path log-likelihood computation must be AD-compatible. For simple models, compute it analytically. For complex models, consider modifying CompetingClocks' TrajectoryWatcher to support generic numeric types.","category":"section"},{"location":"gen/hmc_paths/#Full-Example","page":"HMC over Event Paths with Gen.jl","title":"Full Example","text":"See examples/gen_hmc.jl for a complete, runnable version.","category":"section"},{"location":"hierarchical/#Hierarchical-Samplers","page":"Hierarchical Samplers","title":"Hierarchical Samplers","text":"","category":"section"},{"location":"hierarchical/#Overview","page":"Hierarchical Samplers","title":"Overview","text":"Continuous-time samplers have to process each event separately. As simulations grow in size, samplers use more memory, and they take more time to select the next event. One approach to speed up sampling is to use multiple samplers arranged in a hierarchy.","category":"section"},{"location":"hierarchical/#Why-Hierarchical-Samplers","page":"Hierarchical Samplers","title":"Why Hierarchical Samplers","text":"There are two reasons to use hierarchical samplers.\n\nSome samplers are better for some simulations. If all transitions are Exponentially-distributed, then an optimized Direct sampler can be the fastest. If all of the distributions are of Exponential families, then Anderson's method is faster than the Next Reaction method. You can split the events among samplers according to the sampler that best fits the behavior of those events.\n\nThe other reason to use multiple samplers has to do with the frequency and locality of the events, in the same way we think of the frequency and locality of memory accesses for cache use. If there is a small subset of events that regenerate frequently, it can make sense even to use a FirstReaction sampler for those events. While FirstReaction doesn't use a complicated data structure to optimize, it can be winningly fast for small numbers of events. Or, for a spatial simulation, you could make separate samplers for separate parts of the landscape, so that each event tends to affect a limited number of samplers.","category":"section"},{"location":"hierarchical/#First-Sampler-to-Fire","page":"Hierarchical Samplers","title":"First Sampler to Fire","text":"All of the different samplers find the first event to fire. If we set up two samplers, so that each holds mutually distinct enabled event distributions, we can ask each sampler which it thinks will fire next. The first to fire is the first of the two samplers. This generalizes to any number of samplers. We can make a MultiSampler which contains multiple samplers and always returns the soonest of those contained.\n\nEven further a MultiSampler can contain a MultiSampler if that makes sense.","category":"section"},{"location":"hierarchical/#Multiple-Direct-Samplers","page":"Hierarchical Samplers","title":"Multiple Direct Samplers","text":"It's possible to make a Direct-style sampler that is hierarchical, too. A Direct sampler works in two steps. It sums the hazards of all enabled events and then selects a time according to the sum of the hazards. The main algorithm of a Direct sampler is to sum hazards. A hierarchical Direct algorithm sums the sums of the hazards and then selects a time.\n\nWhile hierarchical samplers can contain multiple-Direct samplers, multiple-Direct samplers can only contain other multiple-Direct samplers.","category":"section"},{"location":"hierarchical/#How-to-Split-a-Simulation","page":"Hierarchical Samplers","title":"How to Split a Simulation","text":"Each time a simulation calls enable! and disable! for an event, it specifies a key for that event. If the sampler is hierarchical, it can use that key, and maybe the type of the distribution, to choose which sampler handles any given event.\n\nCompetingClocks's approach in the MultiSampler type is to let the user specify a function that takes as input the key and the distribution and returns some ID for the chosen sampler. The MultiSampler then remembers that choice for this event key, from that point on.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"importance_skills/#Importance-Sampling-for-Simulation","page":"Importance Sampling for Simulation","title":"Importance Sampling for Simulation","text":"Importance sampling is a way to steer a simulation towards simulating the conditions you most care about. The simplest importance sampling is to wait until a simulation gets near a state of interest and then CompetingClocks.split! the simulation into multiple copies that can better explore that state. The technique can be more powerful with the use of likelihoods, as described below.","category":"section"},{"location":"importance_skills/#The-Process","page":"Importance Sampling for Simulation","title":"The Process","text":"When you apply importance sampling in simulation, the workflow feels like this:\n\nBaseline run: Simulate under the desired distributions, p(x). If the event is rare, it might not ever happen in your simulations or might happen too few times to get good statistics on it.\nBias intuition: Identify which physical parameters or transitions make the event unlikely (e.g., promoter turns off too soon). Modify those rates to define q(x). Try to pick rates that happen once or twice in the simulation, and start with gentle bias.\nRun biased simulations: Under q, the rare event occurs more often.\nCompute path likelihoods: Using both the biased and true rates, form w = p(x)q(x) for each path.\nReweight results: Estimate probabilities or expectations with the weighted average.\nDiagnose: Check the mean and variance of weights, or compute ESS. If weights vary over many orders of magnitude, adjust q to reduce the gap.\nIterate: Gradually refine the proposal until ESS stabilizes and probability estimates converge.\n\nThe main problem is that too large of bias on distributions can lead to mathematical underflow in calculation of the weights. Intuitively, a stochastic simulation can have a lot of individual sampled events, and each event's probability multiplies to get the probability of a path of samples in a trajectory. If those samples are repeatedly biased, they can cause numbers that are too small to represent.\n\nw = fracL(lambda_texttarget)L(lambda_textproposal)\n = left(fraclambda_texttargetlambda_textproposalright)^N\ne^-(lambda_texttarget - lambda_textproposal)T\n\nWhat you'll see in practice is that the initial simulation, under p, works fine, that a small change in a distribution's parameters still works fine, and then the importance-weighted estimates fall off a cliff and show values like 10^-73.\n\nIf distributions are scaled, the mean weight can be much less than one. A mean weight that isn't small is a good sign. We want a sense of the ratio of w=pq the ratio of weights.","category":"section"},{"location":"importance_skills/#Evaluate-proposal-quality","page":"Importance Sampling for Simulation","title":"Evaluate proposal quality","text":"","category":"section"},{"location":"importance_skills/#Track-how-ESS-scales-with-N","page":"Importance Sampling for Simulation","title":"Track how ESS scales with N","text":"# Stable log-sum-exp\nfunction logsumexp(x)\n    m = maximum(x)\n    return m + log(sum(exp.(x .- m)))\nend\n\n# Estimate E_q[w] = 1 using the *unshifted* Δ (i.e., don't subtract max here)\n# log mean weight = log( (1/N) * sum(exp(Δ)) )\nlog_mean_w = logsumexp(Δ) - log(length(Δ))\nmean_w_est = exp(log_mean_w)\nprintln(\"E_q[w] (should be ~1): \", mean_w_est)\n\n# For self-normalized IS you don’t need this, but it’s a nice sanity check.\n\nprintln(\"mean weight ≈ \", mean_w_est)\nw = exp.(Δ)                  # unshifted\n# normalize stably:\nZ_log = logsumexp(Δ)\nwn = exp.(Δ .- Z_log)        # now sum(wn) = 1\nESS_norm = 1 / sum(wn.^2)    # between 1 and N\n# Close to (sum(importance)^2) / sum(importance.^2)\nprintln(\"ESS (normalized): \", ESS_norm)\n\nESS is explained sum of squares. You're looking for this to be a significant fraction of N the number of trajectories.\n\nIf it stops growing linearly with N, your proposal is too far from the target.","category":"section"},{"location":"importance_skills/#Use-the-coefficient-of-variation-of-weights-to-see-where-variance-explodes.","page":"Importance Sampling for Simulation","title":"Use the coefficient of variation of weights to see where variance explodes.","text":"textCV^2 = fractextVar(w)Ew^2 = fracNtextESS - 1\n\nCoefficient of variation is a reparametrization of ESS.","category":"section"},{"location":"importance_skills/#Make-a-weight-histogram","page":"Importance Sampling for Simulation","title":"Make a weight histogram","text":"Plot log of the weight, log_10(w) or log(wtextmean(w)). You want a unimodal, not-too-wide shape. Heavy-tailed distributions indicate you're close to degeneracy.","category":"section"},{"location":"importance_skills/#Proposal-Improvement","page":"Importance Sampling for Simulation","title":"Proposal Improvement","text":"","category":"section"},{"location":"importance_skills/#Mixture-proposals","page":"Importance Sampling for Simulation","title":"Mixture proposals","text":"Instead of one biased model, use a mixture of proposals. This helps if different regions of state space are rare for different reasons. For the gene example, maybe one proposal distribution keeps the promoter on longer and another emphasizes instead reducing degradation of MRNA. You would make one set of distribution parameters for each case and run your simulation where each set of distribution parameters is used a fraction alpha_i of the time.\n\nq(x) = sum_i alpha_i q_i(x)\n\nUsing a mixture of weights is a way to hedge your bets on what about the simulation is causing the outcome to be rare. It does something subtle to the importance calculation because the weight is with respect to the mixture density.\n\nw_i = fracp(x_i)sum_k=1^K alpha_k q_k(x_i)\n\nIn log-space, we would use log-sum-exp.\n\nlog w_i = log p(x_i) - logleft(sum_kalpha_k q_k(x_i)right) = log p(x_i) - textlogsumexp_k(log alpha_k+log q_k(x_i))\n\nLet's say we have three proposal distributions from which we sample evenly, so alpha=13 13 13. We run each simulation where for each enabling of a clock we pass in a vector of four (4) distributions. The first is the proposal distribution we want to use to generate events for this run. The next three are the actual distribution p and the other proposal distributions.\n\nusing StatsFuns: logsumexp\nlog_qmix = logsumexp(log.(α) .+ [log_q1, log_q2, log_q3])\nlog_weight = log_p - log_qmix\nw = exp(log_weight)","category":"section"},{"location":"importance_skills/#Adaptive-importance-sampling-(AIS)","page":"Importance Sampling for Simulation","title":"Adaptive importance sampling (AIS)","text":"Iteratively refit your proposal to minimize weight variance. A typical loop:\n\nRun IS with current proposal.\nReweight samples to estimate sufficient statistics.\nFit a new proposal (e.g. update rate multipliers or shift parameters) using the weighted MLE under the target.\n\nFor instance, this could mean adjusting each event's bias factor until the log-weight variance stops decreasing.","category":"section"},{"location":"importance_skills/#Cross-entropy-(CE)-method","page":"Importance Sampling for Simulation","title":"Cross-entropy (CE) method","text":"This structured version of adaptive importance sampling runs the simulation multiple times. You let it tell you the optimal choice of parameters to reduce variance in your estimate of the rare event. One each run, you choose bias parameters theta to minimize the Kullback-Liebler.\n\ntextKL(p^*q_theta)\n\nHere p^* is the conditional distribution on the rare event.\n\nIt helps to use common random numbers. Using mixtures is just fine with this method, and you can select among the mixture proposals. As in other cases, the self-normalized estimator is more robust than the unbiased estimator.\n\nP.-T. de Boer, D. P. Kroese, S. Mannor, and R. Y. Rubinstein. “A Tutorial on the Cross‑Entropy Method.” Annals of Operations Research 134 (2005): 19–67.\nR. Y. Rubinstein. “The Cross‑Entropy Method for Combinatorial and Continuous Optimization.” Methodology and Computing in Applied Probability 1, no. 2 (1999): 127–190.\nR. Y. Rubinstein and D. P. Kroese. The Cross‑Entropy Method: A Unified Approach to Combinatorial Optimization, Monte‑Carlo Simulation and Machine Learning. Springer, 2004.","category":"section"},{"location":"importance_skills/#Variance-reduction-companions","page":"Importance Sampling for Simulation","title":"Variance-reduction companions","text":"","category":"section"},{"location":"importance_skills/#Self-normalized-Estimator","page":"Importance Sampling for Simulation","title":"Self-normalized Estimator","text":"Try the self-normalized estimator.\n\nsum_i=1^N mathcalI(x_i0) w_i  sum_i w_i\n\nThe standard estimator.\n\nsum_i=1^N mathcalI(x_i0) w_i  N","category":"section"},{"location":"importance_skills/#Control-variates","page":"Importance Sampling for Simulation","title":"Control variates","text":"If you know some part of the model's behavior exactly (like average promoter activity in our example), then you can leverage it to stabilize the estimate of what you don't know, the rare event probability. The part you know is a correlated statistic, h(x), and what you need to know about it is its expectation, E_ph. Then you can add this into the total expectation without biasing the final estimate.\n\nhatmu=sum_i w_i(f(x_i)-c(h(x_i)-E_ph))\n\nA good choice of control variate has a strong linear correlation with your outcome, such as producing a lot of proteins in our example. It has a known, or easy-to-calculate, expected value. It doesn't have wild swings itself which could amplify noise rather than decrease it.\n\nThis technique is often overlooked and can be powerful.","category":"section"},{"location":"importance_skills/#Stratified-or-quasi-Monte-Carlo-sampling","page":"Importance Sampling for Simulation","title":"Stratified or quasi-Monte-Carlo sampling","text":"For path-space simulations, you can stratify on states or numbers of events in the chain, ensuring balanced exploration. In Julia, you can use QuasiMonteCarlo.jl to drive RNGs for low-discrepancy trajectories.","category":"section"},{"location":"importance_skills/#Nested-or-multi-level-Importance-Sampling","page":"Importance Sampling for Simulation","title":"Nested or multi-level Importance Sampling","text":"For instance, here we are looking for P(X1000), so split.\n\nP(X1000) = P(X100)P(X300X100)P(X600X300)cdots\n\nThis splitting / multilevel approach drastically cuts variance for ultra-rare events.","category":"section"},{"location":"importance_skills/#Numerical-and-stability-tools","page":"Importance Sampling for Simulation","title":"Numerical and stability tools","text":"","category":"section"},{"location":"importance_skills/#Log-sum-exp-normalization","page":"Importance Sampling for Simulation","title":"Log-sum-exp normalization","text":"Use this for any aggregate quantity that involves exp/log across samples.\n\nDo the log-space trick. Just like log-sum-exp in machine learning. Underflow is a problem. exp(-700) is small enough to underflow.\n\nfrace^Delta_isum_j e^Delta_j = frace^Delta_i-textmax(Delta)sum_j e^Delta_j-textmax(Delta)\n\nThis makes the probabilities or expectations identical but improves numerical stability.\n\nΔ = basal - weighted\nΔ = Δ .- maximum(Δ)  # stabilize if you ever aggregate multiple paths at once\nimportance = exp.(Δ)","category":"section"},{"location":"importance_skills/#Log-domain-accumulation","page":"Importance Sampling for Simulation","title":"Log-domain accumulation","text":"Keep any running-sums of log-likelihoods with log-add-exp rather than exp-sum-log.","category":"section"},{"location":"importance_skills/#Outlier-clipping","page":"Importance Sampling for Simulation","title":"Outlier clipping","text":"In diagnostics (not in the final estimator), cap extermely large weights (say top 0.1%) are recompute ESS. If the estimate hardly changes, your results are stable.","category":"section"},{"location":"importance_skills/#Interpretability-and-sanity-checks","page":"Importance Sampling for Simulation","title":"Interpretability and sanity checks","text":"","category":"section"},{"location":"importance_skills/#Check-expected-weight","page":"Importance Sampling for Simulation","title":"Check expected weight","text":"Use log-sum-exp to check that E_qwapprox 1.","category":"section"},{"location":"importance_skills/#Check-relative-contribution","page":"Importance Sampling for Simulation","title":"Check relative contribution","text":"Compute w_isum_j w_j for top samples. If a handful contribute over 50% of the total weight, you're in a weight collapse regime.","category":"section"},{"location":"importance_skills/#Compare-multiple-bias-directions","page":"Importance Sampling for Simulation","title":"Compare multiple bias directions","text":"Run several small-bias proposals and look for constistent rare-event probability estimates. If results differ wildly, your current proposals are too aggressive.","category":"section"},{"location":"importance_skills/#For-GSMP-specific-models","page":"Importance Sampling for Simulation","title":"For GSMP-specific models","text":"Here each event type has a known distribution, so you can\n\nbias only a subset of clocks.\nconditionally reweight partial paths as soon as one rare component occurs. This can reduce full-path variance.","category":"section"},{"location":"gen/overview/#Gen.jl-and-CompetingClocks.jl","page":"Gen.jl and CompetingClocks.jl","title":"Gen.jl and CompetingClocks.jl","text":"From Gen's point of view, there are two main “hooks” CompetingClocks.jl can plug into:\n\nprobability distributions (Distribution{T} with random/logpdf), and\ngenerative functions (things that implement the Generative Function Interface and produce traces with scores). ([Gen][1])\n\nCompetingClocks already the operations Gen needs: forward simulation of event paths, and step‑ or path‑wise log‑likelihoods.\n\nBelow is an overview of the main integration modes.\n\n","category":"section"},{"location":"gen/overview/#1.-CompetingClocks-as-a-Gen-distribution-over-event-paths","page":"Gen.jl and CompetingClocks.jl","title":"1. CompetingClocks as a Gen distribution over event paths","text":"","category":"section"},{"location":"gen/overview/#What-CompetingClocks-gives-you","page":"Gen.jl and CompetingClocks.jl","title":"What CompetingClocks gives you","text":"Relevant features:\n\nA SamplingContext/SamplerBuilder where you can turn on\nstep_likelihood=true (for steploglikelihood) and/or\npath_likelihood=true (for pathloglikelihood), optionally with likelihood_cnt for multiple distributions / IS.\nTrajectoryWatcher and PathLikelihoods objects that do not sample but compute the log‑likelihood of a full path of (event, time) pairs. \nAn integration pattern where you replay a sequence of events and call pathloglikelihood(sampler, end_time) to get the log probability of that entire trajectory.\n\nThis is exactly what Gen’s distribution API wants as random (sampling a path) and logpdf (log‑likelihood of a path). ([Gen][1])","category":"section"},{"location":"gen/overview/#How-this-looks-conceptually-in-Gen","page":"Gen.jl and CompetingClocks.jl","title":"How this looks conceptually in Gen","text":"Define a concrete Julia type for a path, e.g. a vector of records (time, clock_key) where clock_key is whatever you already use.\nImplement a custom Distribution{PathType} (e.g., GsmpPath) for Gen:\nrandom(::GsmpPath, params, T, rng)\nBuild a SamplingContext with path_likelihood=true.\nRun your usual integration loop (initialize_events!, next, fire!, handle_event!) up to horizon T, collecting (time, key) into a path.\nReturn that path.\nlogpdf(::GsmpPath, path, params, T)\nRebuild the same sampler, but now replay the given path (possibly using TrajectoryWatcher/PathLikelihoods instead of a sampler).\nAfter replay, return pathloglikelihood(sampler_or_watcher, T), which is a Float64 when likelihood_cnt == 1.\nIn a Gen model you then treat the whole continuous‑time trajectory as one random choice:\nAs a latent path:\npath ~ gsmp_path(params, T) inside an @gen function.\nAs an observed path:\nUse generate(model, (params, T), choicemap((:path, observed_path))); Gen will call your logpdf to score that trace. ([Gen][1])\n\nOnce you do this, all Gen inference methods that operate on generative functions calling distributions—importance sampling, SMC, generic MH, etc.—can work with your GSMP path as just another random variable. ([Gen][1])\n\n","category":"section"},{"location":"gen/overview/#2.-CompetingClocks-as-a-custom-Generative-Function","page":"Gen.jl and CompetingClocks.jl","title":"2. CompetingClocks as a custom Generative Function","text":"If you want finer control over the trace (addressable choices per event, incremental updates, gradient hooks), you can wrap CompetingClocks as a full Gen generative function rather than just a single distribution. ([Gen][2])","category":"section"},{"location":"gen/overview/#Core-idea","page":"Gen.jl and CompetingClocks.jl","title":"Core idea","text":"Gen’s generative function should:\n\ntake simulation parameters and possibly a time horizon as arguments,\ninternally run that loop using a SamplingContext,\nconstruct a trace whose choice map encodes the discrete events and/or times,\nset its score to the path log‑likelihood from CompetingClocks.\n\nKey points:\n\nTrace structure and addresses\nGen allows arbitrary address types (not just symbols), and your doc explicitly suggests using a Pair key like :i => 37 “for use with Gen.jl”. \nYou can align your CompetingClocks clock keys with Gen trace addresses directly:\ne.g. event key ClockKey(:infect, i, j) maps to Gen address (:infect, i, j) or to the suggested :infect => i / similar scheme.\nThe generative function’s get_choices(trace) then gives a choice map whose addresses are your event identifiers. ([Gen][3])\nImplementing the Generative Function Interface\nAt minimum you implement:\nsimulate: build the SamplingContext (with path_likelihood=true), run the main loop, record events into the trace, and store pathloglikelihood as the trace score.\nget_args, get_retval (e.g. the final state or full path), get_choices, get_score. ([Gen][2])\nIf you want full use of Gen’s MCMC/SMC:\nadd generate (to create traces that satisfy constraints on some events/times),\nupdate/regenerate (for efficient incremental proposals that adjust only part of the path),\noptionally choice_gradients and accumulate_param_gradients! if you expose derivatives of the path log‑likelihood w.r.t. parameters or event times. ([Gen][2])\nWhen this is attractive\nYou want to expose internal events as addressable random choices for custom proposals.\nYou need incremental updates of long trajectories inside MCMC (rather than resimulating whole paths).\nYou want Gen’s gradient‑based machinery to see through to your likelihood (after you supply logpdf_grad/choice_gradients). ([Gen][4])\n\n","category":"section"},{"location":"gen/overview/#3.-Using-CompetingClocks-as-a-likelihood-engine-inside-Gen-inference","page":"Gen.jl and CompetingClocks.jl","title":"3. Using CompetingClocks as a likelihood engine inside Gen inference","text":"Even without fully wrapping your simulator as a distribution or generative function, Gen inference code can delegate likelihood calculations to CompetingClocks.","category":"section"},{"location":"gen/overview/#a)-Observation-likelihood-for-event-data","page":"Gen.jl and CompetingClocks.jl","title":"a) Observation likelihood for event data","text":"Given observed event times/types:\n\nRepresent the data as a list of (clock_key, time) events.\nBuild a TrajectoryWatcher or a sampler created with path_likelihood=true and likelihood_cnt=1.\nIn a Gen model, after sampling parameters, call a pure Julia function that:\nreplays the observed sequence into the watcher/sampler, and\nreturns log_prob = pathloglikelihood(watcher_or_sampler, end_time).\n\nThe clean way to plug this into Gen is still via a custom distribution or generative function whose logpdf / get_score calls this function. That keeps the likelihood inside Gen’s bookkeeping, so all standard inference algorithms see the correct score. ([Gen][4])","category":"section"},{"location":"gen/overview/#b)-Importance-sampling-and-mixture-proposals","page":"Gen.jl and CompetingClocks.jl","title":"b) Importance sampling and mixture proposals","text":"We have already seen importance sampling with CompetingClocks.\n\nWithin Gen:\n\nA custom inference procedure (e.g. an SMC or MH kernel) can:\ndraw candidate paths using a biased CompetingClocks sampler,\nuse PathLikelihoods to evaluate both the target and proposal path log‑likelihoods,\ncompute importance weights or Metropolis–Hastings acceptance ratios, and\nattach the resulting weight as the trace score (or as an incremental factor inside a custom generative function).\n\nThis lets you reuse your variance‑reduction machinery (common random numbers, mixtures, control variates) inside Gen’s programmable inference.","category":"section"},{"location":"gen/overview/#c)-HMC/gradient‑based-parameter-inference","page":"Gen.jl and CompetingClocks.jl","title":"c) HMC/gradient‑based parameter inference","text":"Two ways this interacts with Gen:\n\nExternal HMC over latent event times, Gen for everything else\nUse your HMC driver to update a latent event list given parameters.\nWrap that event list as a variable in a Gen model (e.g. through a distribution over paths).\nCombine Gen’s inference for other latent variables/parameters with your HMC over the CTDES part.\nGen‑native gradients\nBecause pathloglikelihood is ordinary Julia code, it can in principle be differentiated using AD; Gen’s distribution and generative‑function APIs have hooks (logpdf_grad, choice_gradients) to expose these gradients to its optimizers and variational methods. ([Gen][4])\n\n","category":"section"},{"location":"gen/overview/#Summary","page":"Gen.jl and CompetingClocks.jl","title":"Summary","text":"At a high level, the main interaction patterns are:\n\nCustom Gen distribution over GSMP paths, with random and logpdf implemented via CompetingClocks simulation and pathloglikelihood.\nCustom Gen generative function that internally runs your simulation, uses your key types as Gen addresses, and sets its score from your path likelihood.\nUse of CompetingClocks as a likelihood / weighting engine in Gen inference code: observation likelihoods for event data, importance‑sampling/mixture proposals (with PathLikelihoods and CRNs), and HMC‑style gradient‑based updates driven by pathloglikelihood.\n\nAll three rely on the same core feature set you already built: configurable samplers/contexts, step‑ and path‑wise log‑likelihoods, watchers, and importance‑sampling tools.","category":"section"},{"location":"gen/overview/#References","page":"Gen.jl and CompetingClocks.jl","title":"References","text":"https://www.gen.dev/docs/stable/ref/modeling/distributions/ \"Probability Distributions · Gen.jl\"\nhttps://www.gen.dev/docs/stable/howto/customgen_fns/ \"Adding New Generative Functions · Gen.jl\"\nhttps://www.gen.dev/docs/stable/ref/core/gfi/ \"Generative Function Interface · Gen.jl\"\nhttps://www.gen.dev/docs/dev/howto/customdistributions/ \"Adding New Distributions · Gen.jl\"","category":"section"},{"location":"develop/#Design","page":"Design","title":"Design","text":"The scope of this is that I want to make a continuous-time simulation that is rooted in stochastic processes and as fast as they can be. The state will be the simplest, a vector of integers. Transitions, however, can be non-Exponential distributions. I'd like to exercise all of the top sampling methods. This code asks how to set up a best-practices continuous-time simulation in Julia. The fastest method for sampling is to use a hierarchical setup, where different sets of transitions get the samplers that are most efficient for their distributions.\n\nThe main research question is how to hook the state and transitions of the stochastic process to the sampler algorithm. The mathematical work I've seen does sometimes discuss hierarchical sampling, but it doesn't discuss algorithms for how best to connect a transition with its appropriate sampler. How do we specify it that connection? There's nothing in the math about distributions having a name or an indexing key.\n\nWhile we normally simulate, there are some other ways to use simulation code, and those other ways give a clue about how to separate functions.\n\nFire transitions in a given order without sampling them. Work through a trace.\nConstruct a state by specifying an initial state and sequence of transitions.\nMeasure likelihood of a state without sampling. This is used for MCMC.","category":"section"},{"location":"develop/#Vector-addition-systems","page":"Design","title":"Vector addition systems","text":"A vector addition system (VAS) defines the state as a vector of non-negative integers. Transitions are two matrices of shape (transition x state). One indicates how large the state vector has to be for that transition to be enabled. Together, they define values removed and added to the state vector when a transition fires.\n\nIn practice, vector addition systems aren't implemented with vectors. The professional versions are defined on bipartite graphs where the state is one node type and transitions are the other node type.","category":"section"},{"location":"develop/#Semi-Markov-Vector-Addition-System","page":"Design","title":"Semi-Markov Vector Addition System","text":"We'll make one little change to the VAS. Instead of having only exponential distributions, it can have general distribution types. That adds complexity to the sampler, but the samplers will handle that. For the VAS, it adds some state and adds burden to specification. The state now needs to track the time at which each transition was enabled, known as t_e. We'll call the main part of the state its physical state, which is the vector of integers in this case.\n\nIn order to specify a Markov VAS, you need to give a rate for each transition. A chemical simulation has a very particular function to determine the rate of transitions. For chemicals, the rate is a function of the number of possible combinations of the chemicals. For a Semi-Markov VAS, which we're making, we'll let the state be any function of the state of the system.\n\nThere's one other wrinkle to specifying a Semi-Markov VAS. The Zimmerman simulation book points out that non-Exponential transitions can have memory or be memoryless. He means that, if a transition is enabled and disabled, we need to decide whether that affects its rate the next time it's enabled. If the transition were emptying a bathtub, and we put in the stopper plug, then taking out that plug depends on the previous enabling. It must have memory. If it were the time a robot needs to put a gas cap on an assmebly-line car, it would need to begin from scratch during a restart.","category":"section"},{"location":"develop/#Core-responsibilities","page":"Design","title":"Core responsibilities","text":"The state of the system is dictated by stochastic processes theory: a. Physical state, which can be a vector of integers for this version. b. Enabling times. This is the time at which each transition was, or wasn't enabled. c. The last time any transition fired.\nSampling depends only on distributions, not any other information about each transition. All optimized samplers keep a cache of the distributions of enabled transitions and modify that cache with each firing.","category":"section"},{"location":"develop/#Sampling","page":"Design","title":"Sampling","text":"Most samplers optimize their work by tracking what transitions were last enabled. They treat newly-enabled and newly-disabled transitions as a modification to the likelihood of the next sample. Some samplers don't store any state. First-reaction method is this way, as is the original Direct method. These are naive samplers, and I don't think it's worth optimizing for them. I would, instead, assume that all samplers track which transitions were last enabled. I'll add that as a layer on the first-reaction and direct methods.","category":"section"},{"location":"develop/#Sequence","page":"Design","title":"Sequence","text":"The simulation inner loop is critical for efficient simulation. For continuous-time simulation, it's a game of clock-cycles, so we should get this right. This inner loop can have a lot of different kinds of calculations to do, and those calculations benefit from good cache use, right near the processor on L1. As a consequence, we want to design the parts of the inner loop so that they interleave work that operates on the same data.\n\nIf we think of a single transition as a consecutive set of steps, each of which has a different function, then those functions traverse state updates, transitions calculations, and sampling decisions.\n\nFire a transition.\nModify state.\nCalculate changes to transitions.\nUpdate sampler information.\nSample for next transition.\n\nHowever, the state and transitions will be stored on a graph for the most efficient simulations. We'd like to make the most efficient simulations possible. When state and transitions are stored on a graph, it helps to perform all operations on graph data while doing a single traversal of the graph.\n\nFire a transition\nFor each [state changed]\n    Update a single state\n    For each [transition depending on that state]\n        Calculate the hazard rate for that transition.\n        Update the sampler about that updated hazard.\n\nThe goal, then, is to make code where firing, finding affected transitions, and sampling those transitions, is all separate, but they get called nicely in order within a single loop.","category":"section"},{"location":"distributions/#Non-exponential-Simulation","page":"Non-exponential Simulation","title":"Non-exponential Simulation","text":"CompetingClocks is a sampler for generalized semi-Markov processes (GSMP). Every event in a generalized semi-Markov process is chosen as the result of a competion among clocks to see which fires next.\n\nIn a process-oriented simulation (like SimJulia), control flow is based on tasks. Each task performs some action on the state, rolls the dice, and sets a wake-up time. It might wake up as expected and possible execute code, or it might be interrupted by another task's actions. In contrast, an event-oriented simulation using CompetingClocks will create a set of possible next events, assign a probability distribution for when each can happen, and the timing of which happens first determines which next event happens. Let's look at how a probability distribution describes the time for an event to happen and then how they compete in CompetingClocks.","category":"section"},{"location":"distributions/#Distributions-in-Time","page":"Non-exponential Simulation","title":"Distributions in Time","text":"Let's say you have a cold. You know you aren't going to recover immediately, but, as days go by, you're more and more sure you'll recover soon. This graph below shows recovery as a hazard rate, which is the probability, per unit time, given that the event has not yet happened.\n\n(Image: )\n\nThis hazard rate starts at zero, meaning there's no way you'll recover when you're first sick. It gets more likely over time that you're at the tail end of being sick. The hazard rate shown is that of a Gamma distribution, commonly used to describe the rate of recovery for a population of individuals who are sick.\n\nIf, instead, you want to see the number of people who recover on any given day, that is called a probability distribution function (pdf), which is a much more common way to display a distribution in time.\n\n(Image: )\n\nWhere the hazard rate is an instantaneous quantity at a point in time, the probability distribution function (pdf) integrates over all possible future times. If we call the hazard rate lambda(t) and call the pdf f(t), we get this relationship.\n\nf(t) = lambda(t) e^-int_0^t lambda(s)ds\n\nThe graph of the pdf tells us that the most likely time for this event is a little before time 5, in whatever units. You will see graphs of pdfs on Wikipedia because this is how people usually think about the probability an event happens at some time.\n\nA simulation, however, has multiple events possible at any one time. One event may happen, and then other events need to restart. Let's ask, if you still have a cold on day 5, what is the probability distribution function for when you will recover?\n\n(Image: )\n\nThe probability distribution function changes now that you know you didn't recover earlier than day 5. On the other hand, the hazard rate for recovery from the cold will be unchanged. Using the same hazard rate, we can recalculate the pdf from the new time t_0=5.\n\nf(ttt_0) = lambda(t) e^-int_t_0^t lambda(s)ds\n\nThe hazard rate describes a flow of probability, whereas the distribution function tells us about ensembles of events.\n\nThe hazard rate is related to the well known cumulative distribution function (CDF) by an integral. The CDF tells us what is the overall probability the event occured some time in the interval t_0t_1).\n\nF(t_0t_1) = 1 - e^-int_t_0^t_1 lambda(s) ds\n\nEqually important for simulation is the survival function (sometimes called the complementary cumulative distribution function), which is the probability the event will not occur until after t_1.\n\nS(t_1) = 1 - F(t_10) = e^-int_0^t_1 lambda(s) ds\n\n(Image: )\n\nFor our example, survival is the chance the cold lasts longer than the given time.","category":"section"},{"location":"distributions/#Competition","page":"Non-exponential Simulation","title":"Competition","text":"","category":"section"},{"location":"distributions/#Individual-Distributions","page":"Non-exponential Simulation","title":"Individual Distributions","text":"Let's think of a moment when there are three possible next events. There is a Gamma distribution for when you recover from a cold, a Weibull distribution for when you decide to take medicine for the cold, and an Exponential distribution for when your Mom calls you. Each one is described by a distribution in time, and we can think of them as three hazard rates.\n\n(Image: )\n\nThe separate hazard rates are what we put into the simulation. Given their competition, the hazard rates will remain unchanged, but the pdfs will change.","category":"section"},{"location":"distributions/#Marginal-Probability","page":"Non-exponential Simulation","title":"Marginal Probability","text":"Each of the three clock distributions above corresponds to a unique event E_i, which has a probability that it will be the first to fire. We calculate this probability by marginalizing over the other events, which ends up being an integral over the distribution, multiplied by the survivals of the other events.\n\nPE_i = int_0^infty f_i(t) prod_jne i S_j(t) dt\n\nThat gives the chart on the left, where the sum of all PE_i is one.\n\n(Image: )\n\nThe graph on the right shows the conditional distribution in time for each event, given that it was the one that fired, so it is Pt_i  E_i. In the language of semi-Markov processes, these distributions are called holding times. You can see that these distributions don't match the distributions for the individual events. They are modified by competition.","category":"section"},{"location":"distributions/#Marginal-Time","page":"Non-exponential Simulation","title":"Marginal Time","text":"What if we split the marginal and conditional the other way? Instead of marginalizing the probability of which event fires, start with a marginal of the probability for when any event fires. One way to calculate this is to say that the hazard rate for any event to fire is the sum of the hazard rates.\n\nlambda_m(t) = sum_ilambda_i(t)\n\nFrom here, we know the pdf for the first firing time.\n\nf(t) = lambda_m(t)expleft(-int_0^tlambda_m(s)dsright)\n\nFrom the graph above, if we pick a time, t_1=10, we can read from the graph three hazard rates, (lambda_1(t_1)lambda_2(t_1) lambda_3(t_1)). Each hazard rate is the rate, per unit time, of that event. We know that, if the simulation makes it to t=10 without any event happening, the conditional probability for any one of those events is the ratio of hazard rates.\n\nPE_1t=t_1 = fraclambda_1(t_1)lambda_1(t_1)+lambda_2(t_1)+lambda_3(t_1)\n\nNow we can plot, on the left, the pdf for who fires first and, on the right, the probability of which event fires, given the firing time.\n\n(Image: )\n\nOn the left of this graph is the pdf for the first event of the three to fire. We can see this as a marginal Pt and then the right-hand graph as the conditional PE_it.","category":"section"},{"location":"distributions/#Specification-of-a-Simulation","page":"Non-exponential Simulation","title":"Specification of a Simulation","text":"If we imagine a drug trial, where patients can recover, die, or exit the trial for some other reason, there are three mutually-exclusive events, like the example above. If we pick the recovery event and plot its distribution in time, which of the above plots will we see? This will be a holding time. It won't be the pdf that represents the rate of recovery in the absence of competing events. However, given observations of competing events, it is possible to calculate back to the original hazard rates using survival analysis.\n\nSurvival analysis uses observations of event times and event cancellations to estimate hazard rates for each event. It helps you tease apart the effects of competition to see the underlying probability per unit time that any event would fire, given that it has not yet fired.\n\nSimulation is the opposite of survival analysis. It allows you to take rules for how any event would fire, in the absence of competition, and to place it in a more complicated environment where competition happens. When you specify a continuous-time simulation, it isn't specified with the pdfs of holding times but with the pdfs of rates derived from survival analysis.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"CompetingClocks.jl is a registered Julia package. You can install it using Julia's package manager.\n\nIn the Julia REPL, press ] to enter the package manager, then run:\n\npkg> add CompetingClocks\n\nAlternatively, you can install it directly from the REPL:\n\nusing Pkg\nPkg.add(\"CompetingClocks\")\n\nTo use the package in your code:\n\nusing CompetingClocks","category":"section"},{"location":"gen/distribution/#CompetingClocks-as-a-Gen-Distribution","page":"CompetingClocks as a Gen Distribution","title":"CompetingClocks as a Gen Distribution","text":"This document shows how to treat an entire CompetingClocks trajectory as a single random choice in Gen.jl, enabling Bayesian inference over continuous-time discrete-event systems.","category":"section"},{"location":"gen/distribution/#Statistical-Framework","page":"CompetingClocks as a Gen Distribution","title":"Statistical Framework","text":"","category":"section"},{"location":"gen/distribution/#Path-Likelihood-for-Generalized-Semi-Markov-Processes","page":"CompetingClocks as a Gen Distribution","title":"Path Likelihood for Generalized Semi-Markov Processes","text":"Consider a continuous-time system over horizon 0 T where:\n\nAt time t, a set of clocks mathcalK_t are enabled\nEach clock k has a survival function S_k(tau) = 1 - F_k(tau) and hazard h_k(tau) = f_k(tau)S_k(tau)\nThe system produces a path x = (t_1 e_1) ldots (t_n e_n) with 0  t_1  cdots  t_n le T\n\nThe path density with respect to Lebesgue measure on event times follows the standard GSMP form:\n\nlog p(x mid theta) = sum_i=1^n log h_e_i(t_i mid mathcalH_t_i^- theta) - int_0^T sum_k in mathcalK_s h_k(s mid mathcalH_s^- theta)  ds\n\nThe first term sums log-hazards at each firing time. The second term—the integrated hazard over all enabled clocks—accounts for the probability of not firing before each event.","category":"section"},{"location":"gen/distribution/#CompetingClocks-Handles-the-Integrals","page":"CompetingClocks as a Gen Distribution","title":"CompetingClocks Handles the Integrals","text":"When you construct a SamplingContext with path_likelihood=true, CompetingClocks tracks both terms automatically. After simulation:\n\nlog_prob = pathloglikelihood(sampler, T)\n\nreturns the exact log path likelihood, including the probability of no further events until time T.","category":"section"},{"location":"gen/distribution/#Integration-with-Gen","page":"CompetingClocks as a Gen Distribution","title":"Integration with Gen","text":"The strategy is:\n\nSimulate paths using CompetingClocks' next/fire!/enable! loop\nEvaluate log p(x mid theta) via pathloglikelihood\nWrap these as Gen.random and Gen.logpdf for a custom distribution\n\nFrom Gen's perspective, the entire trajectory becomes a single continuous random choice whose density is delegated to CompetingClocks.\n\n","category":"section"},{"location":"gen/distribution/#Example:-Density-Dependent-Birth-Death-Process","page":"CompetingClocks as a Gen Distribution","title":"Example: Density-Dependent Birth-Death Process","text":"A simple linear birth-death process either explodes or dies out. For stable dynamics suitable for inference, we use a logistic birth rate:\n\nlambda(N) = lambda_0 cdot N cdot maxleft(0 1 - fracNKright)\n\nwhere K is the carrying capacity. This ensures the population fluctuates around K rather than diverging.\n\nThe complete working example is in examples/gen_distribution.jl.","category":"section"},{"location":"gen/distribution/#Basic-Types","page":"CompetingClocks as a Gen Distribution","title":"Basic Types","text":"using Random\nusing Distributions\nusing CompetingClocks\n\n# Clock keys: (:birth, 0) for births, (:death, i) for individual i's death\nconst ClockKey = Tuple{Symbol,Int}\n\n# A single event in a trajectory\nstruct BDEvent\n    time::Float64\n    key::ClockKey\nend\n\nconst EventPath = Vector{BDEvent}\n\n# Population state\nmutable struct BDState\n    population::Set{Int}\n    next_id::Int\nend\n\nBDState(N0::Int) = BDState(Set(1:N0), N0 + 1)","category":"section"},{"location":"gen/distribution/#Simulation-with-Path-Likelihood","page":"CompetingClocks as a Gen Distribution","title":"Simulation with Path Likelihood","text":"function simulate_bd(\n    rng::AbstractRNG,\n    t_max::Float64,\n    λ_birth::Float64,\n    K::Float64,\n    death_shape::Float64,\n    death_scale::Float64,\n    N0::Int,\n)\n    # Enable path likelihood tracking\n    sampler = SamplingContext(ClockKey, Float64, rng; path_likelihood=true)\n    state = BDState(N0)\n    path = EventPath()\n\n    # Density-dependent birth rate\n    function birth_rate(N::Int)\n        N <= 0 && return 0.0\n        return λ_birth * N * max(0.0, 1.0 - N / K)\n    end\n\n    # Initialize clocks\n    rate = birth_rate(length(state.population))\n    if rate > 0\n        enable!(sampler, (:birth, 0), Exponential(inv(rate)))\n    end\n    for i in state.population\n        enable!(sampler, (:death, i), Gamma(death_shape, death_scale))\n    end\n\n    # Simulation loop\n    when, which = next(sampler)\n    while !isnothing(which) && when <= t_max\n        fire!(sampler, which, when)\n        push!(path, BDEvent(when, which))\n\n        # Update state\n        if which[1] == :birth\n            new_id = state.next_id\n            state.next_id += 1\n            push!(state.population, new_id)\n            enable!(sampler, (:death, new_id), Gamma(death_shape, death_scale))\n        elseif which[1] == :death\n            delete!(state.population, which[2])\n        end\n\n        # Refresh birth clock with updated rate\n        rate = birth_rate(length(state.population))\n        if rate > 0\n            enable!(sampler, (:birth, 0), Exponential(inv(rate)))\n        end\n\n        when, which = next(sampler)\n    end\n\n    return path, sampler\nend","category":"section"},{"location":"gen/distribution/#Replay-for-Log-Likelihood-Evaluation","page":"CompetingClocks as a Gen Distribution","title":"Replay for Log-Likelihood Evaluation","text":"To compute log p(x mid theta) for an arbitrary path x, we \"replay\" it through a fresh sampler:\n\nfunction bd_path_logpdf(\n    path::EventPath,\n    t_max::Float64,\n    λ_birth::Float64,\n    K::Float64,\n    death_shape::Float64,\n    death_scale::Float64,\n    N0::Int,\n)::Float64\n    # Validate path structure\n    if any(ev -> ev.time < 0 || ev.time > t_max, path)\n        return -Inf\n    end\n    for i in 2:length(path)\n        if path[i].time <= path[i-1].time\n            return -Inf\n        end\n    end\n\n    # Fresh sampler for replay (RNG unused)\n    rng = Xoshiro(0)\n    sampler = SamplingContext(ClockKey, Float64, rng; path_likelihood=true)\n    state = BDState(N0)\n\n    # Same birth rate function\n    function birth_rate(N::Int)\n        N <= 0 && return 0.0\n        return λ_birth * N * max(0.0, 1.0 - N / K)\n    end\n\n    # Initialize\n    rate = birth_rate(length(state.population))\n    if rate > 0\n        enable!(sampler, (:birth, 0), Exponential(inv(rate)))\n    end\n    for i in state.population\n        enable!(sampler, (:death, i), Gamma(death_shape, death_scale))\n    end\n\n    # Replay events\n    for ev in path\n        if !isenabled(sampler, ev.key)\n            return -Inf  # Invalid: firing a disabled clock\n        end\n\n        fire!(sampler, ev.key, ev.time)\n\n        if ev.key[1] == :birth\n            new_id = state.next_id\n            state.next_id += 1\n            push!(state.population, new_id)\n            enable!(sampler, (:death, new_id), Gamma(death_shape, death_scale))\n        elseif ev.key[1] == :death\n            delete!(state.population, ev.key[2])\n        end\n\n        rate = birth_rate(length(state.population))\n        if rate > 0\n            enable!(sampler, (:birth, 0), Exponential(inv(rate)))\n        end\n    end\n\n    return pathloglikelihood(sampler, t_max)\nend\n\n","category":"section"},{"location":"gen/distribution/#Gen-Distribution-Wrapper","page":"CompetingClocks as a Gen Distribution","title":"Gen Distribution Wrapper","text":"","category":"section"},{"location":"gen/distribution/#Distribution-Type","page":"CompetingClocks as a Gen Distribution","title":"Distribution Type","text":"using Gen\n\nstruct BDPathDist <: Gen.Distribution{EventPath} end\nconst bd_path_dist = BDPathDist()","category":"section"},{"location":"gen/distribution/#Required-Methods","page":"CompetingClocks as a Gen Distribution","title":"Required Methods","text":"function Gen.random(\n    ::BDPathDist,\n    t_max::Float64,\n    λ_birth::Float64,\n    K::Float64,\n    death_shape::Float64,\n    death_scale::Float64,\n    N0::Int,\n)::EventPath\n    rng = Random.default_rng()\n    path, _ = simulate_bd(rng, t_max, λ_birth, K, death_shape, death_scale, N0)\n    return path\nend\n\nfunction Gen.logpdf(\n    ::BDPathDist,\n    path::EventPath,\n    t_max::Float64,\n    λ_birth::Float64,\n    K::Float64,\n    death_shape::Float64,\n    death_scale::Float64,\n    N0::Int,\n)::Float64\n    return bd_path_logpdf(path, t_max, λ_birth, K, death_shape, death_scale, N0)\nend\n\nGen.is_discrete(::BDPathDist) = false\nGen.has_output_grad(::BDPathDist) = false\nGen.has_argument_grads(::BDPathDist) = (false, false, false, false, false, false)\n\nThis is sufficient for importance sampling, SMC, and Metropolis-Hastings. For gradient-based inference (HMC/NUTS), implement logpdf_grad.\n\n","category":"section"},{"location":"gen/distribution/#Using-the-Distribution-in-a-Gen-Model","page":"CompetingClocks as a Gen Distribution","title":"Using the Distribution in a Gen Model","text":"","category":"section"},{"location":"gen/distribution/#Generative-Model","page":"CompetingClocks as a Gen Distribution","title":"Generative Model","text":"@gen function bd_model(t_max::Float64, K::Float64, N0::Int)\n    # Priors on rate parameters\n    λ_birth = @trace(gamma(2.0, 1.0), :λ_birth)        # mean = 2\n    mean_death = @trace(gamma(2.0, 2.0), :mean_death)  # mean = 4\n\n    death_shape = 2.0\n    death_scale = mean_death / death_shape\n\n    # Entire trajectory as one random choice\n    path = @trace(\n        bd_path_dist(t_max, λ_birth, K, death_shape, death_scale, N0),\n        :path,\n    )\n\n    return (λ_birth=λ_birth, mean_death=mean_death, path=path)\nend","category":"section"},{"location":"gen/distribution/#Forward-Simulation","page":"CompetingClocks as a Gen Distribution","title":"Forward Simulation","text":"t_max = 10.0\nK = 50.0\nN0 = 10\n\ntrace = Gen.simulate(bd_model, (t_max, K, N0))\nretval = Gen.get_retval(trace)\n\nprintln(\"λ_birth = \", retval.λ_birth)\nprintln(\"mean_death = \", retval.mean_death)\nprintln(\"Events = \", length(retval.path))\nprintln(\"Log-probability = \", Gen.get_score(trace))","category":"section"},{"location":"gen/distribution/#Conditioning-on-Observed-Data","page":"CompetingClocks as a Gen Distribution","title":"Conditioning on Observed Data","text":"Given an observed trajectory obs_path:\n\nobs = Gen.choicemap((:path, obs_path))\ntrace, logw = Gen.generate(bd_model, (t_max, K, N0), obs)\n\n# trace[:λ_birth] and trace[:mean_death] are sampled from the prior\n# logw is the importance weight\n\nFor proper posterior inference, use Gen's inference library:\n\n# Importance sampling\ntraces, weights, _ = Gen.importance_sampling(bd_model, (t_max, K, N0), obs, n_samples)\n\n# MCMC\ntrace, = Gen.importance_resampling(bd_model, (t_max, K, N0), obs, 100)\nfor i in 1:1000\n    trace, = Gen.mh(trace, Gen.select(:λ_birth, :mean_death))\nend\n\n","category":"section"},{"location":"gen/distribution/#Generalizing-to-Other-Models","page":"CompetingClocks as a Gen Distribution","title":"Generalizing to Other Models","text":"The pattern applies to any CompetingClocks simulation:\n\nDefine your simulation using SamplingContext(...; path_likelihood=true)\nRecord the path as a sequence of (time, event) pairs\nWrite a replay function that:\nCreates a fresh sampler with path_likelihood=true\nReplays each event with fire!(sampler, key, time)\nReturns pathloglikelihood(sampler, T)\nWrap as Gen.Distribution with random and logpdf\n\nThe simulation logic (state transitions, clock distributions) is model-specific. The Gen integration remains identical.","category":"section"},{"location":"gen/distribution/#Examples-to-Adapt","page":"CompetingClocks as a Gen Distribution","title":"Examples to Adapt","text":"SIR epidemics: Infection and recovery clocks with population-dependent rates\nQueueing systems: Arrival and service clocks with queue-length feedback\nReliability models: Component failure and repair with dependent hazards\nChemical kinetics: Reaction clocks with mass-action propensities\n\nIn each case, the path likelihood integral is handled automatically by CompetingClocks.","category":"section"},{"location":"choosing_sampler/#Choosing-a-Sampler","page":"Choosing a Sampler","title":"Choosing a Sampler","text":"How to make a sampler for events in CompetingClocks.jl.","category":"section"},{"location":"choosing_sampler/#High-level-Interface","page":"Choosing a Sampler","title":"High-level Interface","text":"Every event in a simulation has an identifying key which can be any immutable Julia type. A Tuple key type works fine, but it will be more performant to use a concrete type for the KeyType. The second argument is a type to use for time. Basic usage:\n\nsampler = SamplingContext(KeyType, Float64, rng)\n\nThe sampler takes a Random.AbstractRNG as its second argument.\n\nSpecify features for the sampler with keyword arguments. These features determine the type of the sampler.\n\nmethod=nothing–-Setting this chooses a single sampling algorithm for all clocks.\nstep_likelihood=false–-Setting this to true let's you calculate the the likelihood of the next event and time before firing it.\npath_likelihood=false–-Set to true in order to calculate likelihood of a whole trajectory at any point in the simulation. This is more efficient than adding up steps in the likelihood along the way.\nlikelihood_cnt=1–-Applies when likelihoods are enabled and supports importance sampling. Specifies how many event distributions will be used to calculate a vector of likelihoods.\ncommon_random=false–-For variance reduction, turn on recording of random number usage during sampling.\nstart_time=0–-Sometimes you want a simulation to start at a different time.\ndebug=false–-Whether to print debug messages using the Logging package.\nrecording=false–-This will create a vector of every enable and disable event for test and debug.\n\nIf you want to try a particular sampler instead of having the SamplingContext pick one for you, use the method parameter.\n\nsampler = SamplingContext(KeyType, Float64, rng; method=DirectMethod(:keep, :tree))","category":"section"},{"location":"choosing_sampler/#Quick-Reference","page":"Choosing a Sampler","title":"Quick Reference","text":"These are all of the samplers.\n\nName Distribution support Best use cases\nFirstToFireMethod All Fastest for simple simulation\nNextReactionMethod All Best for common random numbers\nFirstReactionMethod All Fastest for very few events\nDirectMethod Exponential-only Quicker likelihood calculation\nRejectionMethod Exponential-only RSSA for large systems\nPartialPropensityMethod Exponential-only For reaction networks.\nPetriMethod All Debug rare errors","category":"section"},{"location":"choosing_sampler/#Hierarchical-Samplers","page":"Choosing a Sampler","title":"Hierarchical Samplers","text":"For spatial simulations, chemical simulations that aren't well-mixed, or simulations with some fast and many slow clocks, it can help to split a sampler into multiple buckets so that each bucket can update its own list of what fires next. This package does this by adding sampler groups.\n\nA sampler group is\n\nA Symbol name for the sampler.\nAn inclusion function from (ClockKey, Distribution) to Bool that decides whether a given event belongs to this sampler.\nAn optional method to say what kind of sampler this group should use.\n\nThis example sends events with keys like (:infect, 3) tto the sampler called :forthright and sends keys like (:recover, 7) to the sampler called :sparky.\n\nconst KeyType = Tuple{Symbol,Integer}\nbuilder = SamplerBuilder(KeyType, Float64)\nadd_group!(builder, :sparky => (x,d) -> x[1] == :recover, method=NextReaction())\nadd_group!(builder, :forthright=>(x,d) -> x[1] == :infect)\nsampler = SamplingContext(builder, rng)\n\nThe resulting sampler will be hierarchical. For every event, it will choose the soonest time among the soonest times from all sampler groups.","category":"section"},{"location":"sir/#Non-Markovian-SIR-Model","page":"SIR Model","title":"Non-Markovian SIR Model","text":"using Random\nusing Plots\nusing Distributions\nusing CompetingClocks\n\nIn this tutorial we demonstrate construction of a SIR (susceptible-infectious-removed) model with non-exponential recovery times. Infection events occur at the points of a Poisson process, which is equivalent to using a single exponential clock whose rate corresponds to the overall rate of infection in the population. The infection rate is beta c S I  N where N is the total population size, making this a frequency-dependent force of infection term rather than pure mass action (although as N does not change in this example, the difference is moot). Clocks for recovery events follow an arbitrary distribution.","category":"section"},{"location":"sir/#Model-structure","page":"SIR Model","title":"Model structure","text":"We use a struct that stores the type of the recovery distribution as a type parameter. The model state is stored as a vector of integers, representing S, I, and R. Additionally, because recovery clocks need unique keys, we define the method get_key! which retrives an integer key and increments the stored key counter.\n\nThe initialize! method uses the initial state to enable the infection clock and recovery clocks for each initial infectious person. Note that the keys are a tuple where the first element is a Symbol giving the event type, and the second element is an integer.\n\nmutable struct SIRNonMarkov{T<:Distribution}\n    state::Vector{Int}\n    parameters::Vector{Float64}\n    next_key::Int\n    recovery_distribution::T\n    time::Float64\nend\n\nfunction get_key!(model::SIRNonMarkov)\n    key = model.next_key\n    model.next_key += 1\n    return key\nend\n\nfunction initialize!(model::SIRNonMarkov, sampler, rng)\n    (β, c, γ) = model.parameters\n    # enable the infection clock\n    enable!(\n        sampler,\n        (:infection, get_key!(model)),\n        Exponential(1.0/(β*c*model.state[2]/sum(model.state)*model.state[1])),\n        model.time,\n        model.time,\n        rng\n        )\n    # enable the recovery clocks\n    for _ in 1:model.state[2]\n        enable!(sampler, (:recovery, get_key!(model)), model.recovery_distribution, model.time, model.time, rng)\n    end\nend;","category":"section"},{"location":"sir/#Model-update","page":"SIR Model","title":"Model update","text":"In the model update function, we use the first element of the clock key to determine the event type corresponding to the clock that fired, and apply the corresponding logic. Infection events disable and enable the infection event with a new rate, and enable a recovery clock for the newly infectious individual. Recovery events simply disable the clock associated to that event. Both events update the state vector.\n\nfunction step!(model::SIRNonMarkov, sampler::SSA{K,T}, when::T, which::K, rng) where {K,T}\n    (β, c, γ) = model.parameters\n    model.time = when\n    if first(which) == :infection\n        model.state[1] -= 1\n        model.state[2] += 1\n        # disable and reenable the infection clock after accounting for the new rate\n        disable!(sampler, which, model.time)\n        enable!(\n            sampler,\n            which,\n            Exponential(1.0/(β*c*model.state[2]/sum(model.state)*model.state[1])),\n            model.time,\n            model.time,\n            rng\n            )\n        # enable a recovery event for the newly infected person\n        enable!(\n            sampler,\n            (:recovery, get_key!(model)),\n            model.recovery_distribution,\n            model.time,\n            model.time,\n            rng\n            )\n    elseif first(which) == :recovery\n        model.state[2] -= 1\n        model.state[3] += 1\n        disable!(sampler, which, model.time)\n    else\n        error(\"unrecognized clock key: $(which)\")\n    end\nend;","category":"section"},{"location":"sir/#Simulation","page":"SIR Model","title":"Simulation","text":"We first set parameters.\n\ntmax = 40.0\ninitial_state = [990, 10, 0]\np = [0.05, 10.0, 4.0]\n\nseed = 456959517\nrng = MersenneTwister(seed);\n\nNext we generate the model struct and the sampler object. Here we choose the CombinedNextReaction sampler type. We choose to use a Dirac delta distribution to simulate deterministic recovery times.\n\nsirmodel = SIRNonMarkov(deepcopy(initial_state), p, 0, Dirac(p[3]), 0.0)\nsampler = CombinedNextReaction{Tuple{Symbol,Int},Float64}();\n\nNow we may run the model, using a function run_sir!. We preallocate a matrix to store model output. Note that in the simple SIR model with only infection and recovery events, a maximum of 2S + I events is possible.\n\nfunction run_sir!(model, sampler, tmax, rng)\n\n    output = zeros(2*model.state[1]+model.state[2]+1, 4)\n    nout = 1\n    output[nout,:] = [sirmodel.time; sirmodel.state]\n    nout += 1;\n\n    initialize!(model, sampler, rng)\n\n    (when, which) = next(sampler, model.time, rng)\n\n    while when <= tmax\n        step!(model, sampler, when, which, rng)\n        (when, which) = next(sampler, model.time, rng)\n\n        output[nout,:] .= [model.time; model.state]\n        nout += 1\n    end\n\n    return output, nout\nend\n\n(output, nout) = run_sir!(sirmodel, sampler, tmax, rng);\n\nFinally we can plot the sampled trajectory.\n\nplot(\n    output[1:nout-1,1],\n    output[1:nout-1,2:end],\n    label=[\"S\" \"I\" \"R\"],\n    xlabel=\"Time\",\n    ylabel=\"Number\"\n)\n\n<img src=\"data:image/png;base64,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\" />\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"constant_birth/#Delayed-Birth-Death-Process","page":"Birth-death Process","title":"Delayed Birth-Death Process","text":"using Random\nusing Distributions\nusing CompetingClocks\n\nBirth-death processes are a fundamental type of stochastic process, and are the building block of many more complicated models. Here we demonstrate how to use CompetingClocks to build a very simple simulation of a birth-death process where birth occurs according to an exponential (Markov) clock, but death occurs according to a Weibull distribution. We compare ensemble results to the known stationary distribution. Such models have been considered many times in the literature, but a recent reference is in \"Stochastic description of delayed systems\" by Lafuerza and Toral.","category":"section"},{"location":"constant_birth/#Model-structure","page":"Birth-death Process","title":"Model structure","text":"The model will be stored in a struct with a type parameter that is a subtype of ContinuousUnivariateDistribution, which is the distribution type for the clock associated to death. We also define a function initialize_model! which enables a single clock for the birth event, and for each individual in the initial population, enables a death clock for that individual.\n\nKnown results tell us that the mean of the stationary distribution will be the birth rate multiplied by the average duration alive, which we use to choose the number of individuals in the initial population. We expect the model to fluctuate randomly around this value.\n\nmutable struct ConstantBirth{T <: ContinuousUnivariateDistribution}\n    birth_rate::Float64\n    death_distribution::T\n    next_name::Int64\n    alive::Int64\n    when::Float64\nend\n\n\nfunction initialize_model!(model, sampler, rng)\n    enable!(sampler, 1, Exponential(1.0 / model.birth_rate), 0.0, 0.0, rng)\n\n    initial_population = model.birth_rate * mean(model.death_distribution)\n\n    for name_id in 1:Int(round(initial_population))\n        past_birth = rand(rng, model.death_distribution)\n        enable!(sampler, name_id, model.death_distribution, -past_birth, 0.0, rng)\n        model.next_name = name_id + 1\n        model.alive += 1\n    end\nend;","category":"section"},{"location":"constant_birth/#Model-update","page":"Birth-death Process","title":"Model update","text":"There's two classes of events that can occur in this model. Birth is always assigned to key 1. When it fires, we disable and enable the birth process to reset it, and then enable a death clock for the new individual. If the firing event was death, we simply disable the clock. We return the integrated population over time from the step! method to check simulation results.\n\nfunction step!(model::ConstantBirth, sampler::SSA{K,T}, when::T, which::K, rng) where {K,T}\n    if which == 1\n        disable!(sampler, 1, when)\n        enable!(sampler, 1, Exponential(1.0 / model.birth_rate), when, when, rng)\n\n        name_id = model.next_name\n        enable!(sampler, name_id, model.death_distribution, when, when, rng)\n        model.next_name += 1\n        model.alive += 1\n    else\n        disable!(sampler, which, when)\n        model.alive -= 1\n    end\n    duration = when - model.when\n    model.when = when\n    model.alive * duration\nend;\n\nOur run function is simple. We use the FirstToFire sampler, but any sampler from CompetingClocks capable of supporting non-Exponential distributions can be used.\n\nfunction run_constant_birth(rng, max_step = 10000)\n    birth_rate = 117.0\n    death_rate = Weibull(2.0, 80)\n    model = ConstantBirth(birth_rate, death_rate, 2, 0, 0.0)\n\n    sampler = FirstToFire{Int,Float64}()\n    initialize_model!(model, sampler, rng)\n    # Begin by dropping a few events to account for burn-in.\n    when = 0.0\n    (when, which) = next(sampler, when, rng)\n    while when < 1e4\n        step!(model, sampler, when, which, rng)\n        (when, which) = next(sampler, when, rng)\n    end\n\n    # Then collect statistics.\n    total::Float64 = 0.0\n    start_time = when\n    for _ in 1:max_step\n        total += step!(model, sampler, when, which, rng)\n        (when, which) = next(sampler, when, rng)\n    end\n    steady_state = model.birth_rate * mean(model.death_distribution)\n\n    observed_state = total / (when - start_time)\n    (steady_state, observed_state)\nend;","category":"section"},{"location":"constant_birth/#Simulation","page":"Birth-death Process","title":"Simulation","text":"We check below that as we increase the data collected, it gets closer to the expected average with smaller standard deviation.\n\nfunction multiple_runs(trial_cnt = 20, max_step = 1000)\n    rng = Xoshiro(837100235)\n    trials = zeros(Float64, trial_cnt)\n    single_expected = 0.0\n    Threads.@threads for trial_idx in 1:trial_cnt\n        expected, observed = run_constant_birth(rng, max_step)\n        trials[trial_idx] = observed\n        single_expected = expected\n    end\n    (single_expected,\n     (mean(trials) - single_expected) / single_expected,\n     std(trials) / single_expected)\nend\n\nmultiple_runs(5, 100)\n\n(8295.084022237816, -0.0066604446780677735, 0.008892718847004514)\n\nmultiple_runs(5, 200)\n\n(8295.084022237816, -0.006388077460778242, 0.012503310457599722)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"gen/survival_snippet/#Integration-with-Survival.jl","page":"Integration with Survival.jl","title":"Integration with Survival.jl","text":"Fitting a survival distribution and using it as a GSMP clock.\n\nThis example shows how to:\n\nGenerate some noisy event times with random right‐censoring.\nFit a nonparametric Kaplan–Meier survival curve using Survival.jl.\nFit a parametric Weibull distribution to that curve.\nWrap the fitted Weibull as a UnivariateDistribution and use it as a clock distribution in CompetingClocks.jl.\n\nusing Random\nusing Distributions\nusing Survival          # Kaplan–Meier and EventTime\nusing LsqFit            # nonlinear least squares for parametric fit\nusing CompetingClocks   # GSMP sampler\n\nRandom.seed!(2024)\n\n# ------------------------------------------------------------\n# 1. Synthetic \"messy\" event times with right censoring\n# ------------------------------------------------------------\n\nn = 200\ntrue_dist = Weibull(1.7, 4.0)             # ground-truth failure-time distribution\n\nt_event  = rand(true_dist, n)             # actual failure times\nt_censor = rand(Uniform(0.0, 8.0), n)     # censoring times\n\ntime   = min.(t_event, t_censor)          # observed follow-up time\nstatus = t_event .<= t_censor             # true = failure observed, false = censored\n\n# Optionally store as EventTime values (useful elsewhere in Survival.jl)\nevent_times = EventTime.(time, status)\n\n# ------------------------------------------------------------\n# 2. Nonparametric Kaplan–Meier survival estimate\n# ------------------------------------------------------------\n\nkm = fit(KaplanMeier, time, status)\n\nt_km = km.events.time     # unique event/censor times\nS_km = km.survival        # Kaplan–Meier Ŝ(t)\n\n# ------------------------------------------------------------\n# 3. Parametric Weibull fit to the Kaplan–Meier curve\n#    S_model(t; α, θ) = P(T > t) = ccdf(Weibull(α, θ), t)\n# ------------------------------------------------------------\n\nfunction km_model(t, p)\n    d = Weibull(p[1], p[2])              # p[1] = α (shape), p[2] = θ (scale)\n    return [ccdf(d, ti) for ti in t]     # model survival at each time ti\nend\n\np0 = [1.0, 3.0]                          # initial guess for (α, θ)\nfit_result = curve_fit(km_model, t_km, S_km, p0)\n\nα̂, θ̂ = fit_result.param                # fitted Weibull parameters\nfailure_time_dist = Weibull(α̂, θ̂)      # this is a ContinuousUnivariateDistribution\n\n# ------------------------------------------------------------\n# 4. Use the fitted distribution as a CompetingClocks clock\n# ------------------------------------------------------------\n\nconst ClockKey = Symbol\n\nbuilder = SamplerBuilder(ClockKey, Float64)\nrng = Xoshiro(1234)\nsampler = SamplingContext(builder, rng)\n\n# Enable a GSMP clock whose waiting time is given by the fitted Weibull\nenable!(sampler, :failure, failure_time_dist)\n\n# Sample the next event time from this calibrated clock\nwhen, which = next(sampler)\n@show when which","category":"section"},{"location":"gene_expression/#Stochastic-Gene-Expression","page":"Gene Expression","title":"Stochastic Gene Expression","text":"This is a long example to demonstrate the use of path likelihoods to do importance sampling. The goal of the example is to estimate the probability of a transcriptional burst.\n\nDNA becomes proteins in a three-step process.\n\nDNA can replicate itself.\nTranscription changes a gene in DNA into RNA.\nTranslation turns RNA into protein.\n\nWe will account for the changing states of the system.\n\nA gene can be ON or OFF. When it's ON, it can make RNA. We are looking for the case where the switch stays on longer.\nThe gene has startup time to transcribe its first RNA. One possibile hazard rate comes from the LogNormal distribution.\nmRNA degrades. Different parts of the mRNA are degrading individually with constant rates until they reach a threshold. The time to the threshold is described by a Gamma distribution.\nEach mRNA makes proteins until it degrades.","category":"section"},{"location":"gene_expression/#Importance-sampling","page":"Gene Expression","title":"Importance sampling","text":"The main challenge of simulating transcriptional bursts is that large bursts are rare. This is a good case for using importance sampling. Importance sampling is a way to simulate from a biased set of distributions, in this case distributions weighted towards making more large bursts, but to account for that bias in your final estimate.\n\nThe usual way to use simulations to estimate a quantity is to sum the outcome across trajectories.\n\nE_pf(X) approx frac1Nsum_i=1^N f(x_i)\n\nThat sum is an approximation of a statistical expectation of f over the probability distribution p.\n\nE_pf(X) = int f(x)p(x)dx\n\nThe events in a simulation and their distributions determine the probability p(x) for each trajectory x, and for rare events that probability is very small, so we will bias it.\n\nWe bias it by picking different distributions for our events. Let's call the biased space q. If we work backwards from the statistical expression, we will see that we can undo the bias when we do our sum over trajectories.\n\nE_pf(x) = int f(x)fracp(x)q(x)dx = E_qf(X)fracp(X)q(X)\n\nHere X is a sample under the distribution q. That means we draw from q and at the end sum with a weight on each trajectory.\n\nhatmu = frac1Nsum_i=1^N f(X_i)w(X_i)\n\nHere the importance weight is w(x)=p(x)q(x). This package's samplers will calculate that weigth for you as a path log-likelihood, which is log w(x).\n\nLet's give this a try for gene expression. We can use an intuitive bias shift.\n\nWe're going to rely on standard Julia distributions with one extra one, imported from the file genedist.jl which expresses the initial slowness of MRNA production using a time-varying rate.\n\nusing CompetingClocks\nusing Distributions\nusing Logging\nusing Random\nusing Printf\ninclude(\"genedist.jl\")\n\nBase.rand","category":"section"},{"location":"gene_expression/#State-of-the-system","page":"Gene Expression","title":"State of the system","text":"We start the system when the promoter turns ON and stop the simulation when the promoter turns OFF.\n\nVector of MRNA. Each one was created at a certain time and is enabled/disabled.\nCount of total proteins created.","category":"section"},{"location":"gene_expression/#Events-in-the-system","page":"Gene Expression","title":"Events in the system","text":"(:on, 0), Turn on the promoter. We use this to start the simulation.\n(:transcribe, 0) - When this fires, the promoter creates an MRNA.\n(:translate, 0) - The rate of translation is proportional to the number of MRNA that currently exist.\n(:degrade, mrna_id) - A particular MRNA will degrade, turning it off.\n\nTime = Float64\nEpoch = Int\nmutable struct GeneExpression\n    mrna::Vector{Tuple{Time,Bool}}\n    protein::Int\n    θ::Dict{Symbol,NTuple{2,Float64}}\n    function GeneExpression(params)\n        mrna = Tuple{Time,Bool}[]\n        sizehint!(mrna, 2000)\n        new(mrna, 0, params)\n    end\nend\nBase.empty!(ge::GeneExpression) = (empty!(ge.mrna); ge.protein = 0; nothing)\n\nYou will see in the simulation that we initialize two distributions for each event. The first is used to determine the likelihood of the event. The second distribution is used to sample for the next time. These two can be the same, or they can differ if we want to use importance sampling.\n\nWhen we turn the promoter on, it turns on slowly and ramps up. This is reflected in a custom distribution called TranscriptionRate.\n\nfunction turn_promoter_on(model, sampler, individual, when, θ)\n    enable!(sampler, (:off, 0), [Exponential(inv(θ[:promoter_off][1])), Exponential(inv(θ[:promoter_off][2]))])\n    rate1 = TranscriptionRate(θ[:transcribe_max][1], θ[:transcribe_remodel][1])\n    rate2 = TranscriptionRate(θ[:transcribe_max][2], θ[:transcribe_remodel][2])\n    enable!(sampler, (:transcribe, 0), [rate1, rate2])\nend\n\nturn_promoter_on (generic function with 1 method)\n\nTurning the promoter off doesn't stop the system. We count every protein created until all MRNA degrade.\n\nturn_promoter_off(model, sampler, individual, when, θ) = disable!(sampler, (:transcribe, 0))\n\nturn_promoter_off (generic function with 1 method)\n\nThe transcription rate depends on the number of MRNA present as a total, but each MRNA can degrade individually with a Gamma distribution that starts it's clock when that particular MRNA is produced. The Gamma distribution is the same distribution we use to model how a person recovers from the flu.\n\nfunction transcribe_mrna(model, sampler, individual, when, θ)\n    pre_event_total = count(x -> x[2], model.mrna)\n    total = pre_event_total\n    mrna_id = length(model.mrna) + 1\n    push!(model.mrna, (when, true))\n    time_offset = when - 0  # The 0 is when the promoter turned on.\n    rate1 = TranscriptionRate(θ[:transcribe_max][1], θ[:transcribe_remodel][1]; t0=time_offset)\n    rate2 = TranscriptionRate(θ[:transcribe_max][2], θ[:transcribe_remodel][2]; t0=time_offset)\n    enable!(sampler, (:transcribe, 0), [rate1, rate2])\n    total = count(x -> x[2], model.mrna)\n    transrate1 = Exponential(inv(θ[:translate][1] * total))\n    transrate2 = Exponential(inv(θ[:translate][2] * total))\n    pre_event_total > 0 && disable!(sampler, (:translate, 0))\n    enable!(sampler, (:translate, 0), [transrate1, transrate2])\n    gamma1 = Gamma(θ[:degrade_k][1], inv(θ[:degrade_theta][1]))\n    gamma2 = Gamma(θ[:degrade_k][2], inv(θ[:degrade_theta][2]))\n    enable!(sampler, (:degrade, mrna_id), [gamma1, gamma2])\nend\n\ntranscribe_mrna (generic function with 1 method)\n\nDegrading an MRNA will turn off protein production for that MRNA, but if it turns off the last MRNA, then it turns of all translation.\n\nfunction degrade_mrna(model, sampler, individual, when, θ)\n    pre_event_total = count(x -> x[2], model.mrna)\n    total = pre_event_total\n    model.mrna[individual] = (zero(Time), false)\n    pre_event_total > 0 && disable!(sampler, (:translate, 0))\n    total = count(x -> x[2], model.mrna)\n    if total > 0\n        transrate1 = Exponential(inv(θ[:translate][1] * total))\n        transrate2 = Exponential(inv(θ[:translate][2] * total))\n        enable!(sampler, (:translate, 0), [transrate1, transrate2])\n    end\nend\n\ndegrade_mrna (generic function with 1 method)\n\nWhen translation happens, it isn't a one-time event. The same event can happen again, so we re-enable it.\n\nfunction translate_protein(model, sampler, individual, when, θ)\n    pre_event_total = count(x -> x[2], model.mrna)\n    model.protein += 1\n    if pre_event_total > 0\n        transrate1 = Exponential(inv(θ[:translate][1] * pre_event_total))\n        transrate2 = Exponential(inv(θ[:translate][2] * pre_event_total))\n        enable!(sampler, (:translate, 0), [transrate1, transrate2])\n    end\nend\n\ntranslate_protein (generic function with 1 method)\n\nOur central dynamics calls the appropriate function above when its event fires.\n\nfunction step_gene!(model, sampler, which, when)\n    event, individual = which\n    Dict(\n        :on => turn_promoter_on,\n        :off => turn_promoter_off,\n        :transcribe => transcribe_mrna,\n        :degrade => degrade_mrna,\n        :translate => translate_protein,\n    )[event](model, sampler, individual, when, model.θ)\nend\n\nstep_gene! (generic function with 1 method)\n\nThe CompetingClocks.jl package does the sampling, but you create the mainloop.\n\nfunction one_epoch(model, sampler)\n    step_gene!(model, sampler, (:on, 0), time(sampler))\n    when, which = next(sampler)\n    while !isnothing(which)\n        fire!(sampler, which, when)\n        step_gene!(model, sampler, which, when)\n        when, which = next(sampler)\n    end\n    basal, weighted = pathloglikelihood(sampler, time(sampler))\n    logimportance = basal - weighted\n    return (model.protein, logimportance)\nend\n\none_epoch (generic function with 1 method)\n\nThis runs the simulation many times with chosen parameters.\n\nfunction run_epochs(epoch_cnt, use_importance, rng)\n    # We define two sets of parameters. The first biases the simulation towards\n    # producing a rare event and the second is the basal rate we use to evaluate\n    # the importance of those events.\n    params = Dict(\n        :promoter_off => (0.6, 0.2), # per minute\n        :transcribe_max => (10.0, 10.0), # mRNA/min\n        :transcribe_remodel => (1.0, 1.0), # per minute, rate of chromatin opening.\n        :degrade_k => (4.0, 4.0),  # k for Gamma\n        :degrade_theta => (4 * 4 / 30, 4 * 4 / 30), # theta for Gamma\n        :translate => (1.00, 1.05), # proteins/min/mRNA\n    )\n    protein = zeros(Int, epoch_cnt)\n    importance = zeros(Float64, epoch_cnt)\n    model = GeneExpression(params)\n    builder = SamplerBuilder(\n        Tuple{Symbol,Int}, Float64;\n        method=FirstToFireMethod(),\n        path_likelihood=true,\n        likelihood_cnt=2,\n    )\n    sampler = SamplingContext(builder, rng)\n    sample_from_distribution!(sampler, use_importance ? 2 : 1)\n    for epoch_idx in eachindex(protein)\n        (cnt, weight) = one_epoch(model, sampler)\n        protein[epoch_idx] = cnt\n        importance[epoch_idx] = weight\n        empty!(model)\n        reset!(sampler)\n    end\n    return protein, importance\nend\nfunction show_observed(observed)\n    bins = 100 * collect(1:10)\n    gt_bin = [sum(observed .> bin) for bin in bins]\n    for idx in eachindex(bins)\n        println(\"bin $(bins[idx]) count $(gt_bin[idx])\")\n    end\n    println(\"total $(length(observed))\")\nend\n\nshow_observed (generic function with 1 method)\n\nLet's do one run without importance sampling and print the results to see how  often the rare event happens. We'll see it's fairly rare.\n\nwith_logger(ConsoleLogger(stdout, Logging.Info)) do\n    observed, importance = run_epochs(100, false, Xoshiro(324923))\n    show_observed(observed)\nend\n\nbin 100 count 24\nbin 200 count 10\nbin 300 count 4\nbin 400 count 3\nbin 500 count 1\nbin 600 count 0\nbin 700 count 0\nbin 800 count 0\nbin 900 count 0\nbin 1000 count 0\ntotal 100\n\n\nIf we run it ten times with importance sampling, we can see how good the statistics get. I'm keepign the sample count low here because this is just documentation.\n\nfunction variations(var_cnt, N)\n    prob_over_1000 = zeros(Float64, var_cnt)\n    fraction_over = zeros(Float64, var_cnt)\n    rng = Xoshiro(234291022)\n    for pidx in eachindex(prob_over_1000)\n        observed, Δ = run_epochs(N, true, rng)\n        # Use log-space trick to avoid summing a bunch of zeros and extremely small numbers.\n        importance = exp.(Δ .- maximum(Δ))\n        # This is the self-normalized estimator.\n        prob_over_1000[pidx] = sum((observed .>= 1000) .* importance) / sum(importance)\n        # The unbiased estimator uses 1/N.\n        # prob_over_1000[pidx] = sum((observed .>= 1000) .* importance) / N\n        fraction_over[pidx] = count(x -> x > 1000, observed) / length(observed)\n        println(\"mean weight $(mean(importance))\")\n        println(\"ESS $(sum(importance)^2 / sum(importance.^2))\")\n    end\n    println(\"fraction_over\")\n    println(join([@sprintf(\"%.2g\", x) for x in fraction_over], \", \"))\n    println(\"probability_over\")\n    println(join([@sprintf(\"%.2g\", x) for x in prob_over_1000], \", \"))\nend\nvariations(10, 1_000)\n\nmean weight 0.2566300184812529\nESS 511.9748480113073\nmean weight 0.1905958987266816\nESS 506.36275649675315\nmean weight 0.11366514004791889\nESS 506.2152568608388\nmean weight 0.2133992871985636\nESS 480.309887500895\nmean weight 0.16420703346743035\nESS 504.23611641260646\nmean weight 0.22494785552831026\nESS 504.70217642446266\nmean weight 0.21517063061396302\nESS 484.4704360099825\nmean weight 0.22555949607782808\nESS 501.1609987939006\nmean weight 0.14096564626827154\nESS 483.00195848975915\nmean weight 0.23539199565011704\nESS 503.21950859650894\nfraction_over\n0.056, 0.061, 0.067, 0.069, 0.066, 0.068, 0.067, 0.076, 0.081, 0.071\nprobability_over\n0.00018, 0.00021, 0.00033, 0.0003, 0.00018, 0.00037, 0.00034, 0.00022, 0.00017, 0.00031\n","category":"section"},{"location":"gene_expression/#References","page":"Gene Expression","title":"References","text":"Zong, Chenghang, Lok‐hang So, Leonardo A Sepúlveda, Samuel O Skinner, and Ido Golding. “Lysogen Stability Is Determined by the Frequency of Activity Bursts from the Fate‐determining Gene.” Molecular Systems Biology 6, no. 1 (2010): 440. https://doi.org/10.1038/msb.2010.96.\nRaj, Arjun, and Alexander Van Oudenaarden. “Nature, Nurture, or Chance: Stochastic Gene Expression and Its Consequences.” Cell 135, no. 2 (2008): 216–26. https://doi.org/10.1016/j.cell.2008.09.050.\nCai, Long, Nir Friedman, and X. Sunney Xie. “Stochastic Protein Expression in Individual Cells at the Single Molecule Level.” Nature 440, no. 7082 (2006): 358–62. https://doi.org/10.1038/nature04599.\nHorowitz, Jordan M, and Rahul V Kulkarni. “Stochastic Gene Expression Conditioned on Large Deviations.” Physical Biology 14, no. 3 (2017): 03LT01. https://doi.org/10.1088/1478-3975/aa6d89.\nMcAdams, Harley H., and Adam Arkin. “Stochastic Mechanisms in Gene Expression.” Proceedings of the National Academy of Sciences 94, no. 3 (1997): 814–19. https://doi.org/10.1073/pnas.94.3.814.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"commonrandom/#Common-Random-Numbers","page":"Common Random Numbers","title":"Common Random Numbers","text":"","category":"section"},{"location":"commonrandom/#Introduction","page":"Common Random Numbers","title":"Introduction","text":"If you set up the same model and run it with different initial random number generator (RNG) states, then it will create a set of trajectories. CompetingClocks sees these as a sequence of clock events and times of those events. You are usually interested in some summary outcomes of a simulation, such as the total time to a goal or the number of events. This summary outcome is a predictable function of the trajectories. We often want to ask how the goal function depends on simulation parameters, and that can be difficult to determine because each trajectory gives an individual value, and the set of trajectories gives an estimate that can have wide variance.\n\nWhat we want is a variance reduction technique. Common random numbers (CRN) are a variance reduction technique that enables you to use fewer simulation runs to compare the effect of different simulation parameters on the outcome. There are several other variance reduction techniques, such as antithetic variates and importance sampling, but let's look at common random numbers in CompetingClocks.\n\nIf you estimate a value with n independent trajectories, then the bias of the estimate is proportional to 1sqrtn in most cases. If you want to distinguish the effect of changing a parameter, then the estimate must be precise enough that you can see the difference. It is common to use millions of trajectories. On the other hand, CRN means that you can produce n=100 trajectories, with significant bias in the estimate, and still see the effect of changing a parameter.\n\nCRN works well when the sample path is similar from run to run. If two runs use completely different events, then there will be too little overlap. If the causal chain of which events affect other events changes, that can be a problem, too. In most cases, people try CRN and see if it helps.","category":"section"},{"location":"commonrandom/#Using-Common-Random-Numbers-in-CompetingClocks","page":"Common Random Numbers","title":"Using Common Random Numbers in CompetingClocks","text":"CompetingClocks implements common random numbers by recording the state of the random number generator every time a clock is enabled. There are other ways to do this, but this one works with the CombinedNextReaction and FirstToFire samplers. The workflow you would use looks notionally like:\n\nCreate a sampler with the keyword argument common_random=true.\nRun a lot of simulations in order to explore and record all possible clock states. Run reset!(recorder) after each simulation.\nFor every parameter set to try, run it the same way, using reset! after each run.\nCompare outcomes.\n\nBecause the CommonRandom stores the state of the random number generator at each step, it works best with random number generators that have small state, such as Xoshiro on a linear congruential generator (LCG).\n\nusing Random: Xoshiro\nusing CompetingClocks\nexample_clock = (3, 7)  # We will use clock IDs that are a tuple of 2 integers.\nmodel = MakeModel()\n(Key, Time) = (typeof(example_clock), Float64)\nbuilder = SamplerBuilder(Key, Time; common_random=true)\nrng = Xoshiro(9469922)\nsampler = SamplingContext(builder, rng)\nfor trial_idx in 1:100\n    run_simulation(model, sampler)\n    reset!(sampler)\nend\nfreeze_crn!(sampler)\nfor param_idx in 1:10\n    each_model = modify_model!(model, param_idx)\n    run_simulation(each_model, sampler)\n    reset!(sampler)\nend","category":"section"},{"location":"commonrandom/#Checking-effectiveness-of-Common-Random-Numbers","page":"Common Random Numbers","title":"Checking effectiveness of Common Random Numbers","text":"If your simulation has a large sample space, CRN may not help. We run a first set of simulations in order to record the state of the system for lots of different clocks and different multiplicities of clock events. If that worked well, then subsequent runs of the simulation will re-use draws from the random number generator. If there are a lot of events which are needed but haven't been recorded, those misses are a sign that CRN is unlikely to reduce variance much for this simulation.\n\nWe check this by checking the misscount during later runs of the simulation under CRN. If that miss count is high, we can look into which clocks are firing that didn't previously fire by iterating over the misses, which are pairs of (clock key, number of misses for that clock).\n\nThe final word on effectiveness of CRN is to look at the variance of summary outcomes for runs with and without CRN. The CRN will, in general, slow down a sampler, but it should mean that many fewer runs are required to distinguish the effect of changes in system parameters.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"hamiltonianmontecarlo/#Hamiltonian-Monte-Carlo","page":"Hamiltonian Monte Carlo","title":"Hamiltonian Monte Carlo","text":"There is an excellent paper that shows how to do Hamiltonian Monte Carlo using the likelihood of a path of a simulation. The core idea is that, while you set up the sequenece of events and define distributions for when next events happen, you don't have to run the simulation. You can instead let an HMC sampler choose times for events in the system.\n\nWith this package, that means the HMC updates a list of events, like:\n\nevents = [(evt=(:infect, 0, 1), time=0.1), (evt=(:infect, 0, 3), time=0.15)...] \n\nThen you pass that event list into a likelihood calculator.\n\nfunction one_epoch(model, sampler, events_list)\n    for idx in eachindex(events_list)\n        which = events_list[idx].evt\n        when = events_list[idx].time\n        step_model!(model, sampler, which, when)\n    end\n    return pathloglikelihood(sampler, time(sampler))\nend\n\nThen use that likelihood to guide the next round of HMC. Using this simulation-plus-sampler setup is much easier than working out the math of non-Exponential distributions.\n\nBillig, E. M., Roy, J. A., Ross, M. E., Dolgert, D. J., & Levy, M. Z. (2015, October). \"A Bayesian model for identifying and predicting the dynamics of urban insect infestations,\" in American Journal OF Tropical Medicine and Hygeine (Vol. 93, No. 4, pp. 537-537).","category":"section"},{"location":"reliability/#Reliability-Model-of-a-Work-Crew","page":"Reliability","title":"Reliability Model of a Work Crew","text":"This is an extended example using a reliability model.\n\nusing ColorSchemes\nusing Distributions\nusing CompetingClocks\nusing Logging\nusing Plots\nusing Random\nusing StatsPlots","category":"section"},{"location":"reliability/#Overview","page":"Reliability","title":"Overview","text":"The classic model for reliability is of a machine that is either working or broken. There is a distribution of failure times and a distribution of repair times [1]. Let's extend this idea to the reliability of a vehicle motor pool.\n\nThere are 16 vehicles.\nEvery morning, 10 vehicles go out for work. They all leave in the first 15 mins.\nEach vehicle works at least half a day, at most the whole day.\nWhile working, a vehicle can break, where the chance of breaking depends on the total time since it was last repaired.\nThere is a distribution of repair times.\n\nNumber two, above, says that vehicles start in the first 15 minutes. This plan will initiate ten transitions in rapid succession. We could, instead, start all ten vehicles at the same time, using a single transition. Either would work.\n\nCompetingClocks will take care of the timing of all of the events, but we will see that there is plenty of work to track the state of all of the vehicles. This extended example shows that, if we wanted to create more reliability models, it would make sense to create a framework for reliability modeling, one that uses CompetingClocks underneath.","category":"section"},{"location":"reliability/#Define-State-for-the-Model","page":"Reliability","title":"Define State for the Model","text":"If we think about an individual vehicle, the states are ready, working, or broken.\n\n@enum IndividualState ready working broken\n\nThere are four allowed tansitions among the three states because a vehicle breaks only while it's working.\n\nconst IndividualTransitions = Dict(\n    :work => (ready, working),\n    :done => (working, ready),\n    :break => (working, broken),\n    :repair => (broken, ready)\n);\n\nAn individual has state and parameters. In the language of generalized semi-Markov processes, this state is called the physical state in order to distinguish it from the state of each enabled transition for each vehicle.\n\nmutable struct Individual\n    # State for the individual\n    state::IndividualState\n    work_age::Float64 ## How an individual remembers its total work leading to breaks.\n    transition_start::Float64  ## This is bookkeeping.\n    # Parameters for the individual\n    done_dist::LogUniform\n    fail_dist::LogNormal\n    repair_dist::Weibull\n    Individual(work, fail, repair) = new(\n        ready, 0.0, 0.0, work, fail, repair\n        )\nend\n\nThe simulation as a whole is the state of the individuals and the system time. We put some parameters here:\n\nworkers_max - Each morning, this many vehicles start driving, if at least this many vehicles are ready, instead of broken.\nstart_time - Vehicles start in the first 15 min or so, and this is that 15 min.\n\nmutable struct Experiment\n    time::Float64\n    group::Vector{Individual}\n    # Each day the group tries to start `workers_max` workers.\n    workers_max::Int64\n    start_time::Float64\n    rng::Xoshiro\n    Experiment(group::Vector, crew_size::Int, rng) = new(0.0, group, crew_size, 0.01, rng)\nend\n\nMake a simulation by making individuals.\n\nfunction Experiment(individual_cnt::Int, crew_size::Int, rng)\n    done_rate = LogUniform(.8, 0.99) # Gamma(9.0, 0.2)\n    break_rate = LogNormal(1.5, 0.4)\n    repair_rate = Weibull(1.0, 2.0)\n    workers = [Individual(done_rate, break_rate, repair_rate) for _ in 1:individual_cnt]\n    Experiment(workers, crew_size, rng)\nend\n\nMain.var\"##293\".Experiment\n\nAnd make some helpers. The key_type says that we will track transitions using a tuple of (index of vehicle, symbol to identify the transition).\n\nkey_type(::Experiment) = Tuple{Int,Symbol};\nworker_cnt(experiment::Experiment) = size(experiment.group, 1);","category":"section"},{"location":"reliability/#Define-Transitions-for-the-Model","page":"Reliability","title":"Define Transitions for the Model","text":"If we were modeling one individual, transitions would be very simple, but by asking that ten vehicles work every morning, we require that those individuals interact.\n\nOne way to think clearly about interactions is to think about the state of the whole system. If less than ten vehicles are currently working, then every ready vehicle must have an enabled transition to start work at the next available time. Once the tenth vehicle begins working, all of those transitions need to be disabled.\n\nIt's implied that the start of each day happens at 1.0, 2.0, 3.0, etc. When a vehicle becomes ready, or when the total working vehicles drops below ten, then each ready vehicle could work at a future time. This function takes in the current time and returns two times, relative to the current time, between which the vehicle can start work.\n\nfunction next_work_time(now, fifteen_minutes)\n    hour = now - floor(now)\n    if hour < fifteen_minutes ## If vehicles are still going out today.\n        return 0.0, fifteen_minutes - hour\n    else ## You can't start until tomorrow.\n        return one(hour) - hour, one(hour) + fifteen_minutes - hour\n    end\nend;\n\nNow we handle simulation events. This function's complexity is an argument for using a framework like a queueing model, a generalized stochastic Petri net, or some other continuous-time simulation framework.\n\nThe arguments are:\n\nwhen - The time of the next event.\n(who, transition) - This expands the key_type, which identifies the transition.\nexperiment - It's our simulation data.\nsampler - This is a CompetingClocks.SSA from CompetingClocks to enable and disable transitions.\n\nThe first few statements of the function are automatic for any transition. Then this handler works through the transition types.\n\nfunction handle_event(when, (who, transition), experiment, sampler)\n    start_state, finish_state = IndividualTransitions[transition]\n    individual = experiment.group[who]\n    @assert individual.state == start_state\n    individual.state = finish_state\n    experiment.time = when\n    disable!(sampler, (who, transition), when)\n\n    # If a vehicle is done work, or if they break, then include the time worked\n    # in their total work age.\n    if start_state == working\n        work_duration = when - individual.transition_start\n        @debug \"Adding $work_duration to $who\"\n        individual.work_age += work_duration\n    end\n\n    # The state of the system, as a whole, depends on the total number\n    # currently working.\n    worker_cnt = count(w.state == working for w in experiment.group)\n    need_workers = worker_cnt < experiment.workers_max\n    max_hour = experiment.start_time\n\n    # When an individual was working, there were two possible transitions,\n    # one to `ready`, and one to `broken`. Don't forget to disable the `:break`\n    # transition. Then schedule the next day's work only if the system has less\n    # than ten working.\n    if transition == :done\n        disable!(sampler, (who, :break), when)\n        if need_workers\n            rate = Uniform(next_work_time(when, max_hour)...)\n            enable!(sampler, (who, :work), rate, when, when, experiment.rng)\n            @debug \"schedule $who for $rate\"\n        end\n\n    # A `:repair` transition can happen at any time, including during the first\n    # fifteen minutes of a day.\n    elseif transition == :repair\n        if need_workers\n            rate = Uniform(next_work_time(when, max_hour)...)\n            enable!(sampler, (who, :work), rate, when, when, experiment.rng)\n            @debug \"schedule $who for $rate\"\n        end\n\n    # The `:work` transition represents a vehicle going out to work for the day.\n    # This enables two possible transitions, finishing work or breaking. The\n    # breaking transition is interesting because it has what Zimmerman [2] calls\n    # \"memory.\" It remembers how long it was previously enabled\n    elseif transition == :work\n        # enable :done and :break\n        enable!(sampler, (who, :done), individual.done_dist, when, when, experiment.rng)\n        # Time shift this distribution to the left because it remembers\n        # the time already worked.\n        past_work = when - individual.work_age\n        enable!(sampler, (who, :break), individual.fail_dist, past_work, when, experiment.rng)\n        @debug \"schedule $who for done or break\"\n\n    # When a vehicle breaks, the only option is to repair it. This resets the work age.\n    elseif transition == :break\n        # If you broke, you don't get to finish your work.\n        disable!(sampler, (who, :done), when)\n        individual.work_age = zero(Float64)\n        enable!(sampler, (who, :repair), individual.repair_dist, when, when, experiment.rng)\n        @debug \"schedule $who for repair\"\n\n    else\n        @assert transition ∈ keys(IndividualTransitions)\n    end\n    individual.transition_start = when\n\n    # We haven't handled how we ensure that at most ten vehicles start work every\n    # morning. For that, we need to think about the system as a whole, explicitly\n    # by looking at the current worker count and whether it crossed the threshold of\n    # ten workers.\n    #\n    # If a vehicle just started and is the tenth worker, then cancel the ability of\n    # all other vehicles to work.\n    if transition == :work && worker_cnt == experiment.workers_max\n        notnow = Int[]\n        for too_many in [widx for (widx, w) in enumerate(experiment.group) if w.state == ready]\n            # You don't start today.\n            disable!(sampler, (too_many, :work), when)\n            push!(notnow, too_many)\n        end\n        @debug \"Unscheduling $notnow\"\n\n    # If a vehicle stopped work, either by finishing or breaking, and it was the\n    # first of the work crew to quit, then notify all `ready` vehicles that they\n    # should start work at the start of the next morning.\n    elseif transition ∈ (:done, :break) && worker_cnt == experiment.workers_max - 1\n        rate = Uniform(next_work_time(when, max_hour)...)\n        upnext = Int[]\n        for next_chance in [widx for (widx, w) in enumerate(experiment.group) if w.state == ready]\n            if next_chance != who\n                enable!(sampler, (next_chance, :work), rate, when, when, experiment.rng)\n                push!(upnext, next_chance)\n            end\n        end\n        @debug \"scheduling $upnext for $rate\"\n    end\nend;","category":"section"},{"location":"reliability/#Configure-the-Model","page":"Reliability","title":"Configure the Model","text":"For anything other than an example, the most important step would be configuring the model so that it matches observations. Here, however, we have put this directly into the Experiment type. Here is a plot of the distributions.\n\nfunction show_distributions()\n    experiment = Experiment(16, 10, Xoshiro(9378424))\n\n    plot(experiment.group[1].done_dist, label=\"Done\")\n    plot!(experiment.group[1].fail_dist, label=\"Break\")\n    plot!(experiment.group[1].repair_dist, label=\"Repair\")\n    title!(\"Distributions for Transitions\")\nend\nshow_distributions()\n\n<img src=\"data:image/png;base64,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feedd6xWK3dy0F25+O3ijpJWD9QH3JTe3t7Dhw//9NNP9+/fTxy+89CkIQjhDoZhfvnll6FDh5pMpsmTJ9cyO5rTKALyVxpxw8AJIdyJebm5uQ9e1apVqxx7e//+97/LysqGDh1q/0XPDU7fs2ePvY3JZOLGbzji9vTes6T27dt37tw5Jyfnp59+si9kGIb74c+dbeu66h+UUqmUyWQ2m62uvxK4MS2rV692nPH1+PHjiYmJKpWq9iEo9YvbWeo4K6zRaPz444/vY1U2m636BLZO36XquE2Zl5dX+8qHDx/u5eW1Z8+eCxcu2BdqNJovv/yS1Mem5MqopU5oQjAIhr+2bt3Kna2n1WoLCwtPnjzJjQObPn06N0qhJn379u3QocPYsWOjoqJ8fHwyMjLee+89Qoh9/1hoaGhoaOjx48dnz57dqVMnsVjcs2dP+zw1dZKbmztp0qTXXntNqVTu3r373XffFYvFH330kb3BlClT1qxZ884777As26NHj+zs7OXLl1ssFqf1dO/enaKozz//3Gw2h4WF0TQ9bty4u8638sknnwwfPvz5558vKioaNmxYWVnZqlWrkpKSOnbsOGvWrDoV/9Zbb507d27atGkdOnQIDQ3Nz8//+uuvi4uLH3300eoHpWo3YsSIYcOG7du3b8iQIe+++25YWNjJkyffeustQsjHH39c17U9iEGDBm3fvn3GjBkrVqzo2LFjZmbmfR8qq6qqioqKmjZtWkJCQuvWrWmaPn369KJFi2ia5oL/rnr06EEIee211y5cuMBtwWeffdZxXiGOUql8//33X3/99REjRixZsiQ+Pj4rK+u9994rKCgYN25cTUMVazJ69GilUjlhwoQ2bdqo1err169zX8L73icMjYtHB2+AZ1T/OUzTdLt27Z599tmTJ09Wb+80jnDkyJFOf3e4KxXYbDb7U/744w/HuaycZpap/hI1jSNMSUlp2bKlfT1KpXL79u1Oz/3www8dT/IcPHgwNxuA4zhClmU//fRTx+SrZWaZbdu2OZ2WMmjQoPz8fMc23MwyTpVs2bKFEPLmm29yd5ctW1Z97MHo0aNLS0urfwJ2dx1HyC2fMmWK40FKhULx+eefO7bhRt198skntaz/rmoaR5iamurU0mKxOM0rFB8fz+2z7d27t70ZN47wiy++cHq647hPjUZTfdIfPz+/DRs2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BCF2jQIAuFNycvKvv/66a9cuQkh0dPS5c+dGjBhBCDl79mxYWJhcLr/rs1QqVWho6KhRox555BG3lnsvzSIIpVQprsQEANCQrl69umzZMr1en5aWtmfPnsWLFw8dOpQQ8vrrr48dOzYgIECpVC5YsOCtt96qZSXLli2bMWPGokWLwsPDMzMzdTrd66+/7q53UKPmEIRSARFSRGshCpGnSwEAaI769eun0+nKy8uVSuW4ceO+/PLL4OBg+0O///77hg0bDAbDZ599NmbMGEJIcHDw888/b3/6jBkzwsLCCCHTpk2Lioratm3b4cOHIyIiJk2a5JG346Q5BCH5q1OoEN3j6C4AANyHhISEhISEmh7t3r179+7dHZe0aNFi/vz59ruvvvqq/XafPn0a22WHm8M4QkKIn4SU4HwZAACou2YShP5SUorzZQAAoO6az67REiNLCHaNAgDUv4KCgvz8fEKIRCJp2bKlj4/PA67w6tWr+/fvf+mll+qjugfVXHqE2DUKANBgvvvuu8GDB8+aNWv69Onh4eFz5szhRs3ft5s3b/73v/+tr/IeUDMJQj8pKcUlCQEAGgw36fbZs2fT0tK++eab8+fP2x9iGOb69ev2ybULCwudJhE1m803b95sJDOLVtdMgtBfSpXgGCEAQMNTqVRCoZDrEa5atWr48OG9evWaMGHCgQMHLl++3KVLl9GjR/fs2XPixIkmk4kQsnnz5vbt2//jH//o0qXLpEmTrFar49psNtvs2bOHDRum0Wg8836azTFC7BoFgObKWlpgyc105ysK1IHilu2cFp47d27WrFlmszk5OXnu3LndunXjlh8/fjw1NTUqKophmG7dui1YsOCJJ55gGGbixIlff/31vHnzEhISrl27JhAIrFbr0KFDt2zZ8sQTT3DP1el0U6ZMCQwM3L17t1DosTxqLkEopUqMmHcbAJoha1GePjXJna8oiexYPQgDAgIGDx5stVpDQkI2bdr03HPPcXONJiQkREVFEUJu3ryZkZEhEAi2bNlCCAkNDU1KSpo3b56vr++GDRvOnj1rNBorKysvXLjABWF5efmgQYPGjh27cOFCd7676ppJEAbIyG30CAGgOZJ27CHt2MPTVZCwsLCJEycSQp544omMjIyvvvpqxYoVhBC1Ws01KCsrE4lEN2/etLfnBs7PnTs3Ly/v+eefDwwM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rPdeuRPWYmadwpIQQlhiMRmsRitb7SGWcbrUifPjNithbLU0cGa1EOYueVsnrM1CbDYbyxhYy71bNwyL1Spy+InAWGv7lPhAzApoubc7jw0IZH/nRX39sXI1CENDQwsKCrjbBQUFwcHBNb18QEBA7969Fy5c6OKapa07itp1Edb+8xPchaIoiqJEogY5J6hpUYsaxfW5NBqNt3fT/knRnGBzNCoikahe/li5mqXDhw//7bffuNs7duwYPnz4g782AACAx7naD3v++ed79OgxZcoUHx+fX3/99fjx4w1aFgAAgHu42iMMDAxMTU0dPnx49+7dL1y40LZt2/qqYM+ePRcvXqyvtcEDSk1N/f333z1dBdxRXFzczMYpNWkMw6xcudLTVcDfvv76a6327sfy66QOhxlVKtVTTz313HPPhYTU54X09uzZc+rUqXpcITyIP//8c9++fZ6uAu7IzMz86aefPF0F3GE0GlesWOHpKuBv3333XX5+/oOvBwOBAQCA1xCEAADAawhCAADgNYq925waD2LmzJnbtm2zD6i/p5KSEolEgqE5jYRGozGbzX5+fp4uBAghxGQylZaWhoaGeroQIIQQlmVzcnJatbr75Pjgfnl5ecHBwbUPQ586deqHH35Y+3rqPwhNJlN2drbrA+QtFotAIKivmWXgAdlsNpZlMb9B42EymSSSRnF5ECDYHI2MK5sjJCTEcW6mu6r/IAQAAGhC0A8DAABeQxACAACvIQgBAIDXEIQAAMBrHj458PTp01u2bJHL5U8//TROSvas69evHzp0yH53zJgx9TuXHtwTwzBXr149e/asVqudOXOm4yU/Dx06tHv37sDAwBkzZtRymWuoX4WFhSkpKfn5+UOGDImMjOQWpqenJyUl2duMHz/e39/fQwXyy8WLF/fu3VtYWBgdHT1t2jSF4s6ls/V6/bfffpudnd2nT5+JEyfex5o92SNMSkoaPHhwQECARqPp0aNHYWGhB4uB06dPL1269MZfjEajpyvinVOnTg0cOHDNmjWzZs1iHK6j+/PPP0+dOjUiIuLq1at9+vTR6+t8YV64P3379l26dOkbb7xx9uxZ+8KjR4+uWrXK/i/FZDJ5sEL+YBhm8ODBeXl5LVu23L59e8+ePXU6HffQqFGj9u/fHx0dvWjRonsOGbw71nNGjRq1ZMkS7vaECRPef/99DxYDGzduHDp0qKer4DVuEOfVq1cJIVar1b68c+fOP/74I3e7R48e69at80x9/MNtkY4dO27dutW+cO3atRMmTPBcUfxlMBi4G2azOSQkZNeuXSzLHj9+3N/f32g0siybkpKiUqn0en1d1+zJHmFiYuLQoUO520OGDElMTPRgMUAIyc/PX7ly5b///e+ioiJP18JHd51Wory8/OLFi4MHD+bu4l+KO9U00Ud2dvaKFSu+//770tJSN5fEZ1Kp1H7baDRyu0YTExMffvhhblh9fHw8TdMXLlyo65o9FoQajUar1dqPdgQGBhYUFHiqGCCEeHt7d+nSpaKiYseOHe3bVsQHagAAAxVJREFUt3fcFwQeVFBQQNO0/ShUUFBQvVx3Bu6bUqns2LFjZWXl1q1b27Vrd+XKFU9XxDuLFi3q0KHDgAEDCCEFBQWOR80DAwPv4x+Ix06WEYlEhBCr1crdtVqtYrHYU8UAIWTUqFGjRo3ibr/yyivvvffezp07PVsSEEJEIhHDMDabjeudWCwWTPHlWRMnTrSfkfHss89+8MEHGzdu9GxJvLJu3bqffvopKSmJ+xchEokcT2iwWCz3ESUe6xFKpVK1Wn3r1i3u7q1btzCzcOPRt2/fGzdueLoKIISQkJAQiqLsP3Jv3bqFs3kbD/xLcbP//Oc/ixcvPnz4sH2UQWhoqD1HrFZrUVHRfUSJJ48RPvroo1u2bCGEMAyzbdu2MWPGeLAYMBgM3A2WZXft2hUTE+PZeoCjUCgGDRq0detWQojRaNy5c+ejjz7q6aJ4zd7/YBhm9+7d+JfiNps3b3777bf37dsXFRVlXzhmzJikpKTi4mJCyL59+9RqdWxsbF3X7MlJt69evfrQQw89/PDDxcXFVVVVSUlJXl5enioGHnvsMY1G06JFi4sXL2o0mv379zt+28ANdDrdww8/bDKZLl26FBcXp1KpDh48SAg5ceLEo48+OmLEiPT0dLVavWfPHoFA4OlieWH27NmnT59OS0sLDQ1VqVTfffdd165dhwwZQggJDg4+d+6c1Wo9ePBgWFiYpytt/qqqqtRqdXBwcHBwMLdk/vz5kyZNIoS88MILBw8e7N+//65duz7//PMpU6bUdeUevvpEeXn5wYMHFQpFQkICjnx4Vnl5eXJycllZWWhoaJ8+fXDI1v1sNltqaqr9rlAo7NKlC3e7oKAgKSnJ399/4MCBSEG3uXr1qkajsd9t166dQqEoLS1NTk6uqKgICwvr06cPrlnmHk7/Oggh4eHhgYGB3O0TJ05kZ2f36NGjTZs297FyXIYJAAB4DXONAgAAryEIAQCA1xCEAADAawhCAADgNQQhAADwGoIQAAB4DUEIAAC8hiAEAABeQxACAACvIQgBAIDXEIQAAMBr/w9AdjbO1dbkVQAAAABJRU5ErkJggg==\" />\n\nThe short blue line in the upper-left is the probability distribution function for a LogUniform distribution that represents the time a vehicle drives on a single day. You can see that these vehicles break about once a week and take a couple of days to repair, on average.","category":"section"},{"location":"reliability/#Run-the-Simulation","page":"Reliability","title":"Run the Simulation","text":"Running a simulation means we are sampling from the stochastic process. For a continuous-time stochastic process like this, that means asking the sampler when the next transition is and which transition it is. If there are no possible transitions, the next time will be infinite and the chosen transition will be nothing.\n\nfunction run(experiment::Experiment, observation, days)\n    sampler = FirstToFire{key_type(experiment),Float64}()\n    rng = experiment.rng\n    rate = Uniform(next_work_time(0.0, experiment.start_time)...)\n    for initial in 1:length(experiment.group)\n        enable!(sampler, (initial, :work), rate, 0.0, 0.0, rng)\n    end\n    when, which = next(sampler, experiment.time, rng)\n    while isfinite(when) && when < days\n        # We use different observers to record the simulation.\n        observe(experiment, observation, when, which)\n        @debug \"$when $which\"\n        handle_event(when, which, experiment, sampler)\n        when, which = next(sampler, experiment.time, rng)\n    end\nend\n\nrun (generic function with 1 method)","category":"section"},{"location":"reliability/#Observers","page":"Reliability","title":"Observers","text":"Without care, data collection from continuous-time simulation can generate a lot of data quickly. In many cases, especially for performance analysis, not every event time and transition is important. Therefore, to avoid saving the raw data stream, we use observers of the system to summarize that data. Construction of observers is important as it connects the simulation to tools or analyses that may be used to guide decision-making. It also identifies which variables and metrics are most important.\n\nLet's look at a few examples for the vehicle crew.","category":"section"},{"location":"reliability/#Continuous-time-Summary-Observer","page":"Reliability","title":"Continuous-time Summary Observer","text":"The first example will record data at every transition, but it will record only the total number of working or broken vehicles.\n\nThis represents a single time point.\n\nstruct ContinuousRec\n    working::Int64\n    broken::Int64\n    total_age::Float64\n    time::Float64\nend\n\nThe observer stores a vector of those single time points.\n\nmutable struct ObserveContinuous\n    state::Vector{ContinuousRec}\n    ObserveContinuous() = new([ContinuousRec(0, 0, 0.0, 0.0)])\nend\n\nThis observer keeps a running sum of the number working and broken. Note that it has to know how different transitions change those numbers. The relationship between the transition and how it changes counts is called stochiometry (or stoichiometry), because it was first observed for chemical simulations. Both chemical simualtions and GSPN would have this information encoded in a formal model.\n\nfunction observe(experiment::Experiment, observation::ObserveContinuous, when, which)\n    who, transition = which\n    working = observation.state[end].working\n    broken = observation.state[end].broken\n    if transition == :work\n        working += 1\n    elseif transition == :done\n        working -= 1\n    elseif transition == :break\n        broken += 1\n        working -= 1\n    elseif transition == :repair\n        broken -= 1\n    else\n        @assert transition ∈ (:work, :done, :break, :repair)\n    end\n    total_age = sum(w.work_age for w in experiment.group)\n    push!(observation.state, ContinuousRec(working, broken, total_age, when))\nend;\n\nThis plot shows a timeline of the count of working and broken vehicles over five days.\n\nfunction plot_timeline(obs::ObserveContinuous, experiment::Experiment)\n    state = obs.state\n    last_time = state[end].time\n    first_idx = findlast([x.time < last_time - 5 for x in state])\n    times = [x.time for x in state[first_idx:end]]\n    times .-= 4009\n    working = [x.working for x in state[first_idx:end]]\n    broken = [x.broken for x in state[first_idx:end]]\n    ready = [worker_cnt(experiment) - x.working - x.broken for x in state[first_idx:end]]\n    plot(times, working, label=\"working\", line=(:steppost, 2))\n    plot!(times, broken, label=\"broken\", line=(:steppost, 2))\n    xlabel!(\"Time [days]\")\n    ylabel!(\"Status [count]\")\n    title!(\"Timeline of Work Crew Over Five Days\")\nend\n\nfunction show_typical_timeline()\n    rng = Xoshiro(9234232)\n    years = 11\n    day_cnt = 365 * years\n    worker_cnt = 16\n    experiment = Experiment(worker_cnt, 10, rng)\n    observation = ObserveContinuous()\n    run(experiment, observation, day_cnt)\n\n    plot_timeline(observation, experiment)\nend\nshow_typical_timeline()\n\n<img src=\"data:image/png;base64,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j7pavHjxrl27PD0958yZY16uUqleeumlwsLCNWvW/Pnnn76+vs8995x5BbbGzp8/3/xMGFNYWGhxaNSmWIZeu3at1YT98ssvOzo6rlu3jp1/NScIQjmrejmOHz8eGhp6/fr11q1bs8su6b/RACkpKeY1169fbzV1eXh4DBky5PLly2yAzGuvvWb+aemolEol63dKaPiMfQarQhkqe/mE+cXOgiCw50J07drV4uvsojHThRZGo5GN+2/VqtX333/PnmYQERExbdo0T09P06XQFb+g3mJ2ERERRPTOO++YSnbv3q1QKBwcHN5+++3du3fHx8fv2bNn+fLlTz755Lx588ppkMTERDc3N47jZs6ceeLEibi4uKlTpxKRh4fH9evXTdUqfvkEYxpXaTEiXxAE0yZ48ODB5uVHjx5VKpUqlerDDz88c+bM4cOHhw4dSkQNGjQwv5yAXVBfeo6lL6hfunQpx3ENGjRITEwsP9qIiAg2SKdz585ffPHFrl27duzYsXLlStaX7du3L6tmuqDe4us8z7/00ktE1Lx581WrVh09epTdnvT111/39vY2b0aj0Wg6WpuUlGQqN3Ug4uLiyg+VYVlTLpePHj168+bN+/fvX7NmDUuiTk5Oe/bsKf0V1ttj55tNF3qb6PX67t27E1H79u1/+umnuLi448eP//777xMnTnRzczNd+slGL2/cuLEiQVbqOkITnucbNWqkUChUKlXdunVL342drYqenp4fffRRVFRUfHz89u3bP/roo6ZNm65Zs6aceFinv3379rNnz549e/b06dOHDx9uuu9ocHDwjRs3TJV1Oh27hcW0adNOnjwZHx/PdpgaNWpEZlcumRw/fpxNp1atWhb3ow8PD2/ZsuWyZcv27t176dKlY8eOsatFmzdv/vD3mn9UIBFWL+IkQkEQtFrtrFmzLA5zyeXykJAQ0wXIVZgIBUGIjo423c/JpF69ehEREeW3SVxcnGlUHvP444+zu3+ZVDYRstYja/cRZZ08Ivryyy8tPtq9e7fFabann37aPGEIlUmEgiCsWrVKJpPVq1fv8uXL5Qd84sSJ0r0xtVo9cuRIUwBlJUJBEPR6/XvvvWcxrEkul3fp0sXihgaDBg0iosDAQPNCNvrf/ILC+9q0aZP5LdyYkJCQcm6RYzpraHG9KVNcXDxt2jSLoVVKpbJ79+6mC9VF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\" />","category":"section"},{"location":"reliability/#Once-a-day-Observation-of-the-Working-State","page":"Reliability","title":"Once-a-day Observation of the Working State","text":"Suppose that we want to match our simulation to observation data that counts, every day, how many vehicles went out and how many were broken that morning. This observer records that status each day.\n\nmutable struct ObserveLots\n    status::Array{Int64,2}\n    started_today::Array{Int64,1}\n    total_age::Array{Float64,1}\n    broken_duration::Array{Float64,1}\n    ObserveLots(day_cnt, individual_cnt) = new(\n        zeros(Int64, 2, day_cnt),\n        zeros(Int64, day_cnt),\n        zeros(Float64, day_cnt),\n        zeros(Float64, individual_cnt)\n    )\nend\n\ndays(observation::ObserveLots) = size(observation.status, 2);\n\nThis observer waits until the current transition time is just after the first 15min of the day. Then it records every vehicle's status.\n\nfunction observe(experiment::Experiment, observation::ObserveLots, when, which)\n    who, transition = which\n    day_idx = Int(floor(when))\n    if transition == :work\n        observation.started_today[day_idx + 1] += 1\n    elseif transition == :repair\n        observation.broken_duration[who] += when - experiment.group[who].transition_start\n    end\n    day_start = Int(floor(experiment.time + next_work_time(experiment.time, experiment.start_time)[1]))\n    next_start = Int(floor(when + next_work_time(when, experiment.start_time)[1]))\n    if day_start != next_start\n        worker_cnt = count(w.state == working for w in experiment.group)\n        broken_cnt = count(w.state == broken for w in experiment.group)\n        work_ages = sum(w.work_age for w in experiment.group)\n        for rec_idx in day_start:next_start - 1\n            observation.status[1, 1 + rec_idx] = worker_cnt\n            observation.status[2, 1 + rec_idx] = broken_cnt\n            observation.total_age[1 + rec_idx] = work_ages\n        end\n    end\nend;\n\nNow we can use this observer to make a plot.\n\nfunction walk_simulation()\n    day_cnt = 20\n    experiment = Experiment(16, 10, Xoshiro(979798))\n    observation = ObserveLots(day_cnt, worker_cnt(experiment))\n    run(experiment, observation, day_cnt)\n    plot(1:day_cnt, observation.status[2, :], seriestype=:scatter, label=\"repair\",\n        yticks=0:2:10)\n    plot!(1:day_cnt, observation.status[1, :], seriestype=:scatter, label=\"working\")\n    title!(\"Number Working or in Repair\")\nend\nwalk_simulation()\n\n<img src=\"data:image/png;base64,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\" />","category":"section"},{"location":"reliability/#Distribution-of-Broken-Vehicles-and-Probability-of-Missing-Crew","page":"Reliability","title":"Distribution of Broken Vehicles and Probability of Missing Crew","text":"If we were focused more on the small probability that there wouldn't be enough vehicles in the morning to start a full ten, then we want to understand the histogram of how many vehicles are broken on any given day.\n\nmutable struct ObserveHistogram\n    counts::Array{Int64,2}\n    working::Int64\n    broken::Int64\n    burn::Float64\n    ObserveHistogram(e::Experiment, burn) = new(\n        zeros(Int64, e.workers_max + 1, worker_cnt(e) + 1), 0, 0, burn)\nend\nmust_work(o::ObserveHistogram) = size(o.counts, 1)\ntotal_workers(o::ObserveHistogram) = size(o.counts, 2)\n\nfunction observe(experiment::Experiment, observation::ObserveHistogram, when, which)\n    if when > observation.burn\n        day_start = Int(floor(experiment.time + next_work_time(experiment.time, experiment.start_time)[1]))\n        next_start = Int(floor(when + next_work_time(when, experiment.start_time)[1]))\n        if day_start != next_start\n            observation.counts[observation.working + 1, observation.broken + 1] += 1\n        end\n    end\n\n    who, transition = which\n    if transition == :work\n        observation.working += 1\n    elseif transition == :done\n        observation.working -= 1\n    elseif transition == :break\n        observation.broken += 1\n        observation.working -= 1\n    elseif transition == :repair\n        observation.broken -= 1\n    else\n        @assert transition ∈ (:work, :done, :break, :repair)\n    end\nend;\n\nThis observer will help us see what happens if we keep the same total number of vehicles but send more out each day for work.\n\nfunction compare_across_workers(obs::Vector{ObserveHistogram}, labels, title)\n    firstplot = true\n    cols = palette(:tableau_20, length(obs))\n    for (obs_idx, observation) in enumerate(obs)\n        worker_cnt = total_workers(observation)\n        broken = vec(sum(observation.counts, dims=1))\n        cnt = findlast(broken .> 0)\n        normed = broken[1:cnt] / sum(broken)\n        if firstplot\n            firstplot = false\n            plot(1:cnt, normed, color=cols[obs_idx], seriestype=:scatter, markersize=2.5, label=false)\n            plot!(1:cnt, normed, color=cols[obs_idx], label=labels[obs_idx], legendtitle=\"Crew Size\")\n        else\n            plot!(1:cnt, normed, color=cols[obs_idx], seriestype=:scatter, markersize=2.5, label=false)\n            plot!(1:cnt, normed, color=cols[obs_idx], label=labels[obs_idx])\n        end\n    end\n    xlabel!(\"Count of Broken\")\n    ylabel!(\"Probability Mass\")\n    title!(title)\nend\n\nfunction show_competition_effect()\n    rng = Xoshiro(4377124)\n    observations = ObserveHistogram[]\n    labels = String[]\n    years = 10\n    day_cnt = 365 * years\n    worker_cnt = 20\n    for must_work in [1, 5, 10, 15, 20]\n        experiment = Experiment(worker_cnt, must_work, rng)\n        burn = min(day_cnt ÷ 10, 3650)\n        observation = ObserveHistogram(experiment, burn)\n        run(experiment, observation, day_cnt)\n        push!(observations, observation)\n        push!(labels, string(must_work))\n    end\n\n    compare_across_workers(observations, labels, \"Number Broken as Crew Increases\")\nend\nshow_competition_effect()\n\n<img src=\"data:image/png;base64,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\" />","category":"section"},{"location":"reliability/#References","page":"Reliability","title":"References","text":"Limnios, Nikolaos, and Gheorghe Oprisan. Semi-Markov processes and reliability. Springer Science & Business Media, 2012.\nZimmermann, Armin. Stochastic discrete event systems. Springer, Berlin Heidelberg New York, 2007.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"integration-guide/#Integration-Guide","page":"Integration Guide","title":"Integration Guide","text":"How your code can use CompetingClocks.jl as a sampling engine.","category":"section"},{"location":"integration-guide/#Core-Integration-Pattern","page":"Integration Guide","title":"Core Integration Pattern","text":"CompetingClocks manages when events happen. Your framework manages what happens.\n\nYour framework provides:\n\nState representation\nEvent-handling logic\nA user-facing API\n\nCompetingClocks provides:\n\nEvent timing and scheduling\nDistribution sampling\nVariance reduction and likelihood calculation\n\nA minimal integration loop:\n\nfunction run_simulation(model, sampler, rng, end_time)\n    initialize_events!(model, sampler)  # Your code\n\n    when, which = next(sampler)\n    while !isnothing(which) && when < end_time\n        fire!(sampler, which, when)\n        handle_event!(model, sampler, which, when, rng)  # Your code\n        when, which = next(sampler)\n    end\nend","category":"section"},{"location":"integration-guide/#Design-Decisions","page":"Integration Guide","title":"Design Decisions","text":"","category":"section"},{"location":"integration-guide/#Clock-Key-Type","page":"Integration Guide","title":"Clock Key Type","text":"How will you identify events? CompetingClocks.jl indexes events using an immutable clock key that you provide. Examples:\n\n(:infect, infectious, susceptible) - Tuple{Symbol,Int,Int} or Tuple\n392 - Int64\n:i => 37 - A Pair for use with Gen.jl.\n\nA custom struct type for events works well. Using a concrete type is more performant for sampling.","category":"section"},{"location":"integration-guide/#Threading","page":"Integration Guide","title":"Threading","text":"This package doesn't use Tasks or thread guards because it is so common to run multiple copies of a simulation, each on its own thread. If you run multiple simulations, it can be more correct to use random number generators that work in parallel, such as those in the Random123 package or the jump!() method for the Xoshiro sampler in the Random package.","category":"section"},{"location":"integration-guide/#State-and-Dependencies","page":"Integration Guide","title":"State and Dependencies","text":"Your simulation handles all state. CompetingClocks only knows about enabled events. It can be very helpful for performance if you use information about relationships among events to limit updates to the samplers. There are a few kinds of dependency graphs that may help.\n\nDependency Graph–-When one event fires, it changes state. Which other events could be enabled or disabled because of the changed state?\nRate Dependency Graph–-When one event fires, it changes state. Which other events have transition rates that depend on that state? The event may remain enabled, but its distribution of firing times may have a different parameter value.\nEvent-to-event Graph–-When one event fires, you might know directly which other events have enabling rules or transition rates that depend on that first event, without needing to ask what state changed and what events depend on the state.\n\nHow you represent a dependency graph depends on the problem.","category":"section"},{"location":"integration-guide/#Common-Integration-Patterns","page":"Integration Guide","title":"Common Integration Patterns","text":"","category":"section"},{"location":"integration-guide/#Agent-based-Models","page":"Integration Guide","title":"Agent-based Models","text":"The clock key will identify an action and an agent, along with either another agent or a location.\n\nstruct ClockKey\n    action::Symbol\n    who::Int\n    other::Int # other agent or location\nend\n\nIt's also easy to use a Tuple as a ClockKey until you figure out the space of all possible keys.","category":"section"},{"location":"integration-guide/#Spatial-Simulation","page":"Integration Guide","title":"Spatial Simulation","text":"Split the sampler into groups so that each region is faster.\n\nbuilder = SamplerBuilder(EventKey, Float64)\nfor region in spatial_grid\n    add_group!(builder, region.name => (key, dist) -> key.location == region.id)\nend","category":"section"},{"location":"integration-guide/#Chemical-Reaction-Networks","page":"Integration Guide","title":"Chemical Reaction Networks","text":"Map reactions to events.\n\nfunction enable_reaction!(sampler, reaction, state, params)\n    propensity = calculate_propensity(reaction, state, params)\n    enable!(sampler, reaction.id, Exponential(1/propensity))\nend","category":"section"},{"location":"integration-guide/#Advanced-Features","page":"Integration Guide","title":"Advanced Features","text":"There is extra work in a simulation to support some of the sampler features.","category":"section"},{"location":"integration-guide/#Exposing-likelihood-calculation","page":"Integration Guide","title":"Exposing likelihood calculation","text":"The step log-likelihood and path log-likelihood can be found from the sampler at any point during a simulation. They are always calulated relative to the last event to fire!(), even if next() has been called.\n\nbuilder = SamplerBuilder(KeyType, Float64;\n    path_likelihood=true)\nsampler = SamplingContext(builder, rng)\n# After simulation, the log_prob is a Float64.\nlog_prob = pathloglikelihood(sampler, end_time)\n\nThe resulting value is the likelihood of a single trajectory of the system. The pathloglikelihood is a regular function and can be differentiated.","category":"section"},{"location":"integration-guide/#Variance-reduction","page":"Integration Guide","title":"Variance reduction","text":"Construct the sampler with the common_random option.\n\nbuilder = SamplerBuilder(KeyType, Float64; common_random=true)\nsampler = SamplingContext(builder, rng)\n\nRun the simulation a bunch of times, calling reset!() between runs to clear the sampler's memory of the previous run but save the common random numbers. Each run will pin more random draws. Then use freeze_crn! to stop collecting random draws.\n\nfor i in 1:warm_up\n    reset!(sampler)\n    results1 = run_simulation(model, sampler)\nend\nfreeze_crn!(sampler)  # Lock random draws\n\nReplay with different parameters.\n\nfor i in 1:draw_cnt\n    reset!(sampler) # Do this before each run with same sampler.\n    results2 = run_simulation(model, sampler)  # Uses same random draws\nend\n\nEach simulation copy also needs a copy of the state.\n\nIf you want to run these multithreaded, you can use clone() to copy the sampler to a vector and then use copy_clocks! to initialize all the samplers in the vector with the common random numbers that were just collected.\n\nmaster_seed = (0x3a97a224, 0x65ff9227)\ncommon_samplers = Vector{typeof(sampler)}(undef, clone_cnt)\nfor i in 1:clone_cnt\n    rng = Philox4x((0, 0, 0, init_idx), master_seed)\n    common_samplers[init_idx] = clone(sampler, rng)\nend\n# Run warm-up of common random numbers here, and freeze them.\nfor i in 1:clone_cnt\n    copy_clocks!(common_samplers[i], sampler)\nend\n\nThen run tasks on the clones of the frozen sampler.","category":"section"},{"location":"integration-guide/#Path-splitting-for-rare-events","page":"Integration Guide","title":"Path splitting for rare events","text":"This is a simple form of importance sampling. When a simulation gets near a space of interesting results, take the current trajectory and make multiple copies of the simulation, both the state and the samplers. Weight the results of each copy by one over the number of copies.\n\nCompetingClocks offers a split! function that copies the state to a vector of clocks and keeps a split_weight as a record of how many times splitting was done. Take a look at the implementation of CompetingClocks.split!().\n\nYour code might keep the sampler in the main simulation framework, in which case you would include the sampler in the cloning and copying process.","category":"section"},{"location":"integration-guide/#Error-Handling-and-Debugging","page":"Integration Guide","title":"Error Handling and Debugging","text":"If you call the sampler builder with debug=true then there will be logging.\n\nbuilder = SamplerBuilder(KeyType, Float64; debug=true)\nsampler = SamplingContext(builder, rng)\n\nThen run with logging on.\n\nwith_logger(ConsoleLogger(stdout, Logging.Debug)) do\n    observed, importance = run_epochs(100)\nend\n\nThere is also a chaos-monkey option called a Petri sampler. This sampler always advances time by the same time step dt=1.0 by default, and it ignores the clock distributions. It chooses any enabled sampler at each step, with the goal of finding unusual sampling paths. This is surprisingly effective at finding logic errors in code to change state.","category":"section"},{"location":"integration-guide/#Performance-Considerations","page":"Integration Guide","title":"Performance Considerations","text":"Type Stability–-Use a concrete type for the ClockKey for more speed.\n\nSampler Choice–-If there are a lot of clocks enabled at the same time, the the sampler choice can be important. Experts in traffic simulation use hierarchical samplers to split sampling by geographic location but also split fast events from slow events. There are also fine-grained choices for samplers about whether clock keys are reused.\n\nMemory Allocation–-Instead of making a new sampler for each run, use reset!(sampler) between runs to clear out the clocks.","category":"section"},{"location":"mainloop/#Sample-Main-Loop","page":"Sample Main Loop","title":"Sample Main Loop","text":"","category":"section"},{"location":"mainloop/#Introduction","page":"Sample Main Loop","title":"Introduction","text":"Let's walk through a small simulation so that we can see how CompetingClocks could appear in the main loop. This models individuals wandering around on a checkerboard, where no two individuals can occupy the same space. First, let's import libraries.\n\nimport Base\nusing Distributions\nusing Random\nusing Test\nusing CompetingClocks\n\nThere is a physical state for the model, separate from the state of the bag of clocks and separate from the time. Most of the board is empty, so let's use a spare matrix to represent the locations of individuals.\n\nmutable struct PhysicalState\n    board::Matrix{Int64}\nend\n\n# They can move in any of four directions.\n@enum Direction Up Left Down Right\nconst DirectionDelta = Dict(\n    Up => CartesianIndex(-1, 0),\n    Left => CartesianIndex(0, -1),\n    Down => CartesianIndex(1, 0),\n    Right => CartesianIndex(0, 1),\n    );\n\nThe simulation, itself, carries the state of the clocks in the sampler, as well as the physical state. We'll call it a finite state machine.\n\nmutable struct SimulationFSM{Sampler}\n    physical::PhysicalState\n    sampler::Sampler\nend","category":"section"},{"location":"mainloop/#Main-Loop","page":"Sample Main Loop","title":"Main Loop","text":"The main loop will ask what event happens next to the state. When that event changes the state, the loop will update the set of possible next events by disabling outdated ones and enabling new ones. The calls to CompetingClocks are:\n\nnext(sampler)\nenable!(sampler, event ID, distribution)\ndisable!(sampler, event ID)\n\nThere are a lot of samplers in CompetingClocks to choose from. Samplers in CompetingClocks require two type parameters, a key type for clocks and the type used to represent time. In this case, the clock key type fully represents an event, giving the ID of the individual, where they start, and which direction they may move.\n\nstruct ClockKey\n    individual::Int\n    location::CartesianIndex{2}\n    direction::Direction\nend\n\nfunction run(event_count)\n    rng = Xoshiro(2947223)\n    sampler = SamplingContext(ClockKey, Float64, rng)\n    physical = PhysicalState(zeros(Int, 10, 10))\n    sim = SimulationFSM(\n        physical,\n        sampler,\n    )\n    initialize!(sim.physical, 9, rng)\n    current_events = allowed_moves(sim.physical)\n    for event_id in current_events\n        enable!(sim.sampler, event_id, Weibull(1.0))\n    end\n\n    for i in 1:event_count\n        (when, what) = next(sim.sampler)\n        if isfinite(when) && !isnothing(what)\n            fire!(sim.sampler, what, when)\n            delete!(current_events, what)\n            move!(sim.physical, what)\n            next_events = allowed_moves(sim.physical)\n            update_events!(sampler, current_events, next_events, Weibull(1.0))\n            current_events = next_events\n            @show (when, what)\n        end\n    end\nend;\n\nFor this checkerboard with wandering individuals, the allowed moves are moves by any individual to any free square on the board. The set of allowed moves is precisely the set of enabled clocks, so it stores ClockKeys.\n\nfunction allowed_moves(physical::PhysicalState)\n    allowed = Set{ClockKey}()\n    occupied_locations = findall(!iszero, physical.board)\n    for location in occupied_locations\n        individual = physical.board[location]\n        for (direction, offset) in DirectionDelta\n            if checkbounds(Bool, physical.board, location + offset)\n                if physical.board[location + offset] == 0\n                    push!(allowed, ClockKey(individual, location, direction))\n                end\n            end\n        end\n    end\n    return allowed\nend;\n\nIn practice, you would track dependencies among individuals in order to accelerate a simulation rather than checking all events in allowed_moves. The next function updates the current events in the sampler.\n\nfunction update_events!(sampler, old_events, new_events, distribution)\n    for remove in setdiff(old_events, new_events)\n        disable!(sampler, remove)\n    end\n    for add in setdiff(new_events, old_events)\n        enable!(sampler, add, distribution)\n    end\nend;","category":"section"},{"location":"mainloop/#Changes-to-the-state-of-the-board","page":"Sample Main Loop","title":"Changes to the state of the board","text":"We set up the board with an initializer that places individuals at random. We move one individual at a time, when their next event happens.\n\nfunction initialize!(physical::PhysicalState, individuals::Int, rng)\n    physical.board .= 0\n    for ind_idx in 1:individuals\n        loc = rand(rng, CartesianIndices(physical.board))\n        while physical.board[loc] != 0\n            loc = rand(rng, CartesianIndices(physical.board))\n        end\n        physical.board[loc] = ind_idx\n    end\nend;\n\n\nfunction move!(physical::PhysicalState, event::ClockKey)\n    next_location = event.location + DirectionDelta[event.direction]\n    physical.board[event.location] = 0\n    physical.board[next_location] = event.individual\nend;","category":"section"},{"location":"mainloop/#How-it-runs","page":"Sample Main Loop","title":"How it runs","text":"A run of this simulation produces a sequence of moves, no two happening at the same time because this is a continuous-time simulation.\n\nrun(10)\n\n(when, what) = (0.07319364933011555, Main.var\"##277\".ClockKey(7, CartesianIndex(7, 6), Main.var\"##277\".Right))\n(when, what) = (0.10866577949385807, Main.var\"##277\".ClockKey(2, CartesianIndex(5, 10), Main.var\"##277\".Up))\n(when, what) = (0.15079187330778177, Main.var\"##277\".ClockKey(2, CartesianIndex(4, 10), Main.var\"##277\".Left))\n(when, what) = (0.1682581650543986, Main.var\"##277\".ClockKey(2, CartesianIndex(4, 9), Main.var\"##277\".Left))\n(when, what) = (0.1951607095320235, Main.var\"##277\".ClockKey(4, CartesianIndex(9, 1), Main.var\"##277\".Right))\n(when, what) = (0.2118081725791219, Main.var\"##277\".ClockKey(5, CartesianIndex(4, 1), Main.var\"##277\".Right))\n(when, what) = (0.23428157161572638, Main.var\"##277\".ClockKey(2, CartesianIndex(4, 8), Main.var\"##277\".Down))\n(when, what) = (0.2646327040189687, Main.var\"##277\".ClockKey(3, CartesianIndex(1, 8), Main.var\"##277\".Left))\n(when, what) = (0.26803917104227504, Main.var\"##277\".ClockKey(7, CartesianIndex(7, 7), Main.var\"##277\".Left))\n(when, what) = (0.381302342107937, Main.var\"##277\".ClockKey(3, CartesianIndex(1, 7), Main.var\"##277\".Down))\n\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"gen/generative_function/#CompetingClocks-as-a-Gen-Generative-Function","page":"CompetingClocks as a Gen Generative Function","title":"CompetingClocks as a Gen Generative Function","text":"This document shows how to wrap a CompetingClocks simulator as a custom Gen.jl generative function, enabling it to serve as a building block in larger probabilistic models where the event path is latent.","category":"section"},{"location":"gen/generative_function/#Statistical-Framework","page":"CompetingClocks as a Gen Generative Function","title":"Statistical Framework","text":"","category":"section"},{"location":"gen/generative_function/#Path-Likelihood-for-Black-Box-Simulators","page":"CompetingClocks as a Gen Generative Function","title":"Path Likelihood for Black-Box Simulators","text":"A CompetingClocks simulator defines a probability distribution over event paths:\n\nParameters: theta (rates, shape parameters, etc.)\nEvent path: omega = (t_1 e_1) ldots (t_n e_n) over horizon 0 T\nPath density: p_theta(omega)\n\nWith path_likelihood=true, CompetingClocks computes the exact log-density via pathloglikelihood(sampler, T). This includes both the probability of observed events and the survival probability (no further events before T).","category":"section"},{"location":"gen/generative_function/#The-Generative-Function-Interface","page":"CompetingClocks as a Gen Generative Function","title":"The Generative Function Interface","text":"Gen's generative function interface (GFI) wraps simulators that:\n\nTake arguments (parameters, initial conditions, horizon)\nUse internal randomness to produce a trace\nReturn a value (here: a summary like final population)\nReport a log-probability score for the trace\n\nBy implementing simulate, generate, and trace accessors, any CompetingClocks model becomes a first-class Gen building block.","category":"section"},{"location":"gen/generative_function/#When-to-Use-This-Approach","page":"CompetingClocks as a Gen Generative Function","title":"When to Use This Approach","text":"The generative function approach is appropriate when:\n\nThe event path is latent—you observe consequences (final state, counts) rather than the path itself\nYou want to embed the simulator in a larger model with priors and observation likelihoods\nYou need Gen's inference machinery (importance sampling, MCMC) over model parameters\n\nFor conditioning directly on observed paths, see CompetingClocks as a Gen Distribution.\n\n","category":"section"},{"location":"gen/generative_function/#Example:-Density-Dependent-Birth-Death-Process","page":"CompetingClocks as a Gen Generative Function","title":"Example: Density-Dependent Birth-Death Process","text":"A linear birth-death process either explodes or dies out. For stable dynamics suitable for inference, we use a logistic birth rate:\n\nlambda(N) = lambda_0 cdot N cdot maxleft(0 1 - fracNKright)\n\nwhere K is the carrying capacity. The population fluctuates around K rather than diverging.\n\nThe complete working example is in examples/gen_generative.jl.","category":"section"},{"location":"gen/generative_function/#Basic-Types","page":"CompetingClocks as a Gen Generative Function","title":"Basic Types","text":"using Random\nusing Distributions\nusing CompetingClocks\n\n# Clock keys: (:birth, 0) for births, (:death, i) for individual i's death\nconst ClockKey = Tuple{Symbol,Int}\n\n# A single event in a trajectory\nstruct BDEvent\n    time::Float64\n    key::ClockKey\nend\n\nconst EventPath = Vector{BDEvent}","category":"section"},{"location":"gen/generative_function/#Simulation-with-Path-Likelihood","page":"CompetingClocks as a Gen Generative Function","title":"Simulation with Path Likelihood","text":"function simulate_bd_path(\n    birth_rate::Float64,\n    K::Float64,\n    death_shape::Float64,\n    death_scale::Float64,\n    init_pop::Int,\n    tmax::Float64,\n    rng::AbstractRNG,\n)\n    # Initial state: individuals are numbered 1:init_pop\n    population = Set(1:init_pop)\n    next_id = init_pop + 1\n\n    # CompetingClocks sampler with path likelihood enabled\n    sampler = SamplingContext(ClockKey, Float64, rng; path_likelihood=true)\n\n    # Density-dependent birth rate: logistic model\n    function birth_rate_total(N::Int)\n        N <= 0 && return 0.0\n        return birth_rate * N * max(0.0, 1.0 - N / K)\n    end\n\n    # Enable initial birth and death clocks\n    rate = birth_rate_total(length(population))\n    if rate > 0\n        enable!(sampler, (:birth, 0), Exponential(inv(rate)))\n    end\n    for i in population\n        enable!(sampler, (:death, i), Gamma(death_shape, death_scale))\n    end\n\n    # Simulate until horizon tmax or extinction\n    path = BDEvent[]\n    when, which = next(sampler)\n\n    while !isnothing(which) && when <= tmax && !isempty(population)\n        fire!(sampler, which, when)\n        push!(path, BDEvent(when, which))\n\n        if which[1] == :birth\n            new_id = next_id\n            next_id += 1\n            push!(population, new_id)\n            enable!(sampler, (:death, new_id), Gamma(death_shape, death_scale))\n        elseif which[1] == :death\n            delete!(population, which[2])\n        end\n\n        # Refresh birth clock with density-dependent rate\n        rate = birth_rate_total(length(population))\n        if rate > 0\n            enable!(sampler, (:birth, 0), Exponential(inv(rate)))\n        end\n\n        when, which = next(sampler)\n    end\n\n    # Log-likelihood of the whole path, including survival up to tmax\n    logp = pathloglikelihood(sampler, tmax)\n\n    return path, length(population), logp\nend\n\n","category":"section"},{"location":"gen/generative_function/#Gen-Generative-Function-Wrapper","page":"CompetingClocks as a Gen Generative Function","title":"Gen Generative Function Wrapper","text":"","category":"section"},{"location":"gen/generative_function/#Trace-Type","page":"CompetingClocks as a Gen Generative Function","title":"Trace Type","text":"The trace stores the simulation output and implements Gen's trace interface:\n\nusing Gen\n\nstruct BDTrace <: Gen.Trace\n    args::Tuple                # (birth_rate, K, death_shape, death_scale, init_pop, tmax)\n    choices::Gen.ChoiceMap     # :path => Vector{BDEvent}\n    retval::Int                # final population size\n    logp::Float64              # log p(path | args)\n    gen_fn::Any                # back-pointer to the generative function\nend","category":"section"},{"location":"gen/generative_function/#Generative-Function-Type","page":"CompetingClocks as a Gen Generative Function","title":"Generative Function Type","text":"The generative function wraps the simulator and holds an RNG:\n\nstruct BDPathGF{R<:AbstractRNG} <: Gen.GenerativeFunction{Int,BDTrace}\n    rng::R\nend\n\nBDPathGF(rng::AbstractRNG) = BDPathGF{typeof(rng)}(rng)\nBDPathGF() = BDPathGF(Random.default_rng())","category":"section"},{"location":"gen/generative_function/#Required-GFI-Methods","page":"CompetingClocks as a Gen Generative Function","title":"Required GFI Methods","text":"function Gen.simulate(gen_fn::BDPathGF, args::Tuple)\n    birth_rate, K, death_shape, death_scale, init_pop, tmax = args\n\n    path, final_pop, logp = simulate_bd_path(\n        birth_rate, K, death_shape, death_scale, init_pop, tmax, gen_fn.rng\n    )\n\n    choices = Gen.choicemap((:path, path))\n    return BDTrace(args, choices, final_pop, logp, gen_fn)\nend\n\n# Default proposal q = p, so generate calls simulate with weight 0\nfunction Gen.generate(gen_fn::BDPathGF, args::Tuple, constraints::Gen.ChoiceMap)\n    trace = Gen.simulate(gen_fn, args)\n    return trace, 0.0\nend\n\nGen.generate(gen_fn::BDPathGF, args::Tuple) =\n    Gen.generate(gen_fn, args, Gen.choicemap())\n\n# Trace accessors\nGen.get_args(trace::BDTrace) = trace.args\nGen.get_retval(trace::BDTrace) = trace.retval\nGen.get_choices(trace::BDTrace) = trace.choices\nGen.get_score(trace::BDTrace) = trace.logp\nGen.get_gen_fn(trace::BDTrace) = trace.gen_fn\n\nBase.getindex(trace::BDTrace, addr) = getindex(trace.choices, addr)\n\n# No gradients in this example\nGen.has_argument_grads(::BDPathGF) = (false, false, false, false, false, false)\nGen.accepts_output_grad(::BDPathGF) = false\n\n# Project returns the full log-probability\nGen.project(trace::BDTrace, ::Gen.Selection) = trace.logp","category":"section"},{"location":"gen/generative_function/#Standalone-Usage","page":"CompetingClocks as a Gen Generative Function","title":"Standalone Usage","text":"The generative function can be used directly:\n\nbd_gf = BDPathGF(Xoshiro(42))\n\ntrace = Gen.simulate(bd_gf, (2.0, 50.0, 2.0, 2.0, 10, 10.0))\nfinal_pop = Gen.get_retval(trace)  # Int: final population\npath = trace[:path]                 # Vector{BDEvent}: full trajectory\nlogp = Gen.get_score(trace)         # Float64: log p(path | params)\n\n","category":"section"},{"location":"gen/generative_function/#Using-the-Generative-Function-in-a-Gen-Model","page":"CompetingClocks as a Gen Generative Function","title":"Using the Generative Function in a Gen Model","text":"","category":"section"},{"location":"gen/generative_function/#Inference-Model","page":"CompetingClocks as a Gen Generative Function","title":"Inference Model","text":"Embed the generative function in a model with priors over parameters and an observation likelihood:\n\nconst global_bd_gf = BDPathGF(Xoshiro(123))\n\n@gen function bd_inference_model(K::Float64, tmax::Float64)\n    # Prior on the birth rate (lognormal via exp of normal)\n    log_birth_rate = @trace(normal(0.0, 0.5), :log_birth_rate)\n    birth_rate = exp(log_birth_rate)\n\n    # Fixed death parameters and initial population\n    death_shape = 2.0\n    death_scale = 2.0\n    init_pop = 10\n\n    # Draw a whole birth-death path via CompetingClocks\n    final_pop = @trace(\n        global_bd_gf(birth_rate, K, death_shape, death_scale, init_pop, tmax),\n        :simulation\n    )\n\n    # Noisy observation of the final population\n    y = @trace(normal(float(final_pop), 2.0), :y)\n\n    return (birth_rate=birth_rate, final_pop=final_pop, y=y)\nend","category":"section"},{"location":"gen/generative_function/#Forward-Simulation","page":"CompetingClocks as a Gen Generative Function","title":"Forward Simulation","text":"K = 50.0\ntmax = 10.0\n\ntrace = Gen.simulate(bd_inference_model, (K, tmax))\nretval = Gen.get_retval(trace)\n\nprintln(\"Sampled birth_rate: \", retval.birth_rate)\nprintln(\"Final population: \", retval.final_pop)\nprintln(\"Model log-probability: \", Gen.get_score(trace))","category":"section"},{"location":"gen/generative_function/#Importance-Sampling-Inference","page":"CompetingClocks as a Gen Generative Function","title":"Importance Sampling Inference","text":"Condition on an observed population count and infer the birth rate:\n\n# Observed data\nobserved_y = 40.0\n\n# Condition on the observation\nobservations = Gen.choicemap((:y, observed_y))\n\n# Run importance sampling\nn_samples = 100\ntraces, log_weights, lml_est = Gen.importance_sampling(\n    bd_inference_model, (K, tmax), observations, n_samples\n)\n\n# Compute importance-weighted posterior mean\nposterior_birth_rates = [exp(tr[:log_birth_rate]) for tr in traces]\nweights = exp.(log_weights .- maximum(log_weights))\nweights ./= sum(weights)\n\nmean_birth_rate = sum(weights .* posterior_birth_rates)","category":"section"},{"location":"gen/generative_function/#Accessing-the-Event-Path","page":"CompetingClocks as a Gen Generative Function","title":"Accessing the Event Path","text":"The event path is stored in the generative function's choice map. Access it via get_submap:\n\nexample_trace = traces[1]\nchoices = Gen.get_choices(example_trace)\nsim_choices = Gen.get_submap(choices, :simulation)\nexample_path = sim_choices[:path]\n\n","category":"section"},{"location":"gen/generative_function/#Generalizing-to-Other-Models","page":"CompetingClocks as a Gen Generative Function","title":"Generalizing to Other Models","text":"The pattern applies to any CompetingClocks simulation:\n\nDefine your simulation using SamplingContext(...; path_likelihood=true)\nReturn the path, summary statistics, and pathloglikelihood(sampler, T)\nCreate a trace type storing arguments, choices, return value, and score\nImplement GFI methods: simulate, generate, and accessors","category":"section"},{"location":"gen/generative_function/#Model-Specific-Components","page":"CompetingClocks as a Gen Generative Function","title":"Model-Specific Components","text":"Component What to Customize\nsimulate_*_path State transitions, clock distributions, event handling\nReturn value Summary statistics relevant to your observations\nTrace type Fields for your specific outputs","category":"section"},{"location":"gen/generative_function/#Extensions","page":"CompetingClocks as a Gen Generative Function","title":"Extensions","text":"MCMC over paths: Implement update/regenerate to propose path modifications\nMultiple trajectories: Call the generative function in a loop within your model\nGradient-based inference: Implement has_argument_grads and gradient methods\nBiased proposals: Use likelihood_cnt > 1 for importance sampling with mixture proposals","category":"section"},{"location":"gen/generative_function/#Examples-to-Adapt","page":"CompetingClocks as a Gen Generative Function","title":"Examples to Adapt","text":"SIR epidemics: Return final recovered count; observe case reports\nQueueing systems: Return throughput metrics; observe service times\nReliability models: Return component states; observe maintenance logs\nChemical kinetics: Return species concentrations; observe assay measurements","category":"section"},{"location":"gen/importance_mixture/#Importance-Sampling-with-Mixture-Proposals","page":"Importance Sampling with Mixture Proposals","title":"Importance Sampling with Mixture Proposals","text":"CompetingClocks can compute path log-likelihoods under multiple distributions simultaneously, enabling importance sampling with mixture proposals for continuous-time stochastic processes. This page describes how to use the likelihood_cnt feature and integrate it with Gen.jl for Bayesian inference.","category":"section"},{"location":"gen/importance_mixture/#Path-Space-Importance-Sampling","page":"Importance Sampling with Mixture Proposals","title":"Path-Space Importance Sampling","text":"Let X be an event path generated by a continuous-time stochastic system (SIR, gene expression, reliability, etc.). In CompetingClocks, a path is a sequence of (clock key, firing time) pairs:\n\nx = bigl (k_1 t_1) (k_2 t_2) ldots (k_n t_n) bigr\n\nDefine:\n\nTarget path law p_theta(x): the GSMP dynamics you want to characterize (parameterized by theta)\nProposal path law q_phi(x): biased dynamics that make rare events more frequent\n\nStandard path-space importance sampling:\n\nDraw x sim q_phi\nCompute the importance weight:\nw(x) = fracp_theta(x)q_phi(x) quad log w(x) = log p_theta(x) - log q_phi(x)\nEstimate expectations under p_theta via weighted averages sum_i w_i f(x_i)  sum_i w_i\n\nCompetingClocks supports this directly:\n\nCreate a sampler with path_likelihood=true and likelihood_cnt=K\nFor each enable! call, pass a vector of K distributions for that clock\nThe sampler simulates using one distribution (selected via sample_from_distribution!) but accumulates log-likelihoods for the realized path under all K distributions\nCall pathloglikelihood(sampler, end_time) to retrieve the K log path-densities","category":"section"},{"location":"gen/importance_mixture/#Mixture-Proposals","page":"Importance Sampling with Mixture Proposals","title":"Mixture Proposals","text":"Introduce M proposals q_1 ldots q_M and form a mixture:\n\nq_textmix(x) = sum_m=1^M alpha_m q_m(x) quad alpha_m ge 0 quad sum_m alpha_m = 1\n\nTo sample x sim q_textmix:\n\nDraw component index J sim textCategorical(alpha)\nDraw x sim q_J\n\nThe mixture importance weight is:\n\nlog w(x) = log p_theta(x) - log q_textmix(x) = log p_theta(x) - logBigl( sum_m=1^M alpha_m e^log q_m(x) Bigr)\n\nCompute the denominator numerically via logsumexp:\n\nlog q_textmix(x) = textlogsumexp_mbigl(log alpha_m + log q_m(x)bigr)\n\nCompetingClocks implementation:\n\nSet likelihood_cnt = 1 + M (target plus M proposals)\nFor each clock, pass a distribution vector where index 1 is the target p_theta and indices 2 through M+1 are the proposals\nCall sample_from_distribution!(sampler, 1 + j) to sample from proposal j\nAfter simulation, pathloglikelihood returns 1 + M log-likelihoods","category":"section"},{"location":"gen/importance_mixture/#Example:-Poisson-Process-with-Mixture-Proposals","page":"Importance Sampling with Mixture Proposals","title":"Example: Poisson Process with Mixture Proposals","text":"Consider a homogeneous Poisson process on 0 T with rate lambda. We define:\n\nTarget: rate lambda\nProposals: rates lambda cdot m_1 ldots lambda cdot m_M where each m_i is a multiplicative bias\nMixture weights: uniform alpha = (1M ldots 1M)\n\nThe following function simulates a path under the mixture proposal and returns both the event count and the log importance weight:\n\nusing Random\nusing Statistics: mean, var\nusing Distributions: Exponential, Categorical, UnivariateDistribution, Gamma, Poisson, logpdf\nusing CompetingClocks\nusing StatsFuns: logsumexp\n\nconst ClockKey = Int\n\n\"\"\"\n    simulate_poisson_path_with_mixture(λ_target, multipliers, α, T_end, rng)\n\nSimulate a Poisson process path up to time `T_end` using a mixture of biased\nrates. Returns `(count, log_weight)` where:\n- `count`: number of events by time `T_end`\n- `log_weight`: log p(path | λ_target) - log q_mix(path)\n\"\"\"\nfunction simulate_poisson_path_with_mixture(\n    λ_target::Float64,\n    multipliers::Vector{Float64},\n    α::Vector{Float64},\n    T_end::Float64,\n    rng::AbstractRNG\n)\n    M = length(multipliers)\n    @assert length(α) == M\n    @assert isapprox(sum(α), 1.0)\n    K = 1 + M  # target + M proposals\n\n    # Create sampler with K path likelihoods\n    sampler = SamplingContext(ClockKey, Float64, rng;\n        method=FirstToFireMethod(),\n        path_likelihood=true,\n        likelihood_cnt=K\n    )\n\n    # Select which proposal to sample from\n    j = rand(rng, Categorical(α))\n    sample_from_distribution!(sampler, 1 + j)\n\n    # Distribution vector: [target, proposal_1, ..., proposal_M]\n    dists = Vector{UnivariateDistribution}(undef, K)\n    dists[1] = Exponential(1.0 / λ_target)\n    for m in 1:M\n        dists[1 + m] = Exponential(1.0 / (λ_target * multipliers[m]))\n    end\n\n    enable!(sampler, 1, dists)\n\n    count = 0\n    when, which = next(sampler)\n    while !isnothing(which) && when <= T_end\n        fire!(sampler, which, when)\n        count += 1\n        enable!(sampler, 1, dists)\n        when, which = next(sampler)\n    end\n\n    # Extract log-likelihoods\n    logliks = pathloglikelihood(sampler, T_end)\n    log_p = logliks[1]\n    log_qs = logliks[2:end]\n\n    # Mixture weight via logsumexp\n    log_q_mix = logsumexp(log.(α) .+ collect(log_qs))\n    log_weight = log_p - log_q_mix\n\n    return count, log_weight\nend","category":"section"},{"location":"gen/importance_mixture/#Verifying-Correctness","page":"Importance Sampling with Mixture Proposals","title":"Verifying Correctness","text":"The weighted sample mean should match the true expectation EN_T = lambda T:\n\nλ_target = 1.5\nT_end = 10.0\nmultipliers = [0.5, 1.0, 2.0]\nα = fill(1.0 / length(multipliers), length(multipliers))\n\nn_samples = 1000\ncounts = zeros(Int, n_samples)\nlog_weights = zeros(Float64, n_samples)\n\nrng = Xoshiro(42)\nfor i in 1:n_samples\n    counts[i], log_weights[i] = simulate_poisson_path_with_mixture(\n        λ_target, multipliers, α, T_end, rng\n    )\nend\n\n# Normalize weights\nmax_lw = maximum(log_weights)\nweights = exp.(log_weights .- max_lw)\nweights ./= sum(weights)\n\nweighted_mean = sum(weights .* counts)  # ≈ 15.0\ntrue_mean = λ_target * T_end            # = 15.0\n\nThe unweighted mean will differ from the true mean (due to the biased proposals), but the importance-weighted mean converges to the correct value.","category":"section"},{"location":"gen/importance_mixture/#Integration-with-Gen.jl","page":"Importance Sampling with Mixture Proposals","title":"Integration with Gen.jl","text":"Gen.jl provides a probabilistic programming framework where you can combine CompetingClocks simulations with parameter inference. The key insight: treat the CompetingClocks simulation as a black box that returns a summary and an importance weight, then incorporate that weight into Gen's trace score.","category":"section"},{"location":"gen/importance_mixture/#Model-Structure","page":"Importance Sampling with Mixture Proposals","title":"Model Structure","text":"Consider a model with:\n\nParameter theta with prior p(theta)\nLatent path X with law p_theta(x)\nObservation y with likelihood p(y mid x theta)\n\nRather than representing each event as a Gen choice, let CompetingClocks handle the path simulation. For each trace:\n\nSample theta from the prior (Gen choice)\nSimulate x using the mixture proposal via CompetingClocks\nCompute log w(x) = log p_theta(x) - log q_textmix(x)\nAdd the weight to Gen's score so inference sees the correct target density","category":"section"},{"location":"gen/importance_mixture/#Implementation","page":"Importance Sampling with Mixture Proposals","title":"Implementation","text":"using Gen\n\n@gen function poisson_inference_model(\n    T_end::Float64,\n    multipliers::Vector{Float64},\n    α::Vector{Float64},\n    rng::AbstractRNG\n)\n    # Prior on target rate\n    λ ~ gamma(2.0, 1.0)\n\n    # Simulate path with mixture proposal\n    count, log_w = simulate_poisson_path_with_mixture(λ, multipliers, α, T_end, rng)\n\n    return (count=count, log_weight=log_w, λ=λ)\nend","category":"section"},{"location":"gen/importance_mixture/#Inference-Loop","page":"Importance Sampling with Mixture Proposals","title":"Inference Loop","text":"Since the path importance weight must be incorporated into the particle weights, implement a manual importance sampling loop:\n\n# Generate synthetic observation\ntrue_λ = 1.5\nobs_count = rand(Xoshiro(999), Poisson(true_λ * T_end))\n\n# Importance sampling over λ\nn_particles = 1000\nrng = Xoshiro(42)\n\nλ_samples = zeros(Float64, n_particles)\ntotal_log_weights = zeros(Float64, n_particles)\n\nfor i in 1:n_particles\n    # Sample from prior\n    λ = rand(rng, Gamma(2.0, 1.0))\n    λ_samples[i] = λ\n\n    # Simulate with mixture proposal\n    sim_count, log_w_path = simulate_poisson_path_with_mixture(\n        λ, multipliers, α, T_end, rng\n    )\n\n    # Observation likelihood\n    log_obs = logpdf(Poisson(max(sim_count, 1)), obs_count)\n\n    # Total weight: path correction + observation\n    total_log_weights[i] = log_w_path + log_obs\nend\n\n# Normalize and compute posterior statistics\nmax_lw = maximum(total_log_weights)\nweights = exp.(total_log_weights .- max_lw)\nweights ./= sum(weights)\n\nposterior_mean_λ = sum(weights .* λ_samples)\ness = 1.0 / sum(weights.^2)  # Effective sample size\n\nThis gives two layers of importance sampling:\n\nInner layer (CompetingClocks): corrects from q_textmix to p_lambda\nOuter layer (Gen/manual): corrects from prior p(lambda) to posterior p(lambda mid y)","category":"section"},{"location":"gen/importance_mixture/#Variance-Reduction","page":"Importance Sampling with Mixture Proposals","title":"Variance Reduction","text":"Mixture proposals can substantially improve effective sample size compared to a single proposal. The benefit comes from adaptive coverage: when one proposal generates unlikely paths under the target, others may assign higher probability.\n\nCompare effective sample sizes:\n\nProposal Type ESS (out of 1000)\nMixture (m = [0.5, 1.0, 2.0]) ~430\nSingle (m = 1.5) ~95\n\nThe mixture achieves roughly 4× higher ESS by hedging across multiple rate biases.","category":"section"},{"location":"gen/importance_mixture/#Generalizing-to-Other-Models","page":"Importance Sampling with Mixture Proposals","title":"Generalizing to Other Models","text":"To adapt this pattern to your CompetingClocks model:\n\nIdentify target parameters theta that define p_theta — these become Gen random choices or inference targets\nFor each clock, construct a distribution vector [p_dist, q1_dist, ..., qM_dist] and call the vectorized enable!(sampler, key, dists)\nSelect the sampling distribution with sample_from_distribution!(sampler, index) before the simulation loop\nAfter simulation, call pathloglikelihood(sampler, end_time) and compute the mixture weight via logsumexp\nWrap in a helper that returns (path_summary, log_weight)\nIn Gen or your inference code:\nCall the helper\nIncorporate log_weight into particle weights or Gen factors\nAdd observation likelihoods\nUse any inference algorithm (importance sampling, SMC, MCMC)\n\nThis separation keeps variance-reduction logic (multiple proposals, mixture weights, common random numbers) in CompetingClocks while exposing a clean interface to probabilistic programming frameworks.","category":"section"},{"location":"contextinterface/#Context-Interface","page":"Context Interface","title":"Context Interface","text":"","category":"section"},{"location":"contextinterface/#Building-a-Context","page":"Context Interface","title":"Building a Context","text":"","category":"section"},{"location":"contextinterface/#Choosing-Sampler-Methods","page":"Context Interface","title":"Choosing Sampler Methods","text":"","category":"section"},{"location":"contextinterface/#Using-a-Context","page":"Context Interface","title":"Using a Context","text":"","category":"section"},{"location":"contextinterface/#CompetingClocks.SamplingContext-Union{Tuple{R}, Tuple{T}, Tuple{K}, Tuple{Type{K}, Type{T}, R}} where {K, T, R<:AbstractRNG}","page":"Context Interface","title":"CompetingClocks.SamplingContext","text":"SamplingContext(::Type{K}, ::Type{T}, rng::AbstractRNG; kwargs...)\n\nConvenience wrapper that allocates a SamplerBuilder then builds a SamplingContext.\n\n\n\n\n\n","category":"method"},{"location":"contextinterface/#CompetingClocks.SamplingContext-Union{Tuple{R}, Tuple{SamplerBuilder, R}} where R<:AbstractRNG","page":"Context Interface","title":"CompetingClocks.SamplingContext","text":"SamplingContext(builder::SamplerBuilder, rng)\n\nUses the SamplerBuilder to make a SamplingContext.\n\nK is always the user key type (builder.clock_type). The sampler and middleware use an internal key type K_int which is equal to K for regular contexts and Tuple{K,Symbol} when builder.support_delayed == true.\n\n\n\n\n\n","category":"method"},{"location":"contextinterface/#CompetingClocks.SamplerBuilder","page":"Context Interface","title":"CompetingClocks.SamplerBuilder","text":"SamplerBuilder(::Type{K}, ::Type{T};\n    step_likelihood=false,\n    path_likelihood=false,\n    debug=false,\n    recording=false,\n    common_random=false,\n    method=nothing,\n    start_time::T,\n    likelihood_cnt::Int,\n    support_delayed=false,\n    )\n\nA SamplerBuilder is responsible for recording a user's requirements and building an initial sampler.\n\nK and T are the clock type and time type.\nstep_likelihood - whether you will call steploglikelihood before each fire!\npath_likelihood - whether you will call pathloglikelihood  at the end of a simulation run.\ndebug - Print log messages at the debug level.\nrecording - Store every enable and disable for later examination.\ncommon_random - Use common random numbers during sampling.\nmethod - If you want a single, particular sampler, put its SamplerSpec here. It will create a group called :all that has this sampling method.\nstart_time - Sometimes a simulation shouldn't start at zero.\nlikelihood_cnt - The number of likelihoods to compute, corresponds to number of distributions in enable! calls. This turns on path_likelihood.\nsupport_delayed - If true, the internal sampler key type becomes Tuple{K,Symbol} to distinguish regular, initiation, and completion phases.\n\n\n\n\n\n","category":"type"},{"location":"contextinterface/#CompetingClocks.add_group!","page":"Context Interface","title":"CompetingClocks.add_group!","text":"The selector defines the group of clocks that go to this sampler using an inclusion rule, so it's a function from a clock key and distribution to a Bool.\n\n\n\n\n\n","category":"function"},{"location":"contextinterface/#CompetingClocks.NextReactionMethod","page":"Context Interface","title":"CompetingClocks.NextReactionMethod","text":"NextReactionMethod()\n\nUses Anderson's Modified Next Reaction method for distributions in an Exponential class (Exponential, Weibull, Erlang) and the Next Reaction method for other distributions. Yes, these two methods are mixed into one sampler because Julia's holy traits pattern makes it efficient to use the fastest sampler on a distribution-by-distribution basis. Because it reuses draws, this is the best choice if you want to do variance reduction with Common Random Numbers.\n\nSee CombinedNextReaction.\n\n\n\n\n\n","category":"type"},{"location":"contextinterface/#CompetingClocks.DirectMethod","page":"Context Interface","title":"CompetingClocks.DirectMethod","text":"DirectMethod()\nDirectMethod(memory::Symbol, search::Symbol)\nDirectMethod(:keep, :scan)\nDirectMethod(:keep, :tree)\nDirectMethod(:remove, :scan)\nDirectMethod(:remove, :tree)\n\nUse this to specify any Direct method for Exponential distributions. Defaults to memory=:remove so it limits memory growth over time but memory=:keep will be faster if the space of clock keys is limited. Defaults to search=:tree for best performance for many enabled clocks but search=:scan is faster for small numbers of clocks. The different kinds of methods, like \"Optimized Direct Methods\" amount to using different computer science techniques for scanning sums of hazard rates, and that's what the search algorithm lets you choose.\n\nSee DirectCall.\n\n\n\n\n\n","category":"type"},{"location":"contextinterface/#CompetingClocks.FirstReactionMethod","page":"Context Interface","title":"CompetingClocks.FirstReactionMethod","text":"FirstReactionMethod()\n\nThe classic sampler that draws every clock at every time step. Very fast for very small numbers of enabled clocks and returns a new next() every time it is called which helps when resampling paths. Other samplers return the same value every time you call next() unless you jitter! them, which is expensive.\n\nSee FirstReaction.\n\n\n\n\n\n","category":"type"},{"location":"contextinterface/#CompetingClocks.FirstToFireMethod","page":"Context Interface","title":"CompetingClocks.FirstToFireMethod","text":"FirstToFireMethod()\n\nThe simplest and fastest sampler. When you enable!() a clock, this draws the firing time and saves it in a queue.\n\nSee FirstToFire.\n\n\n\n\n\n","category":"type"},{"location":"contextinterface/#CompetingClocks.PartialPropensityMethod","page":"Context Interface","title":"CompetingClocks.PartialPropensityMethod","text":"PartialPropensityMethod()\n\nExact, continuous-time sampler using composition-rejection over groups. Only for exponential distributions. This variant of partial-propensity composition-rejection implements the sampler but not the reaction network. The reaction-network can be implemented outside of the sampler.\n\nSee PSSACR.\n\n\n\n\n\n","category":"type"},{"location":"contextinterface/#CompetingClocks.PetriMethod","page":"Context Interface","title":"CompetingClocks.PetriMethod","text":"PetriMethod()\nPetriMethod(dt)\n\nSamples by picking at random ignoring distributions. Good for testing rare cases in simulations. Increments time dt=1.0 by default. It's called \"Petri\" because a Petri net model always chooses the next event at random.\n\nSee Petri.\n\n\n\n\n\n","category":"type"},{"location":"contextinterface/#CompetingClocks.RejectionMethod","page":"Context Interface","title":"CompetingClocks.RejectionMethod","text":"RejectionMethod(bound_factor=1.05)\n\nA rejection-based algorithm. Only for exponential distributions, this may be the fastest for large simulations. The bound_factor>= 1.0 controls the default upper bounds. Set to 1.0 for no rejections, which reduces this to the direct method.\n\nSee RSSA.\n\n\n\n\n\n","category":"type"},{"location":"contextinterface/#CompetingClocks.enable!","page":"Context Interface","title":"CompetingClocks.enable!","text":"enable!(sampler, clock, distribution, enablingtime, currenttime, RNG)\n\nTell the sampler to start a clock.\n\nsampler::SSA{KeyType,TimeType} - The sampler to tell.\nclock::KeyType - The ID of the clock. Can be a string, integer, tuple, etc.\ndistribution::Distributions.UnivariateDistribution\nenablingtime::TimeType - The zero time for the clock's distribution, in absolute time. Usually equal to when.\nwhen::TimeType - The current time of the simulation.\nrng::AbstractRNG - A random number generator.\n\nThese times are absolute since the start of the simulation. The current time should be when. If you want to shift the distribution so that this event cannot happen for a little while then choose enablingtime > when. If you want to modify the distribution by shifting it left, then choose enablingtime < when. Usually, enablingtime == when. It is also possible to always use enablingtime == when and use the truncated() function to modify distributions.\n\n\n\n\n\nenable!(dc::DirectCall, clock::T, distribution::Exponential, when, rng)\n\nTell the DirectCall sampler to enable this clock. The clock argument is an identifier for the clock. The distribution is a univariate distribution in time. In Julia, distributions are always relative to time t=0, but ours start at some absolute enabling time, t_e, so we provide that here. The when argument is the time at which this clock is enabled, which may be later than when it was first enabled. The rng is a random number generator.\n\nIf a particular clock had one rate before an event and it has another rate after the event, call enable! to update the rate.\n\n\n\n\n\nenable!(ctx, clock, dist, relative_te)\n\nEnable a regular clock in a non-delayed context.\n\n\n\n\n\nenable!(ctx::SamplingContext, clock::K, dist::Vector)\n\nEnabling when there is no shift in enabling time and no delayed distributions.\n\n\n\n\n\nenable!(ctx, clock, dist::Vector, relative_te)\n\nVectorized enable in a non-delayed context.\n\n\n\n\n\nenable!(ctx::SamplingContext, clock::K, dist::Vector)\n\nEnabling for a vector of distributions (for importance sampling) when there is no shift in enabling time and no delayed distributions.\n\n\n\n\n\nenable!(ctx, clock, dist, relative_te)\n\nRegular (non-delayed) clock enable in a delayed-support context. User key clock::K is mapped to internal (clock, :regular).\n\n\n\n\n\nenable!(ctx::SamplingContext, clock::K, dist)\n\nEnabling when there is no shifted enabling time but there are delayed distributions.\n\n\n\n\n\nenable!(ctx, clock, dist::Vector, relative_te)\n\nVectorized enable for regular clocks in a delayed context.\n\n\n\n\n\nenable!(ctx::SamplingContext, clock::K, dist::Vector)\n\nEnabling when there is a vector of distributions and no shifted enabling time for those distributions and there are delayed distributions.\n\n\n\n\n\nenable!(ctx, clock, delayed::Delayed, relative_te)\n\nEnable a delayed reaction. This:\n\nStores the duration distribution delayed.duration in ctx.delayed.durations[clock].\nEnables an initiation event with internal key (clock, :initiate) and distribution delayed.initiation.\n\nThe relative_te shift applies only to the initiation, not the completion.\n\n\n\n\n\n","category":"function"},{"location":"contextinterface/#CompetingClocks.disable!","page":"Context Interface","title":"CompetingClocks.disable!","text":"disable!(sampler, clock, when)\n\nTell the sampler to forget a clock. We include the current simulation time because some Next Reaction methods use this to optimize sampling.\n\n\n\n\n\ndisable!(dc::DirectCall, clock::T, when)\n\nTell the DirectCall sampler to disable this clock. The clock argument is an identifier for the clock. The when argument is the time at which this clock is enabled.\n\n\n\n\n\ndisable!(ctx, clock)\n\nNon-delayed context: disable a single clock.\n\n\n\n\n\ndisable!(ctx, clock)\n\nDelayed context: disable all phases associated with clock and clear any stored duration distribution.\n\n\n\n\n\n","category":"function"},{"location":"contextinterface/#CompetingClocks.next","page":"Context Interface","title":"CompetingClocks.next","text":"next(sampler, when, rng)\n\nAsk the sampler for what happens next, in the form of (when, which)::Tuple{TimeType,KeyType}. rng is a random number generator.\n\n\n\n\n\nnext(dc::DirectCall, when::TimeType, rng::AbstractRNG)\n\nAsk the sampler what clock will be the next to fire and at what time. This does not change the sampler. You can call this multiple times and get multiple answers. Each answer is a tuple of (when, which clock). If there is no clock to fire, then the response will be (Inf, nothing). That's a good sign the simulation is done.\n\n\n\n\n\nnext(multiple_direct, when, rng)\n\nSelects the next transition to fire and when it fires.\n\nThere are two main algorithms for this selection. This implementation handles the case when there are a lot of clocks or when some clocks have much smaller hazards. It first draws a random number to choose which subset of hazards will be used, and then it asks that subset to draw a random number to choose which particular hazard is used. When there are many hazards, it is possible that a random number generator will never choose a particular value because there is no guarantee that a random number generator covers every combination of bits. Using more draws decreases the likelihood of this problem.\n\n\n\n\n\nFor the first reaction sampler, you can call next() multiple times and get different, valid, answers. That isn't the case here. When you call next() on a CombinedNextReaction sampler, it returns the key associated with the clock that fires and marks that clock as fired. Calling next() again would return a nonsensical value.\n\n\n\n\n\nnext(ctx::SamplingContext)\n\nReturn (when, internal_key) for the next event from the underlying sampler. For non-delayed contexts, internal_key is the user key. For delayed contexts it is the internal key, e.g. (user_key, phase).\n\n\n\n\n\n","category":"function"},{"location":"contextinterface/#CompetingClocks.fire!","page":"Context Interface","title":"CompetingClocks.fire!","text":"fire!(ctx, clock, when)\n\nNon-delayed context: fire a regular event and advance time.\n\n\n\n\n\nfire!(ctx, clock, when)\n\nDelayed context: treat this as a regular (non-delayed) event with phase :regular.\n\n\n\n\n\nfire!(ctx, clock, phase, when)\n\nDelayed context: fire an event with phase information.\n\nphase == :regular   : regular event\nphase == :initiate  : initiation of a delayed reaction; schedules completion\nphase == :complete  : completion of a delayed reaction; clears delayed state\n\n\n\n\n\n","category":"function"},{"location":"contextinterface/#CompetingClocks.reset!","page":"Context Interface","title":"CompetingClocks.reset!","text":"reset!(sampler)\n\nAfter a sampler is used for a simulation run, it has internal state. This function resets that internal state to the initial value in preparation for another sample run.\n\n\n\n\n\nDoesn't reset the stored clocks, does reset miss count.\n\n\n\n\n\nreset!(ds::DelayedState)\n\nClear all stored duration distributions.\n\n\n\n\n\nreset!(sampling)\n\nClear all enabled clocks (and delayed state if present) and reset time to the fixed start time.\n\n\n\n\n\n","category":"function"},{"location":"contextinterface/#CompetingClocks.copy_clocks!","page":"Context Interface","title":"CompetingClocks.copy_clocks!","text":"copy_clocks!(destination_sampler, source_sampler)\n\nThis copies the state of the source sampler to the destination sampler, replacing the current state of the destination sampler. This is useful for splitting techniques where you make copies of a simulation and restart it with different random number generators.\n\n\n\n\n\ncopy_clocks!(dst, src)\n\nCopy enabled clocks and delayed state from src into dst, jittering the destination sampler so it will generate different next() samples.\n\n\n\n\n\n","category":"function"},{"location":"contextinterface/#Base.Libc.time-Tuple{SamplingContext}","page":"Context Interface","title":"Base.Libc.time","text":"time(sampling)\n\nCurrent simulation time.\n\n\n\n\n\n","category":"method"},{"location":"contextinterface/#CompetingClocks.sample_from_distribution!","page":"Context Interface","title":"CompetingClocks.sample_from_distribution!","text":"sample_from_distribution!(sampling, index)\n\nChoose which element of a vector-of-distributions to sample from when using path likelihoods (importance sampling).\n\n\n\n\n\n","category":"function"},{"location":"contextinterface/#CompetingClocks.clone","page":"Context Interface","title":"CompetingClocks.clone","text":"clone(sampler)\n\nGiven an existing sampler, make a copy that has the same type and same constructor options but has no data in it. Use this to initialize an array of samplers.\n\n\n\n\n\nclone(ds::DelayedState)\n\nDeep copy of a DelayedState.\n\n\n\n\n\nclone(sampling, rng)\n\nClone a SamplingContext as though constructed again, using a new RNG. All subcomponents (sampler, likelihood, CRN, debug, delayed state) are cloned.\n\n\n\n\n\n","category":"function"},{"location":"contextinterface/#CompetingClocks.enabled","page":"Context Interface","title":"CompetingClocks.enabled","text":"enabled(sampler)\n\nReturns a read-only set of currently-enabled clocks.\n\n\n\n\n\nenabled(sampling)\n\nReturn the set of enabled clock keys. For delayed contexts this returns the internal keys, e.g. (K, Symbol).\n\n\n\n\n\n","category":"function"},{"location":"contextinterface/#CompetingClocks.enabled_history","page":"Context Interface","title":"CompetingClocks.enabled_history","text":"enabled_history(ctx::SamplingContext)\n\nReturns a Vector{EnablingEntry{K,T}} that has every time a clock was enabled.\n\nSee CompetingClocks.EnablingEntry.\n\n\n\n\n\n","category":"function"},{"location":"contextinterface/#CompetingClocks.disabled_history","page":"Context Interface","title":"CompetingClocks.disabled_history","text":"disabled_history(ctx::SamplingContext)\n\nReturns a Vector{DisablingEntry{K,T}} that has every time a clock was disabled.\n\nSee CompetingClocks.DisablingEntry.\n\n\n\n\n\n","category":"function"},{"location":"contextinterface/#CompetingClocks.EnablingEntry","page":"Context Interface","title":"CompetingClocks.EnablingEntry","text":"EnablingEntry{K,T}(clock::K, distribution, te::T, when::T)\n\nRecords that clock is enabled at time when with an enabling time te (in absolute time) that sets the zero of the distribution.\n\nFields\n\nclock::K: The key for the event/clock/transition.\ndistribution::Distributions.UnivariateDistribution, a distribution of clock firing times.\nte::T - An absolute time to use as the zero-time for the distribution. Usually the same as when.\nwhen::T - The time this clock was enabled.\n\n\n\n\n\n","category":"type"},{"location":"contextinterface/#CompetingClocks.DisablingEntry","page":"Context Interface","title":"CompetingClocks.DisablingEntry","text":"DisablingEntry{K,T}(clock::K, when::T)\n\nRecords that clock is disabled at time when.\n\nFields\n\nclock::K: The key for the event/clock/transition.\nwhen::T - The time this clock was enabled.\n\n\n\n\n\n","category":"type"},{"location":"contextinterface/#Base.length-Tuple{SamplingContext}","page":"Context Interface","title":"Base.length","text":"Base.length(sampling)\n\nTotal number of enabled clocks.\n\n\n\n\n\n","category":"method"},{"location":"contextinterface/#CompetingClocks.isenabled","page":"Context Interface","title":"CompetingClocks.isenabled","text":"isenabled(sampling, clock)\n\nWhether this user clock key is enabled. In delayed contexts this returns true if any phase (:regular, :initiate, :complete) is enabled.\n\n\n\n\n\n","category":"function"},{"location":"contextinterface/#Base.keytype-Tuple{SamplingContext}","page":"Context Interface","title":"Base.keytype","text":"keytype(sampler)\n\nReturn the type of clock keys.\n\n\n\n\n\nkeytype(sampling)\n\nUser clock key type K.\n\n\n\n\n\n","category":"method"},{"location":"contextinterface/#CompetingClocks.timetype","page":"Context Interface","title":"CompetingClocks.timetype","text":"timetype(sampler)\n\nReturn the type of clock times.\n\n\n\n\n\ntimetype(sampling)\n\nTime type T, usually Float64.\n\n\n\n\n\n","category":"function"},{"location":"contextinterface/#CompetingClocks.pathloglikelihood","page":"Context Interface","title":"CompetingClocks.pathloglikelihood","text":"pathloglikelihood(ctx, endtime)\n\nPath log-likelihood up to endtime, including the probability that no event fires after the last event before endtime.\n\n\n\n\n\n","category":"function"},{"location":"debugging/#Debugging-a-Simulation-that-Uses-CompetingClocks","page":"Debugging a Simulation that Uses CompetingClocks","title":"Debugging a Simulation that Uses CompetingClocks","text":"It can be difficult to debug simulations that use time-varying hazards, especially when it's possible to cancel events and re-enable events with new hazard rates. This library provides a few tools to help.","category":"section"},{"location":"debugging/#Sample-Unlikely-Events-with-the-Petri-Sampler","page":"Debugging a Simulation that Uses CompetingClocks","title":"Sample Unlikely Events with the Petri Sampler","text":"If your simulation has rare events, and you want to test code paths for those rare events, one approach is to sample the next clock entirely randomly. The Petri sampler ignores the distribution of times for events and picks the next event evenly among all enabled keys.\n\npetri_sampler = Petri{K,T}()\nenable!(tw, 3, Exponential(100.0), 0.0, 0.0, rng)\nwhen, what = next(petri_sampler, now, rng)\n@assert abs(when - now - 1) <= 1e-9\n\nIt also returns a time that is one plus the current time.","category":"section"},{"location":"debugging/#Keep-History-of-Enabling-and-Disabling","page":"Debugging a Simulation that Uses CompetingClocks","title":"Keep History of Enabling and Disabling","text":"The DebugWatcher records every time an event is enabled or disabled. You wouldn't normally want to use all of this time and memory (and memory churn), but it can be helpful to see the trace of all events enabled and disabled, in addition to those that fired.\n\nfor enabling_event in enabled_history(sampler)\n    println(\"$(enabling_event.clock), $(enabling_event.when)\")\nend\nfor disabling_event in disabled_history(sampler)\n    println(\"$(disabling_event.clock), $(disabling_event.when)\")\nend\n\nLook at CompetingClocks.enabled_history and CompetingClocks.disabled_history.","category":"section"},{"location":"guide/#Competing-Clocks","page":"Competing Clocks","title":"Competing Clocks","text":"A discrete event simulation tracks the effects of individual events in time. We classify discrete event simulations by the pace of advances in time. If time advances in steps of the same size, it is a discrete-time simulation. If time advances to the next event, whenever that event might happen, it is continuous-time simulation. This library supports continuous-time discrete-event simulations.\n\nWe write discrete event simulations by defining the state of a system and events that can act on that state. The state of a system can be the count of each chemical species for a chemical reaction system. It can be different numbers of chickens at different weights in different chicken coops for a farming simulation. It can be the age of each widget in an engine for a reliability simulation. These states are called the physical state of the system and vary widely in what they represent.\n\nAn event is an observable change of state at a time. It is a function where the argument is the current state of the system and the return value is the new state of the system. We say an event occurs, happens, or fires when we apply that function to the state. How that state changes is up to the model and how it defines the state, but what about when that state changes?\n\nGiven the current state of the system, there is a set of possible next events which could happen. We call the possible next events enabled. Think of the moment in time just after the simulation has begun or an event has just happened. At this moment, there may be multiple enabled events. Which one is next depends on how often that event happens. If our simulation includes both the radioactive decay of an unstable element and decay of iron, the unstable element will usually decay first. We describe the rates of these events using probability distributions in time. Each event has an associated continuous univariate distribution where the variable is time.\n\nWe can think of all event distributions in a model as a bag of clocks. The next one to ring is the next event to occur. When that event occurs, the state changes. When the state changes, it will enable some events and disable others. Enabled events are added to the bag of clocks. Disabled ones are removed. CompetingClocks is responsible for managing this bag of clocks.","category":"section"},{"location":"guide/#Sets-of-Clocks","page":"Competing Clocks","title":"Sets of Clocks","text":"In CompetingClocks, clocks can be either enabled or disabled. The firing of clocks triggers events, which change the state of the system. This in turn changes the set of clocks that are enabled. This is the basic algorithm to sample models that are phrased as continuous-time discrete-event systems.\n\nIt is worth examining what happens at a state update in more detail. Let E^* be the set of clocks (typically, just a single clock) that fires, and whose associated event updates state from S to S^. There are then three basic sets of clocks to consider: E(S), the set of clocks enabled in S, E(S^), the set of clocks enabled in S^, and E^*, the set of clocks that fired.\n\nNewly enabled clocks are those that are enabled in S^ not part of the set that was enabled in S and remains enabled in S^. Newly disabled clocks are those that were enabled in S but are not enabled in S^. Finally old clocks are those that were enabled in S, and remain so in S^.\n\nAll these sets are visualized in the figure below, reproduced from \"Stochastic petri nets: Modelling, stability, simulation\" by Peter J. Haas (2002).\n\n(Image: )\n\nCompetingClocks is responsible for knowing E^*, but it is the main event loop of the simulation using CompetingClocks that decides which clocks to disable and enable.","category":"section"},{"location":"guide/#References","page":"Competing Clocks","title":"References","text":"[Haas:2006]\tPJ. Haas, “Stochastic petri nets: Modelling, stability, simulation,” Springer Science & Business Media, 2006.","category":"section"},{"location":"vas/#Vector-Addition-System","page":"Vector Addition System","title":"Vector Addition System","text":"One way to understand how to use CompetingClocks is to look at a very simple simulation. A vector addition system (VAS) is a lot like chemical simulations, but it's free of some of the assumptions about chemical rates. The physical state of the system is a vector of integers. Such a simple physical state can make it easier to understand possible complications in how we define events.\n\nThere are variations on how to define a vector addition system. Let's begin with one and introduce variations as they become interesting.\n\nA vector addition system is\n\na physical state p which is a set of d integers, labeled (p_1 p_2cdots p_d).\na system time, t\na finite set of events E where each event has an enabling rule, a distribution, and a firing rule.\na rule for when the event is enabled, where the rule is an invariant on the physical state, such as r_i(p)ge 0. When the invariant is met, the event is enabled. When the invariant is not met, the event is disabled. For a vector addition system, this rule must be expressible as a matrix multiplication, so Mcdot vecp ge 0, where the ge means we are checking elementwise that every element is non-negative.\na distribution in time, where the distribution is determined at enabling time and is a function of the physical state and system time at enabling. The distribution in time can have shocks, such as a delta function, but it may not have a shock at time zero, must have a measure-zero probability of firing at the same moment it is enabled.\na rule for how the event changes physical state when it happens. The domain and co-domain of the rule are physical states of the system. Let's limit this model to require all events to modify the state, so that we exclude events that don't modify the state. As with enabling, this must be expressible as a matrix operation on the physical states to produce a new physical state.\nFrom the rules, we see that an event's state is either disabled or enabled at an enabling time t_e.\n\nHow would we implement this system? It's set up so that enabling rules and firing rules can be done with linear algebra. We can write this in Julia code \n\nSimulation using the VAS requires concrete implementation of the interface:\n\nzero_state(vas::VectorAdditionSystem)\nvas_delta(vas::VectorAdditionSystem, transition_idx)\nvas_initial(vas::VectorAdditionSystem, initial_state)\nfire!(visitor, vas::VectorAdditionSystem, state, modify_state, rng)\nsimstep!(fsm::VectorAdditionFSM, state_update::Function, rng::AbstractRNG)\n\nThe method fire! first modifies state, then, for each clock in the system, it checks whether it has been newly enabled or disabled.\n\nnewly disabled: visitor is called to disable that transition\nnewly enabled: visitor is called to enable that transition and cache its newly calculated intensity\nstill enabled: we check if the new intensity differs from the old and if so use visitor to update the intensity\n\nThe method simstep! first applies fire!, followed by next.","category":"section"},{"location":"gen/observation_likelihood/#Observation-Likelihood-for-Event-Data","page":"Observation Likelihood for Event Data","title":"Observation Likelihood for Event Data","text":"This page describes how to compute the likelihood of observed event sequences using pathloglikelihood, and how to integrate this with probabilistic programming frameworks like Gen.jl for Bayesian inference.","category":"section"},{"location":"gen/observation_likelihood/#Statistical-Background","page":"Observation Likelihood for Event Data","title":"Statistical Background","text":"Consider a continuous-time system where multiple events (clocks) compete to fire:\n\nAt time t, a set of clocks mathcalE_t is enabled.\nEach enabled clock e has hazard lambda_e(t mid mathcalH_t theta), where mathcalH_t is the history up to time t and theta are parameters.\nWhen a clock fires, the system state changes and enabled clocks are updated.\n\nGiven an observed event path over 0 T,\n\nmathcalD = (t_1 e_1) ldots (t_n e_n) quad 0  t_1  cdots  t_n le T\n\nthe log-likelihood has the standard competing risks form:\n\nlog p(mathcalDmidtheta) =\nsum_i=1^n log lambda_e_i(t_i mid mathcalH_t_i^- theta)\n- int_0^T Lambda(t mid mathcalH_t theta)dt\n\nwhere Lambda(t) = sum_e in mathcalE_t lambda_e(t) is the total hazard.\n\nThe first term scores each observed event; the second term accounts for the probability that no other events occurred. For non-exponential distributions (Weibull, Gamma, etc.) this integral requires tracking cumulative hazards from each clock's enabling time.","category":"section"},{"location":"gen/observation_likelihood/#CompetingClocks-Approach","page":"Observation Likelihood for Event Data","title":"CompetingClocks Approach","text":"CompetingClocks maintains these integrals internally. To compute the likelihood:\n\nCreate a SamplingContext with path_likelihood=true\nReplay the observed events: call enable! and fire! in sequence\nCall pathloglikelihood(sampler, end_time) to get log p(mathcalDmidtheta)\n\nThis avoids manual hazard calculus entirely.","category":"section"},{"location":"gen/observation_likelihood/#Example:-Single-Machine-Reliability","page":"Observation Likelihood for Event Data","title":"Example: Single-Machine Reliability","text":"A machine alternates between working (:up) and failed (:down):\n\nTime to failure follows textWeibull(k eta)\nTime to repair follows textExponential(mu)\n\nWe observe failure/repair events and want to infer theta = (k eta mu).","category":"section"},{"location":"gen/observation_likelihood/#Data-Representation","page":"Observation Likelihood for Event Data","title":"Data Representation","text":"using Random\nusing Distributions\nusing CompetingClocks\n\nconst RelEvent = NamedTuple{(:key, :time), Tuple{Symbol, Float64}}\n\nobserved_events = RelEvent[\n    (key = :fail,   time = 1.2),\n    (key = :repair, time = 2.0),\n    (key = :fail,   time = 4.5),\n    (key = :repair, time = 5.1),\n]\nobs_end_time = 8.0","category":"section"},{"location":"gen/observation_likelihood/#Model-State","page":"Observation Likelihood for Event Data","title":"Model State","text":"struct ReliabilityParams\n    k_fail::Float64     # Weibull shape\n    η_fail::Float64     # Weibull scale\n    μ_repair::Float64   # Exponential mean (1/rate)\nend\n\nmutable struct ReliabilityModel\n    up::Bool\n    θ::ReliabilityParams\nend\n\ninit_model(θ::ReliabilityParams) = ReliabilityModel(true, θ)","category":"section"},{"location":"gen/observation_likelihood/#Clock-Management","page":"Observation Likelihood for Event Data","title":"Clock Management","text":"function enable_current_clock!(model::ReliabilityModel, sampler)\n    if model.up\n        enable!(sampler, :fail, Weibull(model.θ.k_fail, model.θ.η_fail))\n    else\n        enable!(sampler, :repair, Exponential(model.θ.μ_repair))\n    end\nend\n\nfunction step_reliability!(model::ReliabilityModel, sampler, key::Symbol, when::Float64)\n    fire!(sampler, key, when)\n    model.up = (key == :repair)\n    enable_current_clock!(model, sampler)\nend","category":"section"},{"location":"gen/observation_likelihood/#Computing-the-Log-Likelihood","page":"Observation Likelihood for Event Data","title":"Computing the Log-Likelihood","text":"function reliability_loglikelihood(θ::ReliabilityParams,\n                                   events::Vector{RelEvent},\n                                   end_time::Float64)\n    sampler = SamplingContext(Symbol, Float64, Xoshiro(1);\n                              path_likelihood = true)\n    model = init_model(θ)\n    enable_current_clock!(model, sampler)\n\n    for evt in events\n        step_reliability!(model, sampler, evt.key, evt.time)\n    end\n\n    return pathloglikelihood(sampler, end_time)\nend\n\nTest it:\n\nθ_true = ReliabilityParams(1.5, 2.0, 1.0)\nll = reliability_loglikelihood(θ_true, observed_events, obs_end_time)\n# ll ≈ -5.73","category":"section"},{"location":"gen/observation_likelihood/#Integration-with-Gen.jl","page":"Observation Likelihood for Event Data","title":"Integration with Gen.jl","text":"Gen.jl provides probabilistic programming with MCMC inference. To use CompetingClocks likelihoods in Gen, create a custom distribution that contributes the log-likelihood as a \"factor\" in the trace.","category":"section"},{"location":"gen/observation_likelihood/#Likelihood-Factor-Distribution","page":"Observation Likelihood for Event Data","title":"Likelihood Factor Distribution","text":"Since Gen's @factor macro may not be available in all versions, we define a custom distribution that adds an arbitrary log-probability to the trace:\n\nusing Gen\nusing Statistics: mean, std\n\nstruct LikelihoodFactor <: Gen.Distribution{Nothing} end\nconst likelihood_factor = LikelihoodFactor()\n\nGen.random(::LikelihoodFactor, logpdf_val::Float64) = nothing\nGen.logpdf(::LikelihoodFactor, ::Nothing, logpdf_val::Float64) = logpdf_val\nGen.is_discrete(::LikelihoodFactor) = true\nGen.has_output_grad(::LikelihoodFactor) = false\nGen.has_argument_grads(::LikelihoodFactor) = (false,)","category":"section"},{"location":"gen/observation_likelihood/#Gen-Model","page":"Observation Likelihood for Event Data","title":"Gen Model","text":"@gen function reliability_model(events::Vector{RelEvent}, end_time::Float64)\n    # Priors on log-parameters (positive support)\n    log_k ~ normal(0.0, 0.5)\n    log_η ~ normal(0.0, 1.0)\n    log_μ ~ normal(0.0, 1.0)\n\n    θ = ReliabilityParams(exp(log_k), exp(log_η), exp(log_μ))\n\n    # Add CompetingClocks likelihood to the trace\n    loglike = reliability_loglikelihood(θ, events, end_time)\n    {:likelihood} ~ likelihood_factor(loglike)\n\n    return θ\nend","category":"section"},{"location":"gen/observation_likelihood/#Inference","page":"Observation Likelihood for Event Data","title":"Inference","text":"Generate an initial trace:\n\n(trace, _) = generate(reliability_model, (observed_events, obs_end_time))\nprintln(\"Initial params: \", get_retval(trace))\nprintln(\"Log-joint: \", get_score(trace))\n\nRun Metropolis-Hastings with Gaussian drift proposals:\n\naddrs = [:log_k, :log_η, :log_μ]\n\nfunction run_mh(initial_trace, n_iters; drift_std=0.1)\n    samples = Vector{ReliabilityParams}(undef, n_iters)\n    current_trace = initial_trace\n    accepted = 0\n\n    for i in 1:n_iters\n        addr = addrs[(i - 1) % 3 + 1]\n        current_val = current_trace[addr]\n        proposed_val = current_val + randn() * drift_std\n        constraints = choicemap((addr, proposed_val))\n\n        new_trace, weight, _, _ = update(\n            current_trace, get_args(current_trace),\n            (NoChange(), NoChange()), constraints\n        )\n\n        if log(rand()) < weight\n            current_trace = new_trace\n            accepted += 1\n        end\n        samples[i] = get_retval(current_trace)\n    end\n\n    return samples, accepted / n_iters\nend\n\nsamples, acc_rate = run_mh(trace, 1000)\nprintln(\"Acceptance rate: $acc_rate\")\n\n# Posterior summary (after burn-in)\npost = samples[501:end]\nprintln(\"k: mean=$(mean(s.k_fail for s in post))\")\nprintln(\"η: mean=$(mean(s.η_fail for s in post))\")\nprintln(\"μ: mean=$(mean(s.μ_repair for s in post))\")","category":"section"},{"location":"gen/observation_likelihood/#Key-Points","page":"Observation Likelihood for Event Data","title":"Key Points","text":"pathloglikelihood computes the full path likelihood including the probability of no events in any remaining observation window.\nThe \"replay\" pattern works for any model structure: simply call enable! and fire! to mirror what would happen during forward simulation.\nThe likelihood function is pure Julia and can be used outside Gen for maximum likelihood estimation, importance sampling, or other inference methods.\nFor models with many parameters or complex posteriors, consider gradient-based methods or more sophisticated MCMC schemes.","category":"section"},{"location":"gen/observation_likelihood/#See-Also","page":"Observation Likelihood for Event Data","title":"See Also","text":"Gen.jl Documentation\nAdding Custom Distributions to Gen\nexamples/gen_observation.jl — Complete working example","category":"section"},{"location":"reference/#Samplers","page":"Samplers","title":"Samplers","text":"The choice of sampler determines specific algorithms that are used to sample, update, and disable clocks. Helpers also exist that are useful for logging, utilizing common random numbers, and hierarchical sampling.","category":"section"},{"location":"reference/#Sampling-Helpers","page":"Samplers","title":"Sampling Helpers","text":"","category":"section"},{"location":"reference/#CompetingClocks.CommonRandom","page":"Samplers","title":"CompetingClocks.CommonRandom","text":"Continuation/Functional Pattern\n\nKey Insight: CommonRandom provides RNG transformation as a higher-order function.\n\nstruct CommonRandom{K,R}       recorder::Dict{K,Vector{R}}       mode::Symbol   end\n\nfunction withcommonrng(       crc::CommonRandom{K,R}, clock::K, baserng::R, f::Function   ) where {K,R}       # Determine which RNG to use       if crc.mode == :replaying && haskey(crc.recorder, clock)           # ... retrieve saved RNG ...           activerng = savedrng       else           activerng = copy(base_rng)           if crc.mode == :recording               # ... save RNG snapshot ...           end       end\n\n  # Call continuation with prepared RNG\n  return f(active_rng)\n\nend\n\nfunction enable!(ctx::SamplingContext, clock, dist, te, when)       if ctx.commonrandom !== nothing           # Wrap sampler call in RNG transformation           withcommonrng(ctx.commonrandom, clock, ctx.rng) do rng               enable!(ctx.sampler, clock, dist, te, when, rng)           end       else           enable!(ctx.sampler, clock, dist, te, when, ctx.rng)       end\n\n  # Other components use base RNG\n  ctx.likelihood !== nothing && enable!(ctx.likelihood, clock, dist, te, when, ctx.rng)\n  ctx.debug !== nothing && enable!(ctx.debug, clock, dist, te, when, ctx.rng)\n\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#CompetingClocks.freeze_crn!","page":"Samplers","title":"CompetingClocks.freeze_crn!","text":"Call this before replaying common random numbers. Call it before each replay.\n\n\n\n\n\nfreeze_crn!(ctx::SamplingContext)\n\nSwitch to using only previously recorded common random numbers.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CompetingClocks.reset_crn!","page":"Samplers","title":"CompetingClocks.reset_crn!","text":"reset_crn!(ctx::SamplingContext)\n\nReset stored CRN draws and time.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CompetingClocks.split!","page":"Samplers","title":"CompetingClocks.split!","text":"split!(dst, src)\n\nSplit a src context into multiple copies in dst, adjusting split_weight.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CompetingClocks.misscount","page":"Samplers","title":"CompetingClocks.misscount","text":"How many times the sampler looked for a random number and found no previous value.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CompetingClocks.misses","page":"Samplers","title":"CompetingClocks.misses","text":"The Pairs of clock keys and values that weren't found.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CompetingClocks.consume_survival","page":"Samplers","title":"CompetingClocks.consume_survival","text":"This updates the survival for a transition in the linear space, according to Gibson and Bruck. Transition was enabled between time record t0 and tn. Divide the survival by the conditional survival between t0 and tn. te can be before t0, at t0, between t0 and tn, or at tn, or after t_n.\n\nu=expleft(-int_t_e^t_nlambda_0(s-t_e)dsright)expleft(-int_t_n^taulambda_n(s-t_e)dsright)\n\n\n\n\n\nThis updates the survival for a transition in log space, according to Anderson's method.\n\nln u=-int_t_e^t_nlambda_0(s-t_e)ds - int_t_n^taulambda_n(s-t_e)ds\n\n\n\n\n\n","category":"function"},{"location":"reference/#CompetingClocks.sampling_space","page":"Samplers","title":"CompetingClocks.sampling_space","text":"This function decides whether a particular distribution can be sampled faster and more accurately using its cumulative distribution function or using the log of its cumulative distribution function, also called the integrated hazard. The former is used for the Next Reaction method by Gibson and Bruck. The latter is used by the Modified Next Reaction method of Anderson. We are calling the first a linear space and the second a logarithmic space.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CompetingClocks.steploglikelihood","page":"Samplers","title":"CompetingClocks.steploglikelihood","text":"steploglikelihood(tw::TrackWatcher, now, when_fires, which_fires)\n\nCalculate the log probability density of a single step in which the which_fires transition fires next. now is the current time. when_fires is the time when which_fires happens so when > now. You have to call this before the transition fires so that it is before transitions are enabled and disabled from the previous step.\n\nOne way to compute a marginal likelihood of a particular clock firing PK is to integrate:\n\nUsing QuadGK\nquadgk(t -> exp(steploglikelihood(tw, t0, t, clock)), t0, Inf)[1]\n\nIt would be slow but could be done.\n\n\n\n\n\nsteploglikelihood(ctx, when, which)\n\nStep log-likelihood of an event which at when. For delayed contexts, which should be the internal key (e.g. (clock, phase)).\n\n\n\n\n\n","category":"function"},{"location":"reference/#CompetingClocks.FromInclusion","page":"Samplers","title":"CompetingClocks.FromInclusion","text":"See sampler.jl for the MultiSampler to understand how we're making a chooser. We would like to implement this: \"Compiling Pattern Matching to Good Decision Trees\" - Luc Maranget (2008). It looks like MLStyle.jl has a good example of how to do it.\n\n\n\n\n\n","category":"type"},{"location":"distrib/#Notation-for-Distributions","page":"Notation for Distributions","title":"Notation for Distributions","text":"This defines notation for subsequent sections.","category":"section"},{"location":"distrib/#Notation","page":"Notation for Distributions","title":"Notation","text":"First, let's affix notation. The cumulative distribution function of every regular distribution can be written as an integral over its hazard rate, lambda\n\nF(t)=1-e^-int_0^t lambda(s)ds\n\nAll algorithms for stochastic simulation treat distributions as being defined in absolute time, specified as an enabling time, t_e,\n\nF(t t_e)=1-e^-int_0^t-t_e lambda(s)ds\n\nWorking with distributions in absolute time is a simple shift of the time scale and will be ignored in further discussions, although the enabling time, t_e, will certainly appear in code.\n\nThe density function is the derivative of the cumulative distribution function,\n\nf(t)=fracdF(t)dt=lambda(t)e^-int_0^t lambda(s)ds\n\nThe survival is\n\nG(t)=1-F(t)=e^-int_0^t lambda(s)ds\n\nBecause survival is multiplicative, we further label the survival from time t_0 to t_1 as\n\nG(t_0 t_1)=fracG(t_1)G(t_0)=e^-int_t_0^t_1 lambda(s)ds","category":"section"},{"location":"distrib/#Using-Julia's-Distributions","page":"Notation for Distributions","title":"Using Julia's Distributions","text":"Julia's continuous univariate distributions support a common interface.\n\nIn this table, d is the distribution, t is the time, and q is a quantile.\n\nJulia call Notation\ncdf(d,t) F(t)\nquantile(d,q) F^-1(q)\nlogcdf(d,t) ln(F(t))\nccdf(d,t) G(t)\nlogccdf(d,t) -int_0^t lambda(s)ds\nquantile(d,q) F^-1(q)\ncquantile(d,q) F^-1(1-q)=G^-1(q)\ninvlogcdf(d,lp) F^-1(e^l_p)\ninvlogccdf(d,lp) G^-1(e^l_p) or -int_0^t(l_p)lambda(s)ds=l_p\nrandexp(rng) -ln(1-U)","category":"section"},{"location":"algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"Many samplers depend on data structures to allow efficient querying of clocks ordered with respect to some value, usually the firing time. These types and methods implement them for CompetingClocks.","category":"section"},{"location":"algorithms/#CompetingClocks.CumSumPrefixSearch","page":"Algorithms","title":"CompetingClocks.CumSumPrefixSearch","text":"CumSumPrefixSearch{T}()\n\nThis stores hazard rates in order to make it easier for the Direct method to sample them. This version is the simplest possible, but it can be faster when there are few hazards enabled. It uses a simple array and, each time the Direct method samples, this evaluates the cumulative sum of the array.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#CompetingClocks.BinaryTreePrefixSearch","page":"Algorithms","title":"CompetingClocks.BinaryTreePrefixSearch","text":"BinaryTreePrefixSearch{T}(N=32)\n\nThis stores hazard rates to make them faster for the Direct method to sample. This is a binary tree where the leaves are values and the nodes are sums of those values. It is meant to make it easier to find the leaf such that the sum of it and all previous leaves is greater than a given value.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#CompetingClocks.KeyedKeepPrefixSearch","page":"Algorithms","title":"CompetingClocks.KeyedKeepPrefixSearch","text":"This decorator turns a Prefix Search algorithm into one that works for arbitrary keys. This version only adds entries, so disabling a clock sets its hazard to zero without removing it. If a simulation re-enables the same set of clocks, this is the faster choice.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#CompetingClocks.KeyedRemovalPrefixSearch","page":"Algorithms","title":"CompetingClocks.KeyedRemovalPrefixSearch","text":"This decorator turns a Prefix Search algorithm into one that works for arbitrary keys. This version reuses entries in the prefix search after their clocks have been disabled. If the simulation moves through a large key space, this will use less memory.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#CompetingClocks.choose","page":"Algorithms","title":"CompetingClocks.choose","text":"choose(pst::BinaryTreePrefixSearch, value)\n\nFind the minimum index such that the prefix is greater than the given value.\n\nPrecondition: The value must be strictly less than the total for the tree.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#Base.setindex!","page":"Algorithms","title":"Base.setindex!","text":"setindex!(A, X, inds...)\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#Base.rand","page":"Algorithms","title":"Base.rand","text":"rand(rng, sampler::SamplerTrivial{BinaryTreePrefixSearch})\n\nThis method overload allows the machinery of Random to generate random variates from the BinaryTreePrefixSearch set of values.\n\n\n\n\n\nrand(rng, sampler::SamplerTrivial{CumSumPrefixSearch})\n\nThis method overload allows the machinery of Random to generate random variates from the CumSumPrefixSearch set of values.\n\n\n\n\n\nDrawing a random number from a left-truncated exponential is particularly simple.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#CompetingClocks.set_multiple!","page":"Algorithms","title":"CompetingClocks.set_multiple!","text":"If there are multiple values to enter, then present them at once as pairs of tuples, (index, value).\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#CompetingClocks.SetOfSets","page":"Algorithms","title":"CompetingClocks.SetOfSets","text":"SetOfSets{K,T<:AbstractSet{K}} <: AbstractSet{K}\n\nA SetOfSets presents sets as a read-only unified set. The goal is to reduce memory allocation by not presuming the client wants an instance of a Set object or an instance of a Vector object. They may want to test is something is in the sets or want to merge with another set.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#CompetingClocks.PrefixEnabled","page":"Algorithms","title":"CompetingClocks.PrefixEnabled","text":"Construct a set that checks which values are zeroed out because this prefix sum doesn't mark what has been deleted. That's faster for small sets of keys but makes getting the set that's enabled more difficult. A hazard rate that is set to zero at enabling will give a funny count because it's enabled!() by the user but set to never fire.\n\n\n\n\n\n","category":"type"},{"location":"objects/#Objects-in-CompetingClocks","page":"Objects in CompetingClocks","title":"Objects in CompetingClocks","text":"This describes the kinds of objects in CompetingClocks in order to explain how they work together.","category":"section"},{"location":"objects/#Distribution","page":"Objects in CompetingClocks","title":"Distribution","text":"At the heart of simulations are probability distributions. When this code refers to a distribution, it means a probability distribution function in time. When we sample a distribution, we randomly draw a time at which an event will happen.\n\nLet's take a Gamma distribution as an example. For the Gamma distribution, the probability distribution function, as you see it in Wikipedia's description,\n\nf(x) = fracbeta^alphaGamma(alpha)x^alpha - 1e^-beta x\n\nFor a simulation, we think of the distribution as being over time, and it's over the time since it was first possible for the event to happen, called t_e. We can write the Gamma distribution for t-t_e.\n\nf(t-t_e) = fracbeta^alphaGamma(alpha)(t-t_e)^alpha - 1e^-beta (t-t_e)\n\nIn Julia, the univariate distributions don't carry their enabling time as a parameter, so we store it separately.","category":"section"},{"location":"objects/#Competing-Clocks","page":"Objects in CompetingClocks","title":"Competing Clocks","text":"Let's say you make a simulation of rabbits eating kibble. A rabbit just picked up a piece of kibble, and the simulation decides there is a Gamma-distributed time at which it will be ready to eat the next bit of kibble. Meanwhile, another rabbit eats the last bit of kibble. That makes it impossible for the first rabbit to eat any kibble, so we say that its event is interrupted. That interruption was a result of the rabbits competing, but what the simulation sees is distributions competing to fire first, and we call them competing clocks.\n\nWe have a small naming problem because, while simulations use distributions in time, they sometimes turn them on or off. This combination of a known distribution (such as an Exponential or Gamma distribution) and the ability to temporarily pause it creates its own probability distribution, which we call a clock.\n\nFor example, let's make a model of a random walker on a chessboard. Given that the walker is at a grid location, (i j), that walker can move to one of four directions, (i-1 j), (i+1 j), (i j-1), or (i j+1). In order to simulate this, we might choose four Exponential distributions, one for each direction. When the walker reaches the side of the chessboard, it doesn't make sense to let it walk off the chessboard, so, at that moment, the simulation disables the ability to walk left. There is an Exponential distribution associated with walking left, but its hazard rate will be zero while the piece is at the side of the chessboard. The simulation considers \"move left\" a clock with an Exponential distribution whose firing is disabled.","category":"section"},{"location":"objects/#Sampler","page":"Objects in CompetingClocks","title":"Sampler","text":"The main responsibility of CompetingClocks.jl is to provide samplers of competing clocks. Given a list of enabled distributions, decide which one is next to fire and when it will fire.\n\nIn order to decide which clock fires next, a sampler needs some information.","category":"section"},{"location":"objects/#Initialization","page":"Objects in CompetingClocks","title":"Initialization","text":"The sampler may have a constructor to configure its memory usage or other resources.","category":"section"},{"location":"objects/#Update-Clock-State","page":"Objects in CompetingClocks","title":"Update Clock State","text":"For a continuous-time simulation, each event happens at a distinct time. Right after an event happens, the simulation is changed, and there are three possible ways clocks are affected.\n\nA clock may be disabled. For instance, if the event was crashing a car, you can no longer crash a crashed car.\nA clock may be enabled. For instance, once a person is infected, they can now infect all neighboring people.\nThe rate of a clock may change. We discussed moves on a chessboard earlier. Maybe there's now a breeze so that the rate to move right is greater than the rate to move left. The Exponential distributions would change accordingly.","category":"section"},{"location":"gsmp/#Generalized-Semi-Markov-processes","page":"Generalized Semi-Markov processes","title":"Generalized Semi-Markov processes","text":"","category":"section"},{"location":"gsmp/#Definition","page":"Generalized Semi-Markov processes","title":"Definition","text":"We said that a semi-Markov process is a set of random variables representing states and times of a system, X_iT_i. For each state at time T_i, the probability of the next state and time is some distribution, PX_i+1T_i+1X_iT_i. A generalized semi-Markov process (GSMP) also has the same states and times an the same distribution of next states and times, but it's more specific about how to calculate the probability.\n\nFor a GSMP, every change in state of the system, from X_i to X_i+1, is the result of an event E_j. Each event is associated with a distribution of event times, also called firing times, and those times are distributed as f_j(tau) where tau=t-T_i. The probability of the next state and time is determined by the minimum firing time of all events enabled at (X_iT_i). The distributions of these events are our competing clocks. When one event fires, it changes the state of the system, and, as a result, some events may be disabled and new events may be enabled.","category":"section"},{"location":"gsmp/#Considerations","page":"Generalized Semi-Markov processes","title":"Considerations","text":"Once we create this separate object, the event, it raises questions about corner cases. If two events change the state in the same way, then they are the same as one event whose hazard rate is the sum of the two events. If an event does not change the state, then this is like a self-loop in a Markov chain, and it complicates how we count states. As with the semi-Markov process, there remains the question of events which are immediate. If an event can happen at T_i+1=T_i, then it is possible for a system to fail to progress to a later time, and that's a problem.\n\nThe GSMP is a specific form of a semi-Markov process that requires PT_i+1X_iT_i (note the X_i+1 isn't on the left side) be determined by the minimum time to the next event, so it is determined solely by the f_j(tau). Each event is also defined by how it changes the state. If events change the state in a deterministic way, such that there is some function X_i+1=chi_j(X_i), then the likelihood of the system is the product of PX_i+1T_i+1X_iT_i for each time step, determined by the mimimum of event times. It is traditional to define generalized stochastic Petri nets [Haas:2002] this way, and Anderson and Kurtz's excellent short manuscript presents GSMP in the same light using counting processes [Anderson:2015]. However, Haas describes GSMP as allowing events to be stochastic. This means the likelihood has two terms, PE_jT_i+1X_iT_iPX_i+1E_j T_i+1 X_iT_i.","category":"section"},{"location":"gsmp/#Events-and-Physical-State","page":"Generalized Semi-Markov processes","title":"Events and Physical State","text":"Glynn presented GSMP by distinguishing the physical state of the system from the clock state [Glynn:1989], and Shedler is known for having the clearest presentation [Shedler:1987]. He represented the physical state as a set of states p=(p_1p_2p_3). Then each event, E_j, is defined in relation to those physical states:\n\nAn event is enabled by an enabling function which depends on a subset of physical states. This is a function e(p_lT_i)rightarrow textbool. In this notation, the curly bracked  indicate a \"set of\" something.\nWhen the event is not enabled, it is disabled.\nThe distribution of event times for an event is determined by a subset of physical states. This is a function f(p_mT_i)rightarrow textpdf.\nAn event creates a new state by changing some subset of the physical state, and that function can depend on another subset of the physical state, which isn't changed. This is a function chi(p_jp_kT_iT_i+1)rightarrow p_j.\n\nLook at all the subsets. There is a subset for enabling, transition rates, modified state, and catalyst state (which affects the action but isn't modified). If we think of the physical state as nodes in a graph and the events as nodes in a graph, then each subset associated with an event forms a different kind of edge in a bipartite graph.\n\nThe state of the system at any time is more than the physical state. It's the physical state plus the history of when each event clock was enabled. It is even reasonable to include in the state of the system every past event that fired and the time it fired, which is called the filtration of the stochastic process.\n\nThe idea behind introducing the notion of physical state and subsets of the physical state is to help think about a semi-Markov process where events live longer than a single time step. Glynn wanted to attach those long-lived competing processes to some state because, in practice, there is something about the state of the world that remains the same at each time step. The brilliance of Anderson and Kurtz's monograph is that they start their model as a set of counting processes [Anderson:2015]. Any state of the system is a predictable function of the filtration (event history) of the counting processes.\n\nIn the nomenclature of the GSMP, an event defines a change to substates, and every possible pair of states (X_i+1X_i) defines a transition. In general, the number of possible transitions is combinatorially larger than the number of possible events, as Haas covers in detail [Haas:2002].","category":"section"},{"location":"gsmp/#Formalisms-of-GSMP","page":"Generalized Semi-Markov processes","title":"Formalisms of GSMP","text":"There are many frameworks for simulation where the simulation is in continuous-time and the next event is determined by competition among clocks.\n\nSimulations of chemical reactions. Here, the physical state is chemical components and simulations are usually, but not always, Exponentially-distributed.\nQueueing theory models of networks, production, and computation. Here, the state is in queues and the events are reprsented by servers.\nEpidemiological models of disease spread among individuals. These models are often hand-coded, but they look a lot like chemical simulation with non-Exponential distributions.\nVector-addition systems are an older form of simulation where the state is a vector of integers and every event gives or takes from the vector of integers. Again, it looks a lot like chemical simulation.\nGeneralized stochastic Petri nets are what happens when engineers use GSMP. There is a strong vocabulary used to define the state as marking and places, but they conform to what is described above.","category":"section"},{"location":"gsmp/#Extensions-to-GSMP","page":"Generalized Semi-Markov processes","title":"Extensions to GSMP","text":"","category":"section"},{"location":"gsmp/#Atomic-Hazards-and-Differential-Equations","page":"Generalized Semi-Markov processes","title":"Atomic Hazards and Differential Equations","text":"Most presentations of GSMP assume that the distribution times of events are continuous distributions that are well-behaved, but the structure of the stochastic process remains well-defined if we allow distributions that have jumps. Examples of such distributions are delta functions. We could for instance, say that an event has a 1/3 chance of happening in 2 minutes an a 2/3 chance of happening in 5 minutes.\n\nMore commonly, what if the next step in a simulation were determined by an ordinary differential equation (ODE) that depends on the current state and time? A simulation could, at the enabling time, integrate the ODE to find when it predicts the next event and then enable a distribution that is a delta function centered at that predicted time.\n\nThe caveat for atomic hazards it's possible for two atomic hazards to happen at exactly the same time. CompetingClocks doesn't have a way to guarantee which of those events happen first. It certainly doesn't have a way to randomly select which event should happen from a configurable probability distribution. This is a feature specific to samplers that allow instantaneous and simultaneous events. The way we handle the possiblility of simultaneous events is to schedule atomic events relative to continuous-time events or to ensure that there is only one atomic hazard in a whole simulation.","category":"section"},{"location":"gsmp/#Markov-Decision-Process","page":"Generalized Semi-Markov processes","title":"Markov Decision Process","text":"In reinforcement learning, there is a model for how the world changes and a model for how to make decisions that depend on the world's history. For a GSMP-based decision process, there are two terms in the likelihood for the next state and time.\n\nPX_i+1T_i+1X_iT_iPA_j\n\nThe additional stochastic variable A_j is the decision at each step.","category":"section"},{"location":"gsmp/#Piecewise-deterministic-Markov-Process","page":"Generalized Semi-Markov processes","title":"Piecewise-deterministic Markov Process","text":"","category":"section"},{"location":"gsmp/#References","page":"Generalized Semi-Markov processes","title":"References","text":"[Anderson:2015] Anderson, David F., and Thomas G. Kurtz. Stochastic analysis of biochemical systems. Vol. 674. Berlin, Germany: Springer International Publishing, 2015.\n\n[Haas:2002] P. J. Haas, Stochastic Petri Nets: Modelling, Stability, Simulation, Springer-Verlag, New York, New York, USA, 2002.\n\n[Glynn:1989] P. Glynn, A GSMP formalism for discrete event systems, Proceedings of the IEEE 77 (1) (1989) 14– 23, ISSN 00189219, URL.\n\n[Shedler:1987] Shedler, Gerald S. Regeneration and networks of queues. Vol. 3. Springer Science & Business Media, 1987.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"delayed/#Delayed-Clocks","page":"Delayed Clocks","title":"Delayed Clocks","text":"","category":"section"},{"location":"delayed/#Introduction","page":"Delayed Clocks","title":"Introduction","text":"There are common uses for delayed clocks, also called delayed reactions.\n\nState-independent uninterruptible delay: a susceptible-infectious-recovered (SIR) model where the I to R transition occurs after some fixed duration tau.\nState-independent delay with state-independent interruption: consider the SIR model of type 1, but where there is an additional transition from I to death, with constant per-capita hazard mu. Then the I to R transition may be interrupted by death with probability 1-e^-mutau, which is known at initiation of the delay clock.\nState-independent delay with state-dependent interruption: from the example of [3], consider a predator (X) prey (Y) model (including the events birth of prey, predation, and death of predators). Now assume that when prey give birth the juvenile prey requires time tau before becoming an adult. Also assume that juveniles are subject to predation, so they have a per-capita hazard of beta X. Because the rate of predation upon juveniles is a function of state X which may change before completion of the maturation phase tau due to other events, probability of interruption is not known at initiation.\nState-dependent uninterruptible delay: Consider a model where larvae compete for resources, so that the duration of time tau(X) required for maturation is explicitly a function of the state X, but that the larval stage is invulnerable to death, and so cannot be interrupted. An example is the damselfly model of [4] without death.\nState-dependent delay with state-independent interruption: Consider the damselfly model of [4]; a larvae's maturation delay tau(X) depends on the density of other larvae as they compete for a resource, but maturing larvae also suffer constant per-capita mortality mu.\nState-dependent delay with state-dependent interruption: Consider complicating the damselfly model by making larval mortality state dependent, perhaps by introducing a predator class or cannibalism among the larvae.\n\nFor sampling, this means we want to associate a clock with two distributions.","category":"section"},{"location":"delayed/#Sampling-a-Delayed-Clock","page":"Delayed Clocks","title":"Sampling a Delayed Clock","text":"Create a sampler to support delays by passing the support_delayed=true flag. For example:\n\nbuilder = SamplerBuilder(Symbol, Float64;\n                         support_delayed=true,\n                         method=FirstToFireMethod(),\n                         common_random=true)\nsampler = SamplingContext(builder, rng)\n\nEnable a delayed clock using a pair of distributions.\n\nenable!(ctx, :recover, Exponential(0.5) => Dirac(5.0))\n\nThe first is the time until the reaction starts and the second is the time from the start to the end. Either or both can be of fixed duration or have distributions in time.\n\nIn the regular main loop, instead of calling next(sampler), call next_delayed(sampler).\n\nwhen, which, phase = next_delayed(sampler)\n\nThe phase is one of three symbols.\n\n:regular for clocks with no delays.\n:initiate for the first phase of a delayed clock.\n:complete for the second phase of a delayed clock.\n\nYou can delete!(sampler, clock) at any time, and it will delete either the initial and final, or just the final phase. It deletes whatever is currently enabled for that clock.\n\nWhen the main loop fires, it should specify which clock it's firing by adding the phase.\n\nfire!(ctx, which, phase, when) \n\nThe initial clock isn't hidden from the user because some simulations need to be notified when the initial clock fires.","category":"section"},{"location":"delayed/#Compatibility","page":"Delayed Clocks","title":"Compatibility","text":"Common random numbers and likelihoods are compatible with delayed clocks.\nThere isn't support for using arrays of distributions for vectorized importance sampling.\nIf you check for an enabled clock, you will see that its key includes the clock phase.\n\n","category":"section"},{"location":"quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"Learn CompetingClocks.jl basics by building a minimal simulation.","category":"section"},{"location":"quickstart/#The-Simulation","page":"Quickstart","title":"The Simulation","text":"A birth-death process, which is a population that grows and shrinks stochastically.\n\nBirth events at rate 2.0 per time unit per individual.\nDeath events are Gamma-distributed for each individual.\n\nusing CompetingClocks\nusing Distributions\nusing Random\n\nrng = Xoshiro(9834223)\nperson_cnt = 10\npopulation = Set(1:person_cnt)\n\n# Events will be identified by a tuple of type and individual.\nconst ClockKey = Tuple{Symbol,Int}\n# Create a sampler.\nsampler = SamplingContext(ClockKey, Float64, rng)\nenable!(sampler, (:birth, 0), Exponential(inv(length(population) * 2.0)))\nfor mort in population\n    enable!(sampler, (:death, mort), Gamma(inv(1.5)))\nend\nwhen, event = next(sampler)\nwhile !isnothing(event) && when < 100.0\n    fire!(sampler, event, when)\n    if event[1] == :birth\n        person_cnt += 1\n        push!(population, person_cnt)\n        enable!(sampler, (:death, person_cnt), Gamma(inv(1.5)))\n        enable!(sampler, (:birth, 0), Exponential(inv(length(population) * 2.0)))\n    elseif event[1] == :death\n        delete!(population, event[2])\n        enable!(sampler, (:birth, 0), Exponential(inv(length(population) * 2.0)))\n    else\n        error(\"Unknown event $event\")\n    end\n    when, event = next(sampler)\nend","category":"section"},{"location":"quickstart/#The-Core-Pattern","page":"Quickstart","title":"The Core Pattern","text":"Create a state.\nDefine a type for events.\nCreate a sampler.\nEnable initial events.\nAsk what happens next and\nfire! that event, which also disables the event.\nHandle changes to state and enabled events.\n\nYou tell it what could happen with enable!(), ask what happens next(), and decide what you want to fire!(). Why is next() separate from fire!()? So that you can stop a simulation at a fixed time rather than after an event.","category":"section"},{"location":"quickstart/#Next-Steps","page":"Quickstart","title":"Next Steps","text":"Learn More Techniques\n\nState management: Sample Main Loop - Better state handling.\nChoosing samplers: Choosing a Sampler - When to use which algorithm.\nReal examples:\nSIR Model\nReliability\nBirth-Death Process\nGene Expression\n\nAdvanced Features\n\nGet likelihoods\nVariance reduction\nBuild a framework\n\nAPI Reference\n\nBuild a Context\nCompetingClocks.enable! - Parameter documenation.\nCompetingClocks.next - Return value details.\nCompetingClocks.SamplerBuilder - Configuration options.","category":"section"},{"location":"memory/#Transitions-with-Memory","page":"Transitions with Memory","title":"Transitions with Memory","text":"Some transitions can be paused and restarted. These transitions are said to have memory [Zimmerman:2007]. For instance, let's say there is an industrial process that takes a Gamma-distributed amount of time.\n\nusing Distributions\nusing Plots\nbottler = Gamma(7.5, 1.0)\nx = 0.0:0.05:12.0\nplot(x, pdf.(bottler, x), xlims=(0.0, 12.0))\n\n<img src=\"data:image/png;base64,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\" />\n\nThen that process is interrupted, maybe because the machinery is required for a different process with higher priority, and then we restart the industrial process. What is the distribution of the restarted process, assuming it picks up where it left off? It's shifted to the left. Shifting the distribution doesn't just translate the pdf. It rescales the pdf so that the area under the curve is one and also changes the shape.\n\nsurvival = ccdf\nhazard(dist, x) = pdf(dist, x) / survival(dist, x)\nconditional_survival(dist, intermediate, x) = survival(dist, x) / survival(dist, intermediate)\nshiftpdf(dist, intermediate, x) = hazard(dist, x + intermediate) * conditional_survival(dist, intermediate, x + intermediate)\nremembered_age = 5.1\nplot(x, shiftpdf.(bottler, remembered_age, x), xlims=(0.0, 12.0))\n\n<img src=\"data:image/png;base64,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\" />\n\nAnother way to think about transitions with memory is that the zero-time of the process is now in the past. For CompetingClocks, that zero-time is called the enabling time. When we enable a transition, we give the enabling time as an absolute time in the simulation.\n\nenablingtime = currenttime - remembered_age\nenable!(sampler, clock, distribution, enablingtime, currenttime, RNG)`\n\nIf a simulation wants to include transitions that have memory, that simulation needs to store the total time a transition has been enabled and then use that to set the enabling time when it restarts a transtition.","category":"section"},{"location":"memory/#References","page":"Transitions with Memory","title":"References","text":"[Zimmerman:2007] Zimmermann, Armin. Stochastic discrete event systems. Springer, Berlin Heidelberg New York, 2007.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"samplingcontext/#Sampling-with-SamplingContext","page":"Sampling with SamplingContext","title":"Sampling with SamplingContext","text":"This is the main interface to the package.\n\nBuild the SamplingContext. The SamplerBuilder helps choose what hierarchical samplers to use within the SamplingContext. You will see the builder gives you options for debugging output, calculation of likelihoods, use of variance reduction (common random numbers), and more.\n\nClockKey = Int64\nTime = Float64\nrng = Xoshiro(899987987)\nbuilder = SamplerBuilder(ClockKey, Time)\nsampling = SamplingContext(builder, rng)\n\nYou can configure the builder by adding specific samplers for different kinds of clock keys. Each set of keys specified in an add_group! goes to its own sampler in the hierarchy.\n\nWrite a sampling loop. The sampler will tell you what event comes next and then you choose that event using fire!. However, you write your own state for the system and update that state according to the event. Firing the event disables that event.\n\nfunction one_epoch(model, sampler)\n    observe = Observer()\n    step_model!(model, sampler, (:on, 0), time(sampler))\n    when, which = next(sampler)\n    while !isnothing(which)\n        fire!(sampler, which, when)\n        step_model!(model, sampler, which, when)\n        when, which = next(sampler)\n        observer(model, when, which)\n    end\n    return observer\nend\n\nEnable/disable events during state update. When updating the model state, you might enable or disable events. Here is an example from gene expression.\n\nfunction translate_protein(model, sampler, individual, when, θ)\n    pre_event_total = count(x -> x[2], model.mrna)\n    model.protein += 1\n    if pre_event_total > 0\n        transrate1 = Exponential(inv(θ[:translate][1] * pre_event_total))\n        transrate2 = Exponential(inv(θ[:translate][2] * pre_event_total))\n        enable!(sampler, (:translate, 0), [transrate1, transrate2])\n    end\nend","category":"section"},{"location":"gen/turing_dist/#Bayesian-Inference-with-Turing.jl","page":"Bayesian Inference with Turing.jl","title":"Bayesian Inference with Turing.jl","text":"This page demonstrates how to perform Bayesian inference on the parameters of a continuous-time stochastic process using CompetingClocks.jl and Turing.jl.","category":"section"},{"location":"gen/turing_dist/#Statistical-Framework","page":"Bayesian Inference with Turing.jl","title":"Statistical Framework","text":"","category":"section"},{"location":"gen/turing_dist/#The-Model","page":"Bayesian Inference with Turing.jl","title":"The Model","text":"Consider a continuous-time birth-death process where, at time t with population N(t):\n\nBirths occur at rate beta N(t), i.e., waiting times are textExponential(1(beta N))\nDeaths follow independent textGamma(k theta) lifetimes for each individual\n\nThis is a generalized semi-Markov process (GSMP) because death times are non-exponential.","category":"section"},{"location":"gen/turing_dist/#The-Inference-Problem","page":"Bayesian Inference with Turing.jl","title":"The Inference Problem","text":"Given a fully observed event path on 0 T_textend:\n\nmathcalX = (e_i t_i)_i=1^m\n\nwhere e_i in (textbirth cdot) (textdeath textid) and t_1  t_2  cdots  t_m, we want the posterior:\n\np(beta k theta mid mathcalX) propto p(mathcalX mid beta k theta)  p(beta k theta)","category":"section"},{"location":"gen/turing_dist/#Path-Likelihood","page":"Bayesian Inference with Turing.jl","title":"Path Likelihood","text":"The path likelihood for a GSMP is:\n\np(mathcalX mid theta) = prod_i=1^m h_e_i(t_i) cdot prod_j in textenabled S_j(t_i^- to t_i) cdot prod_j in textenabled at  t_m S_j(t_m to T_textend)\n\nwhere h_j(t) is the hazard of clock j and S_j(a to b) is the survival probability over ab.\n\nCompetingClocks computes this via pathloglikelihood(sampler, T_end) when the sampler is constructed with path_likelihood=true.","category":"section"},{"location":"gen/turing_dist/#Integration-Pattern","page":"Bayesian Inference with Turing.jl","title":"Integration Pattern","text":"Turing requires a logpdf function for likelihood terms. We wrap the CompetingClocks path likelihood in a custom Distributions.jl type:\n\nstruct BirthDeathPathDist <: ContinuousMultivariateDistribution\n    β::Float64\n    shape::Float64\n    scale::Float64\n    N0::Int\nend\n\nThe logpdf method:\n\nCreates a SamplingContext with path_likelihood=true\nInitializes the model state and clocks\nReplays each observed event via fire! and state updates\nReturns pathloglikelihood(sampler, T_end)\n\nFrom Turing's perspective, the observed path is a single draw from this distribution:\n\npath ~ BirthDeathPathDist(β, shape, scale, N0)","category":"section"},{"location":"gen/turing_dist/#Complete-Example","page":"Bayesian Inference with Turing.jl","title":"Complete Example","text":"The full working example is available at examples/turing_dist.jl. Key components are shown below.","category":"section"},{"location":"gen/turing_dist/#Model-State-and-Events","page":"Bayesian Inference with Turing.jl","title":"Model State and Events","text":"using Random, Distributions, Turing, CompetingClocks\n\nconst ClockKey = Tuple{Symbol,Int}\n\nstruct BDParams\n    β::Float64       # per-individual birth rate\n    shape::Float64   # Gamma shape for lifetime\n    scale::Float64   # Gamma scale for lifetime\nend\n\nmutable struct BDState\n    population::Set{Int}\n    next_id::Int\nend\n\nBDState(N0::Int) = BDState(Set(1:N0), N0 + 1)","category":"section"},{"location":"gen/turing_dist/#Clock-Management","page":"Bayesian Inference with Turing.jl","title":"Clock Management","text":"function initialize!(state::BDState, sampler, params::BDParams)\n    N = length(state.population)\n    N == 0 && return\n    enable!(sampler, (:birth, 0), Exponential(1 / (params.β * N)))\n    for id in state.population\n        enable!(sampler, (:death, id), Gamma(params.shape, params.scale))\n    end\nend\n\nfunction handle_event!(state::BDState, sampler, evt::ClockKey, t::Float64, params::BDParams)\n    kind, idx = evt\n    if kind === :birth\n        new_id = state.next_id\n        state.next_id += 1\n        push!(state.population, new_id)\n        enable!(sampler, (:death, new_id), Gamma(params.shape, params.scale))\n    elseif kind === :death\n        delete!(state.population, idx)\n    end\n\n    if !isempty(state.population)\n        enable!(sampler, (:birth, 0), Exponential(1 / (params.β * length(state.population))))\n    else\n        disable!(sampler, (:birth, 0))\n    end\nend","category":"section"},{"location":"gen/turing_dist/#Path-Representation","page":"Bayesian Inference with Turing.jl","title":"Path Representation","text":"struct BDPath\n    events::Vector{ClockKey}\n    times::Vector{Float64}\n    T_end::Float64\nend\n\nBase.length(p::BDPath) = length(p.events)\nBase.isnan(p::BDPath) = any(isnan, p.times) || isnan(p.T_end)  # Required by Turing","category":"section"},{"location":"gen/turing_dist/#Simulation","page":"Bayesian Inference with Turing.jl","title":"Simulation","text":"function simulate_path(params::BDParams; N0::Int=10, T_end::Float64=10.0, rng=Random.Xoshiro(42))\n    state = BDState(N0)\n    sampler = SamplingContext(ClockKey, Float64, rng)\n    initialize!(state, sampler, params)\n\n    events, times = ClockKey[], Float64[]\n    while true\n        when, which = next(sampler)\n        (isnothing(which) || when > T_end) && break\n        push!(events, which); push!(times, when)\n        fire!(sampler, which, when)\n        handle_event!(state, sampler, which, when, params)\n    end\n    BDPath(events, times, T_end)\nend","category":"section"},{"location":"gen/turing_dist/#Custom-Distribution-for-Turing","page":"Bayesian Inference with Turing.jl","title":"Custom Distribution for Turing","text":"struct BirthDeathPathDist <: Distributions.ContinuousMultivariateDistribution\n    β::Float64\n    shape::Float64\n    scale::Float64\n    N0::Int\nend\n\nDistributions.length(d::BirthDeathPathDist) = 1\n\nfunction Distributions.logpdf(d::BirthDeathPathDist, path::BDPath)\n    params = BDParams(d.β, d.shape, d.scale)\n    rng = Random.Xoshiro(0)  # RNG unused since we only replay\n    sampler = SamplingContext(ClockKey, Float64, rng; path_likelihood=true)\n\n    state = BDState(d.N0)\n    initialize!(state, sampler, params)\n\n    for (evt, t) in zip(path.events, path.times)\n        fire!(sampler, evt, t)\n        handle_event!(state, sampler, evt, t, params)\n    end\n\n    ll = pathloglikelihood(sampler, path.T_end)\n    return ll isa AbstractVector ? ll[1] : ll\nend\n\n# Required by Turing for likelihood accumulation\nDistributions.loglikelihood(d::BirthDeathPathDist, path::BDPath) = Distributions.logpdf(d, path)","category":"section"},{"location":"gen/turing_dist/#Turing-Model","page":"Bayesian Inference with Turing.jl","title":"Turing Model","text":"@model function birthdeath_model(path::BDPath, N0::Int)\n    β     ~ LogNormal(log(0.3), 0.5)\n    shape ~ LogNormal(log(2.0), 0.5)\n    scale ~ LogNormal(log(0.5), 0.5)\n    path  ~ BirthDeathPathDist(β, shape, scale, N0)\nend","category":"section"},{"location":"gen/turing_dist/#Running-Inference","page":"Bayesian Inference with Turing.jl","title":"Running Inference","text":"# True parameters: ensure birth rate < death rate for finite simulation\n# With Gamma(2, 0.5), mean lifetime = 1.0, so death rate ≈ 1.0\n# Birth rate β = 0.3 < 1.0 gives declining population\ntrue_params = BDParams(0.3, 2.0, 0.5)\nobserved_path = simulate_path(true_params; N0=20, T_end=10.0, rng=Random.Xoshiro(1234))\n\nmodel = birthdeath_model(observed_path, 20)\nchain = sample(model, MH(), 500; rng=Random.Xoshiro(2024))\n\nExample output:\n\nParameter recovery:\n  β: true=0.300, estimated=0.263 ± 0.095\n  shape: true=2.000, estimated=2.073 ± 0.428\n  scale: true=0.500, estimated=0.545 ± 0.162","category":"section"},{"location":"gen/turing_dist/#Alternative:-@addlogprob!","page":"Bayesian Inference with Turing.jl","title":"Alternative: @addlogprob!","text":"Instead of defining a custom distribution, you can add the log-likelihood directly:\n\n@model function birthdeath_model_addlogprob(path::BDPath, N0::Int)\n    β     ~ LogNormal(log(0.3), 0.5)\n    shape ~ LogNormal(log(2.0), 0.5)\n    scale ~ LogNormal(log(0.5), 0.5)\n\n    params = BDParams(β, shape, scale)\n    sampler = SamplingContext(ClockKey, Float64, Random.Xoshiro(0); path_likelihood=true)\n    state = BDState(N0)\n    initialize!(state, sampler, params)\n\n    for (evt, t) in zip(path.events, path.times)\n        fire!(sampler, evt, t)\n        handle_event!(state, sampler, evt, t, params)\n    end\n\n    Turing.@addlogprob! pathloglikelihood(sampler, path.T_end)\nend","category":"section"},{"location":"gen/turing_dist/#Notes","page":"Bayesian Inference with Turing.jl","title":"Notes","text":"Parameter stability: For birth-death processes, ensure β < 1/(shape × scale) to avoid population explosion during simulation. Here, with β=0.3 and Gamma(2, 0.5) (mean lifetime 1.0), the death rate exceeds the birth rate.\n\nSampler choice: The Metropolis-Hastings sampler (MH()) works well for this likelihood. Gradient-based samplers like NUTS require differentiable likelihoods, which may not be straightforward for path-based models.\n\nMultiple distributions: CompetingClocks supports computing likelihoods under multiple parameter settings simultaneously via likelihood_cnt > 1 in the SamplingContext, useful for importance sampling schemes.","category":"section"},{"location":"background/#Markov-Processes","page":"Markov Processes","title":"Markov Processes","text":"This addresses two main points, how to specify a model for the library using distributions defined by hazards and why such a specification, with its initial conditions, is sufficient to define the trajectory for a model.","category":"section"},{"location":"background/#The-Hazard-from-Survival-Analysis","page":"Markov Processes","title":"The Hazard from Survival Analysis","text":"","category":"section"},{"location":"background/#Discrete-case","page":"Markov Processes","title":"Discrete case","text":"The discrete case is much easier to understand than the continuous case because it can be explained without employing any results from calculus. Throughout this section, mathbfX will be assumed to real-valued random variable. For example, mathbfX could represent latent periods for measles.\n\nIt frequently happens that random samples of the real valued variables such as mathbfX are actually analyzed on a discrete scale. For example Stocks' data on latent periods of measles in latent_period is based on daily visits by patients [Stocks:1931].\n\nThe (cumulative) distribution of mathbfX is defined as\n\nF_X(k) = mathcalPx le k\n\nassuming F_X(infty) = 1. The density can be expressed as the difference in adjacent values of the distribution\n\nbeginaligned\nf_X(k)  =  mathcalPX=k \n          =  mathcalPXle k - mathcalPX le k-1  \n      =  F_X(k) - F_X(k-1)\nendaligned\n\nFor Stocks' data in latent_period, the density at day k should be interpreted as the probability of the appearance of symptoms since the previous visit on day k-1.\n\nThe hazard is defined as the conditional probability that the value of a random selection from mathbfX equals k given it this value is already known to exceed k-1. Using the usual rules for computing conditional probabilities, the hazard is given by the following ratio\n\nbeginaligned\nh_X(k)  =  mathcalPX=k  k-1X \n          =  fracf_X(k)1 - F_X(k-1)\nendaligned\n\nIn the case of Stocks' data, the hazards shown in latent_period_hazard would correspond to the probability of symptoms appearing at day k given that the patient had not displayed symptoms at any previous visit. As time goes on, patients who have already developed symptoms effectively reduce the pool of patients in the study who are still in a state where they might first present symptoms on day k. This is the origin of the term in the denominator.\n\n(Image: Figure 2. Estimated hazards of latent periods for measles in London circa 1931)\n\nOn any given day, the hazard for latent periods can be interpreted as the rate of appearance of symptoms per asymptomatic (infected but not yet symptomatic) patient per day. For example, the hazard inferred from the Weibull distribution is approximately 015 on day 10. In other words, 15% of the patients that are asymptomatic on day 9 will present symptoms when examined on day 10.\n\n(Image: Figure 3. Each participant of the Stocks study could either become symptomatic or leave the study. Focusing on the hazard accounts for the effect of those who leave.)\n\nThis interpretation is extremely important because it connects a hazard with a rate for a specific process, and that rate has well defined units of measurement. In addition, it clarifies how rate parameters should be estimated from observational data. Failure to account for the shrinking pool over time is commonplace. In this case it would lead to a systematic errors in the estimation of process rates, especially at long times when the depletion effect is most pronounced.","category":"section"},{"location":"background/#Continuous-case","page":"Markov Processes","title":"Continuous case","text":"The random variable mathbfX is again assumed to be a real-valued, but the measurements will not be binned as above. The cumulative distribution not an integer k but a continuous time interval, tau.\n\nF_X(tau)=Pxletau\n\nassuming F_X(infty)=1. The density is the derivative of the cumulative distribution. The concept of the hazard is part of survival analysis, where survival is G_X(tau)=1-F_X(tau), and represents the probability the random variable, a time interval, is longer than tau. One expression for the hazard is that the density of the random variable is equal to the probability it survives to a time tau multiplied by the hazard rate for firing at time tau, or, in probabilities,\n\nPtauxletau+dtaudtau=PtauxPtauxletau+dtau+dtautaux\n\nWriting this same equation with its almost-sure equivalents defines the continuous hazard, lambda_X(tau),\n\nf_X(tau)=G_X(tau)lambda_X(tau)\n\nThis is a rearrangement away from the definition of the discrete case.","category":"section"},{"location":"background/#Finite-State-Machines-Generate-Trajectories","page":"Markov Processes","title":"Finite State Machines Generate Trajectories","text":"This library accepts a specification of a model in terms of hazards, an initial condition, and produces trajectories. This set of high-level steps to simulation (specify, initialize, step) has a well-defined abstraction called a finite state machine. It isn't the finite state machine familiar to programmers but a mathematical model, coming from category theory, for a particularly simple class of computing systems. At a conceptual level, a finite state machine can be considered a black box that receives a sequence of input signal and produces an output signal for each input signal. Internally, the black box maintains a state -- some sort of finite summary representation of the sequence of input signals encountered so far. For each input signal, the box performs two operations. In both cases, the decision depends on the current internal state and the identity of the input signal just received.\n\nChose next state\nGenerate output token\n\nIt is helpful to view the finite state machine layer as a mechanism to simulate a Markov chain or Markov process.","category":"section"},{"location":"background/#Markov-Chain-for-Discrete-Time-Trajectories","page":"Markov Processes","title":"Markov Chain for Discrete-Time Trajectories","text":"Roughly speaking, a Markov chain, mathbfX, is a probabilistic system that makes random jumps among a finite set of distinct states, s_0 s_1 s_2 ldots s_N such that the probability of choosing the next state, X_n+1 depends only on the current state, X_n. In mathematical terms, the conditional probabilities for state transitions must satisfy\n\nmathcalPX_n+1 = s_l  X_0=s_i X_1=s_j ldots X_n=s_k =\nmathcalPX_n+1 = s_l  X_n=s_k\n\nSince more distant history does not affect future behavior, Markov chains are sometimes characterized as memoryless.\n\nThis relation can be iterated to compute the conditional probabilities for multiple time steps\n\nmathcalPX_n+2 = s_m  X_n=s_k = sum_l mathcalPX_n+2 = s_m \nX_n+1=s_l mathcalPX_n+1 = s_l  X_n=s_k\n\nNote, the transition probabilities mathcalPX_n+1 = s_l  X_n=s_k may depend on time (through the index n). These so-called time-inhomogeneous Markov chains arise when the system of interest is driven by external entities. Chains with time-independent conditional transition probabilities are called time-homogeneous. The dynamics of a time-homogeneous Markov chain is completely determined by the initial state and the transition probabilities. All processes considered in this document are time-homogeneous.","category":"section"},{"location":"background/#Markov-Process-for-Continuous-Time-Trajectories","page":"Markov Processes","title":"Markov Process for Continuous-Time Trajectories","text":"A Markov process is a generalization of the Markov chain such that time is viewed as continuous rather than discrete. As a result, it makes sense to record the times at which the transitions occur as part of the process itself.\n\nThe first step in this generalization is to define a stochastic process mathbfY that includes the transition times as well as the state, Y_n = (s_jt_n).\n\nThe second step is to treat time on a truly continuous basis by defining a new stochastic process, mathbfZ, from mathbfY by the rule Z_t = s_k in the time interval t_n le t  t_n+1 given Y_n = (s_k t_n) . In other words, mathbfZ_t is a piecewise constant version of mathbfY as shown in piecewise_Z.\n\n(Image: Figure 4. **Realization of a continuous time stochastic process and associated Markov chain.**)\n\nA realization of the process mathbfY is defined by the closed diamonds (left end points) alone. Similarly, a realization of the process mathbfZ_t is illustrated by the closed diamonds and line segments. The closed and open diamonds at the ends of the line segment indicate that the segments include the left but not the right end points.\n\nThe memoryless property for Markov processes is considerably more delicate than in the case of Markov chain because the time variable is continuous rather than discrete. In the case of mathbfY, the conditional probabilities for state transitions of must satisfy\n\nmathcalPY_n+1 = (s_lt_n+1)  Y_0=(s_i t_0) Y_1=(s_j t_1)\nldots Y_n=(s_k t_n) =\nmathcalPY_n+1 = (s_l t_n+1)  Y_n=(s_k t_n)\n\nThe proper generalization of the requirement of time-homeogeneity stated previously for Markov chains is that joint probability be unchanged by uniform shifts in time\n\nmathcalPZ_t+tau  Z_s+tau = mathcalPZ_t  Z_s \n\nfor 0st and tau  0. Stochastic processes with shift invariant state transition probabilities are called stationary.\n\nWhen we examined hazard rates above, we were examining the rate of transitions for a Markov process. The overall probability of the next state of the Markov process is called the core matrix,\n\nmathcalPZ_t  Z_s =Q_ij(t_n+1-t_n)\n\nindicating a state change between the states (s_is_j). The derivative of this is a rate,\n\nq_ij(t_n+1-t_n)=fracdQ_ij(t_n+1-t_n)dt\n\nwhich is a joint distribution over states and time intervals. Normalization for this quantity sums over possible states and future times,\n\n1=int_0^infty sum_j  q_ij(s)ds\n\nThe survival, in terms of the core matrix, is\n\nG_i(tau)=1-int_0^tau sum_k  q_ik(s)ds\n\nThis means our hazard is\n\nlambda_ij(tau)=fracq_ij(tau)1-int_0^tau sum_k  q_ik(s)ds\n\nFor the measles example, the set of future states j of each individual include symptomatic and all the possible other ways an individual leaves the study, so you can think of j=mboxleft town. In practice, we build a hazard in two steps. First, count the probability over all time for any one eventual state j. This is the same stochastic probability pi_ij that is seen in Markov chains. Second, measure the distribution of times at which intervals enter each new state j, given that they are headed to that state. This is called the holding time, h_ij(tau), and is a conditional probability. Together, these two give us the core matrix,\n\nq_ij(tau)=pi_ijh_ij(tau)\n\nNote that h_ij(tau) is a density whose integral H_ij(tau) is a cumulative distribution. If we write the same equation in terms of probabilities, we see that it amounts to separating the Markov process into a marginal and conditional distribution.\n\nbeginaligned\nq_ij(tau)=fracddtauPZ_tZ_s \n=fracddtauPs_js_it_nPt_n-1-t_nletaus_is_jt_n \n   =  Ps_js_it_nfracddtauPt_n-1-t_nletaus_is_jt_n \n   =  pi_ijfracddtauH_ij(tau) \n   =  pi_ijh_ij(tau)\nendaligned\n\nChoosing the other option for the marginal gives us the waiting time formulation for the core matrix. It corresponds to asking first what is the distribution of times at which the next event happens, no matter which event, and then asking which events are more likely given the time of the event.\n\nbeginaligned\nq_ij(tau)=fracddtauPZ_tZ_s \n=fracddtauPs_js_it_nt_n+1Pt_n-1-t_nletaus_it_n \n   =  fracddtau(Pi_ij(tau)W_i(tau)) \n   =  pi_ij(tau)fracddtauW_i(tau) \n   =  pi_ij(tau)w_i(tau)\nendaligned\n\nWhile the waiting time density w_i(tau), is the derivative of the waiting time, we won't end up needing to relation pi_ij(tau) to Pi_ij(tau) when finding trajectories or computing hazards, so the more complicated relationship won't be a problem.","category":"section"},{"location":"background/#References","page":"Markov Processes","title":"References","text":"[Stocks:1931]\tP. Stocks, “Incubation period of measles,” British Medical Journal 1(3655): p. 157.","category":"section"},{"location":"background/#Acknowledgement","page":"Markov Processes","title":"Acknowledgement","text":"This section comes was created by the Analytical Framework for Infectious Disease Dynamics (AFIDD) group at Cornell University in conjunction with the USDA Agricultural Research Service. This work was supported by the Science & Technology Directorate, Department of Homeland Security via interagency agreement no. HSHQDC-10-X-00138.","category":"section"},{"location":"low_level_interface/#Low-level-Sampler-Interface","page":"Low-level Sampler Interface","title":"Low-level Sampler Interface","text":"The main interface to the package is the SamplingContext. The SamplingContext contains sampling algorithms and other helper classes. This describes the interface to underlying sampling algorithms, which differ slightly:\n\nThey don't hold a random number generator internally so it is passed as an argument.\nAll input times are absolute, so the enabling time of a distribution is given in absolute time.","category":"section"},{"location":"low_level_interface/#Common-Interface-to-Low-level-Samplers","page":"Low-level Sampler Interface","title":"Common Interface to Low-level Samplers","text":"","category":"section"},{"location":"low_level_interface/#Use-a-Sampler","page":"Low-level Sampler Interface","title":"Use a Sampler","text":"Low-level sampler interface. Most users should use SamplingContext instead, which is documented in Context Interface.","category":"section"},{"location":"low_level_interface/#Query-a-Sampler","page":"Low-level Sampler Interface","title":"Query a Sampler","text":"","category":"section"},{"location":"low_level_interface/#Copies-of-Samplers","page":"Low-level Sampler Interface","title":"Copies of Samplers","text":"","category":"section"},{"location":"low_level_interface/#Individual-Samplers","page":"Low-level Sampler Interface","title":"Individual Samplers","text":"","category":"section"},{"location":"low_level_interface/#Hierarchical-Sampling","page":"Low-level Sampler Interface","title":"Hierarchical Sampling","text":"","category":"section"},{"location":"low_level_interface/#Helper-Classes","page":"Low-level Sampler Interface","title":"Helper Classes","text":"","category":"section"},{"location":"low_level_interface/#CompetingClocks.SSA","page":"Low-level Sampler Interface","title":"CompetingClocks.SSA","text":"SSA{KeyType,TimeType}\n\nThis abstract type represents a stochastic simulation algorithm (SSA). It is parametrized by the clock ID, or key, and the type used for the time, which is typically a Float64. The type of the key can be anything you would use as a dictionary key. This excludes mutable values but includes a wide range of identifiers useful for simulation. For instance, it could be a String, but it could be a Tuple{Int64,Int64,Int64}, so that it indexes into a complicated simulation state.\n\n\n\n\n\n","category":"type"},{"location":"low_level_interface/#CompetingClocks.enable!-Union{Tuple{T}, Tuple{K}, Tuple{SSA{K, T}, K, UnivariateDistribution, T, T, AbstractRNG}} where {K, T}","page":"Low-level Sampler Interface","title":"CompetingClocks.enable!","text":"enable!(sampler, clock, distribution, enablingtime, currenttime, RNG)\n\nTell the sampler to start a clock.\n\nsampler::SSA{KeyType,TimeType} - The sampler to tell.\nclock::KeyType - The ID of the clock. Can be a string, integer, tuple, etc.\ndistribution::Distributions.UnivariateDistribution\nenablingtime::TimeType - The zero time for the clock's distribution, in absolute time. Usually equal to when.\nwhen::TimeType - The current time of the simulation.\nrng::AbstractRNG - A random number generator.\n\nThese times are absolute since the start of the simulation. The current time should be when. If you want to shift the distribution so that this event cannot happen for a little while then choose enablingtime > when. If you want to modify the distribution by shifting it left, then choose enablingtime < when. Usually, enablingtime == when. It is also possible to always use enablingtime == when and use the truncated() function to modify distributions.\n\n\n\n\n\n","category":"method"},{"location":"low_level_interface/#CompetingClocks.reset!-Union{Tuple{SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}","page":"Low-level Sampler Interface","title":"CompetingClocks.reset!","text":"reset!(sampler)\n\nAfter a sampler is used for a simulation run, it has internal state. This function resets that internal state to the initial value in preparation for another sample run.\n\n\n\n\n\nreset!(sampling)\n\nClear all enabled clocks (and delayed state if present) and reset time to the fixed start time.\n\n\n\n\n\n","category":"method"},{"location":"low_level_interface/#CompetingClocks.disable!-Union{Tuple{T}, Tuple{K}, Tuple{SSA{K, T}, K, T}} where {K, T}","page":"Low-level Sampler Interface","title":"CompetingClocks.disable!","text":"disable!(sampler, clock, when)\n\nTell the sampler to forget a clock. We include the current simulation time because some Next Reaction methods use this to optimize sampling.\n\n\n\n\n\n","category":"method"},{"location":"low_level_interface/#CompetingClocks.next-Union{Tuple{T}, Tuple{K}, Tuple{SSA{K, T}, T, AbstractRNG}} where {K, T}","page":"Low-level Sampler Interface","title":"CompetingClocks.next","text":"next(sampler, when, rng)\n\nAsk the sampler for what happens next, in the form of (when, which)::Tuple{TimeType,KeyType}. rng is a random number generator.\n\n\n\n\n\n","category":"method"},{"location":"low_level_interface/#CompetingClocks.timetype-Union{Tuple{SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}","page":"Low-level Sampler Interface","title":"CompetingClocks.timetype","text":"timetype(sampler)\n\nReturn the type of clock times.\n\n\n\n\n\ntimetype(sampling)\n\nTime type T, usually Float64.\n\n\n\n\n\n","category":"method"},{"location":"low_level_interface/#CompetingClocks.enabled-Union{Tuple{SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}","page":"Low-level Sampler Interface","title":"CompetingClocks.enabled","text":"enabled(sampler)\n\nReturns a read-only set of currently-enabled clocks.\n\n\n\n\n\n","category":"method"},{"location":"low_level_interface/#Base.length-Tuple{SSA}","page":"Low-level Sampler Interface","title":"Base.length","text":"length(sampler)::Int64\n\nReturn the number of stored clocks.\n\n\n\n\n\n","category":"method"},{"location":"low_level_interface/#Base.getindex-Union{Tuple{T}, Tuple{K}, Tuple{SSA{K, T}, K}} where {K, T}","page":"Low-level Sampler Interface","title":"Base.getindex","text":"getindex(sampler, clock::KeyType)\n\nReturn stored state for a particular clock. If the clock does not exist, a KeyError will be thrown. Different samplers have different stored state.\n\n\n\n\n\n","category":"method"},{"location":"low_level_interface/#Base.keys-Tuple{SSA}","page":"Low-level Sampler Interface","title":"Base.keys","text":"keys(sampler)\n\nReturn all stored clocks as a vector.\n\n\n\n\n\n","category":"method"},{"location":"low_level_interface/#CompetingClocks.clone-Union{Tuple{SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}","page":"Low-level Sampler Interface","title":"CompetingClocks.clone","text":"clone(sampler)\n\nGiven an existing sampler, make a copy that has the same type and same constructor options but has no data in it. Use this to initialize an array of samplers.\n\n\n\n\n\nclone(ds::DelayedState)\n\nDeep copy of a DelayedState.\n\n\n\n\n\n","category":"method"},{"location":"low_level_interface/#CompetingClocks.copy_clocks!-Union{Tuple{SSA{K, T}}, Tuple{T}, Tuple{K}} where {K, T}","page":"Low-level Sampler Interface","title":"CompetingClocks.copy_clocks!","text":"copy_clocks!(destination_sampler, source_sampler)\n\nThis copies the state of the source sampler to the destination sampler, replacing the current state of the destination sampler. This is useful for splitting techniques where you make copies of a simulation and restart it with different random number generators.\n\n\n\n\n\n","category":"method"},{"location":"low_level_interface/#CompetingClocks.jitter!-Union{Tuple{T}, Tuple{K}, Tuple{SSA{K, T}, T, AbstractRNG}} where {K, T}","page":"Low-level Sampler Interface","title":"CompetingClocks.jitter!","text":"jitter!(sampler, when, rng)\n\nTakes a sampler that is at a statistically-valid stopping time (this is a technical term) and resamples all clocks currently-enabled so that this copy of the sampler will yield different results from another copy of the sampler despite its internal cache of clock data.\n\n\n\n\n\n","category":"method"},{"location":"low_level_interface/#CompetingClocks.CombinedNextReaction","page":"Low-level Sampler Interface","title":"CompetingClocks.CombinedNextReaction","text":"CombinedNextReaction{KeyType,TimeType}()\n\nThis combines Next Reaction Method and Modified Next Reaction Method. The Next Reaction Method is from Gibson and Bruck in their 2000 paper called \"Efficient Exact Stochastic Simulation of Chemical Systems with Many Species and Many Channels\".  The Modified Next Reaction Method is from David F. Anderson's 2007 paper,  \"A modified Next Reaction Method for simulating chemical systems with time dependent propensities and delays\".  Both methods reuse draws of random numbers. The former works by accumulating  survival of a distribution in a linear space and the latter works by accumulating  survival of a distribution in a log space.\n\nEach enabled clock specifies a univariate distribution from the Distributions package. Every distribution is more precise being sampled in the manner of the Next Reaction method (linear space) or the manner of the Modified Next Reaction method (log space). This sampler chooses which space to use depending on the type of the UnivariateDistribution and based on performance timings that are done during package testing. Defaults are set for those distributions included in the Distributions.jl package. If you want to add a distribution, then define:\n\nsampling_space(::MyDistribution) = LogSampling\n\nIf you want to override a choice in the library, then create a sub-type of the given distribution, and specify its sampling space.\n\nstruct LinearGamma <: Distributions.Gamma end\nsampling_space(::LinearGamma) = LinearSampling\n\nIf you want to test a distribution, look at tests/nrmetric.jl to see how distributions are timed.\n\n\n\n\n\n","category":"type"},{"location":"low_level_interface/#CompetingClocks.DirectCall","page":"Low-level Sampler Interface","title":"CompetingClocks.DirectCall","text":"DirectCall{KeyType,TimeType,TreeType}()\n\nDirectCall is responsible for sampling among Exponential distributions. It samples using the Direct method. In this case, there is no optimization to that Direct method, so we call it DirectCall because it recalculates everything every time you call it.\n\nThe algorithm for the Direct Method relies heavily on what data structure it uses to maintain a list of hazard rates, such that it can know the sum of those hazards and index into them using a random value. This struct has a default constructor that chooses a data structure for you, but there are several options.\n\nExample\n\nIf we know that our simulation will only use a small number of different clock keys, then it would make sense to use a data structure that disables clocks by zeroing them out, instead of removing them from the list. This will greatly reduce memory churn. We can do that by changing the underlying data structure.\n\nprefix_tree = BinaryTreePrefixSearch{T}()\nkeyed_prefix_tree = KeyedKeepPrefixSearch{K,typeof(prefix_tree)}(prefix_tree)\nsampler_noremove = DirectCall{K,T,typeof(keyed_prefix_tree)}(keyed_prefix_tree)\n\n\n\n\n\n","category":"type"},{"location":"low_level_interface/#CompetingClocks.FirstReaction","page":"Low-level Sampler Interface","title":"CompetingClocks.FirstReaction","text":"FirstReaction{KeyType,TimeType}()\n\nThis is the classic first reaction method for general distributions.  Every time you sample, this goes to each distribution and asks when it would fire. Then it takes the soonest and throws out the rest of the sampled times until the next sample. It can also be very fast when there are only a few clocks to sample.\n\nOne interesting property of this sampler is that you can call next() multiple times in order to get a distribution of next firing clocks and their times to fire.\n\n\n\n\n\n","category":"type"},{"location":"low_level_interface/#CompetingClocks.FirstToFire","page":"Low-level Sampler Interface","title":"CompetingClocks.FirstToFire","text":"FirstToFire{KeyType,TimeType}()\n\nThis sampler is often the fastest for non-exponential distributions. When a clock is first enabled, this sampler asks the clock when it would fire and saves that time in a sorted heap of future times. Then it works through the heap, one by one. When a clock is disabled, its future firing time is removed from the list. There is no memory of previous firing times.\n\nThis uses a DataStructures.MutableBinaryMinHeap which is a Fibonacci heap. It has been tested against many other heaps and rarely loses by more than a few percent, so we are sticking with it.\n\n\n\n\n\n","category":"type"},{"location":"low_level_interface/#CompetingClocks.PSSACR","page":"Low-level Sampler Interface","title":"CompetingClocks.PSSACR","text":"PSSACR{KeyType,TimeType}(; ngroups::Int=64)\n\nExact, continuous-time sampler using composition–rejection over groups.\n\nAssumptions:\n\nEach enabled clock is Exponential with rate λ (i.e., distribution Exponential(θ) where λ=1/θ).\nThe sampler maintains group-wise sums and maxima of rates.\nTime to next event is drawn from Exp(∑λ), and the firing key is drawn by a two-stage selection: group by probability ∝ group-sum, then within-group by rejection from a uniform proposal with acceptance λ/λ_max_group.\n\nPerformance notes:\n\nChoose ngroups so that groups remain small and rate magnitudes similar. If you possess \"owner\" metadata (partial-propensity style), call assign_group! before enable! to place clocks with common owners into the same group.\n\nReferences:\n\nR. Ramaswamy & I. F. Sbalzarini, \"A partial-propensity variant of the composition-rejection SSA\", J. Chem. Phys. 132, 044102 (2010).\nA. Slepoy, A. P. Thompson, S. J. Plimpton, \"A constant-time kinetic Monte Carlo algorithm...\", J. Chem. Phys. 128, 205101 (2008).\n\n\n\n\n\n","category":"type"},{"location":"low_level_interface/#CompetingClocks.RSSA","page":"Low-level Sampler Interface","title":"CompetingClocks.RSSA","text":"RSSA{KeyType,TimeType}(; bound_factor=1.05)\n\nRejection-based SSA with global Fenwick tree for candidate selection. This is for exponential distributions only not time-dependent rates.\n\nbound_factor ≥ 1.0 controls default upper bounds: \\bar ai ← max(\\bar ai, boundfactor * ai). Set to 1.0 for no rejections (reduces to direct-method timing with tree selection).\n\nAlgorithmic core:\n\nMaintain per-clock true rate ai and a certified upper bound \bar ai >= a_i.\nMaintain Ā = sumi \bar ai and a Fenwick tree over { \bar a_i } for O(log N) sampling.\nDraw candidate times from Exp(Ā). Select candidate clock i by Categorical(\bar a_i/Ā).\nAccept with probability ai / \bar ai; otherwise reject and continue thinning.\n\nExactness: standard thinning of a Poisson process with rate Ā, with acceptance ai/\bar ai, yields the target Markov jump process (homogeneous propensities). See Thanh et al. (2014, 2015).\n\nNotes:\n\nThis implementation targets time-homogeneous propensities (Exponential only). For time-dependent rates (tRSSA), you need piecewise-time envelopes and an integral sampler; these can be added as a thin extension without changing the public interface.\n\n\n\n\n\n","category":"type"},{"location":"low_level_interface/#CompetingClocks.Petri","page":"Low-level Sampler Interface","title":"CompetingClocks.Petri","text":"Petri{KeyType,TimeType}()\n\nIf you want to test a simulation, it can be helpful to test unlikely events. This sampler adopts the Petri net rule for which clock fires next: it's randomly chosen among all enabled events. The returned time is always the previous time plus one.\n\n\n\n\n\n","category":"type"},{"location":"low_level_interface/#CompetingClocks.MultipleDirect","page":"Low-level Sampler Interface","title":"CompetingClocks.MultipleDirect","text":"MultipleDirect{SamplerKey,K,Time,Chooser} <: SSA{K,Time}\n\nMultipleDirect is a sampler that contains multiple prefix-search data structures. Here SamplerKey is an identifier for the sampler. K is the type of the Clock key. Time is a Float64 or other clock time. Chooser is a function that selects a prefix-search given a clock key. This differs from a MultiSampler because this works only for exponential distributions, and it combines them by summing propensities.\n\n\n\n\n\n","category":"type"},{"location":"low_level_interface/#CompetingClocks.MultiSampler","page":"Low-level Sampler Interface","title":"CompetingClocks.MultiSampler","text":"MultiSampler{SamplerKey,Key,Time}(which_sampler::Chooser) <: SSA{Key,Time}\n\nA sampler returns the soonest event, so we can make a hierarchical sampler that returns the soonest event of the samplers it contains. This is useful because the performance of a sampler depends on the type of the event. For instance, some simulations have a few fast events and a lot of slow ones, so it helps to split them into separate data structures.\n\nThe SamplerKey is the type of an identifier for the samplers that this MultiSampler contains. The which_sampler argument is a strategy object that decides which event is sampled by which contained sampler. There is an example of this below.\n\nOnce a clock is first enabled, it will always go to the same sampler. This sampler remembers the associations, which could increase memory for simulations with semi-infinite clocks.\n\nExamples\n\nLet's make one sampler for exponential distributions, one for a few clocks we know will be fast and one for slower clocks. We can name them with symbols. The trick is that we need to direct each kind of distribution to the correct sampler. Use a Float64 for time and each clock can be identified with an Int64.\n\nusing CompetingClocks\nusing Distributions: Exponential, UnivariateDistribution\n\nstruct ByDistribution <: SamplerChoice{Int64,Symbol} end\n\nfunction CompetingClocks.choose_sampler(\n    chooser::ByDistribution, clock::Int64, distribution::Exponential\n    )::Symbol\n    return :direct\nend\nfunction CompetingClocks.choose_sampler(\n    chooser::ByDistribution, clock::Int64, distribution::UnivariateDistribution\n    )::Symbol\n    if clock < 100\n        return :fast\n    else\n        return :slow\n    end\nend\nsampler = MultiSampler{Symbol,Int64,Float64}(ByDistribution())\nsampler[:direct] = OptimizedDirect{Int64,Float64}()\nsampler[:fast] = FirstToFire{Int64,Float64}()\nsampler[:slow] = FirstToFire{Int64,Float64}()\n\n\n\n\n\n","category":"type"},{"location":"low_level_interface/#CompetingClocks.DebugWatcher","page":"Low-level Sampler Interface","title":"CompetingClocks.DebugWatcher","text":"DebugWatcher()\n\nFor debugging, it helps to have visibility into the simulation. This Watcher records everything that is enabled or disabled as a list of all enables and all disabled. It's the complete event history, and you can think of it as the filtration for the process going forward.\n\nwatcher = DebugWatcher{String}()\n# enable and disable some things.\n(watcher.enabled[1].clock,\nwatcher.enabled[1].distribution,\nwatcher.enabled[1].te,\nwatcher.enabled[1].when)\n\n\n\n\n\n","category":"type"},{"location":"low_level_interface/#CompetingClocks.TrackWatcher","page":"Low-level Sampler Interface","title":"CompetingClocks.TrackWatcher","text":"TrackWatcher{K,T}()\n\nThis Watcher doesn't sample. It records everything enabled. You can iterate over enabled clocks with a for-loop. If we think of the model as providing changes in which transitions are enabled or disabled, this Watcher accumulates those changes to provide a consistent list of all enabled transitions. Together, a model and this Watcher provide the Semi-Markov core matrix, or the row of it that is currently known.\n\nfor entry in tracker\n    entry.clock\n    entry.distribution\n    entry.te\n    entry.when\nend\n\n\n\n\n\n","category":"type"},{"location":"low_level_interface/#CompetingClocks.TrajectoryWatcher","page":"Low-level Sampler Interface","title":"CompetingClocks.TrajectoryWatcher","text":"TrajectoryWatcher{K,T}\n\nThis doesn't sample but calculates the likelihood of the path of samples from start to finish. It has many of the same interface functions as a sampler, but the core value is in the pathloglikelihood function.\n\n\n\n\n\n","category":"type"},{"location":"low_level_interface/#CompetingClocks.PathLikelihoods","page":"Low-level Sampler Interface","title":"CompetingClocks.PathLikelihoods","text":"PathLikelihoods{K,T}\n\nCalculates the likelihood of one path of events and times according to a vector of different distributions. This accepts a vector of distributions in each enable! call. This can be useful for tuning distribution parameters, but its main use is for importance sampling with mixtures of distribution parameters in order to stabilize importance sampling.\n\n\n\n\n\n","category":"type"},{"location":"#CompetingClocks","page":"Home","title":"CompetingClocks","text":"<a href=\"https://codecov.io/gh/adolgert/CompetingClocks.jl\">\n  <img src=\"https://codecov.io/gh/adolgert/CompetingClocks.jl/branch/main/graph/badge.svg\" alt=\"Coverage\">\n</a>\n\nFast, composable samplers for stochastic discrete-event simulation. This package gives your simulation or simulation framework statistical features like common random numbers, likelihood tracking, and first-class support for non-Exponential distributions.\n\nThis isn't a simulation framework. It's a component you can use to sample event times for simulation or to calculate the likelihood of a sample path for statistical estimation.\n\nSimulations of chemical reactions.\nQueueing theory models of networks, production, and computation.\nEpidemiological models of disease spread among individuals.\nVector-addition systems.\nGeneralized stochastic Petri nets.\nGeneralized semi-Markov Processes.\n\n(Image: CompetingClocks chooses the next transition but the simulation tracks state and changes to state.)","category":"section"},{"location":"#Implementation-Based-on","page":"Home","title":"Implementation Based on","text":"P. J. Haas, Stochastic Petri Nets: Modelling, Stability, Simulation. in Springer Series in Operations Research. New York, NY: Springer-Verlag New York, Inc, 2002. doi: 10.1007/b97265.\nD. F. Anderson and T. G. Kurtz, Stochastic Analysis of Biochemical Systems. Springer International Publishing AG Switzerland, 2015.\nContinuous-time, discrete-event simulation from counting processes, by Andrew Dolgert, 2016.","category":"section"},{"location":"#Version-History","page":"Home","title":"Version History","text":"v0.2.0 (2025-12) - Likelihood calculation, variance reduction.\nv0.1.0 (2024-06) - Initial release of samplers.","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"The library provides you with samplers. Each sampler has the same interface. Here, a distribution is a Distributions.ContinuousUnivariateDistribution, RNG is a random number generator, the key is some identifier (maybe an integer, tuple, or pair) for the event, and an enabling time is a zero-time for the given distribution.\n\nenable!(sampler, key, distribution, enabling_time) - to start the clock on when an event will fire next.\ndisable!(sampler, key) - to turn off an event so it can't fire.\nnext(sampler) - to ask this library who could fire next, and it return a (time, key).\nfire!(sampler, key, time) - choose which event happens at what time.","category":"section"},{"location":"#When-NOT-to-use-Competing-Clocks","page":"Home","title":"When NOT to use Competing Clocks","text":"Pure exponential distributions and chemical systems? JumpProcesses.jl is a complete framework for this.\nNeed ODE coupling? Again, it's easier to stay within SciML and JumpProcesses.jl. CompetingClocks.jl supports ODEs as Dirac distributions.\nWant high-level frameworks? Try Agents.jl or ConcurrentSim.jl.\n\nCompetingClocks.jl is for:\n\nBuilding a simulation framework with\nGeneral distributions (Weibull, Gamma, etc.),\nLikelihood calculations or rare events, or\nVariance reduction.\nAdvanced work in reliability models, disease models, queueing models.","category":"section"},{"location":"rules/#Rules-and-Guidelines","page":"Rules and Guidelines","title":"Rules and Guidelines","text":"Even though this library is just handling a bag of event clocks, there are some rules for how to call the interface so that those clocks remain consistent. There are rules that keep the simulation running, and there are rules that guarantee repeatable simulations that have the correct statistical likelihood.\n\nSome simulations treat events as maybe changing state, maybe not changing state.\nSome simulations think of an event as probabilistically changing state.\nFor a simulation in continuous time, only one event can happen at any time.","category":"section"},{"location":"samplers/#Understanding-Samplers","page":"Understanding Samplers","title":"Understanding Samplers","text":"From the perspective of someone who uses samplers in a simulation the features are important.\n\nDoes this sampler work only for Exponential distributions or also non-Exponential distributions?\nDoes it support using atomic distributions, such as delta functions?\nDoes it take advantage of a GPU?\nDoes it put any restrictions on clock keys, such as requirements that they be sequential integers or that there be few keys?\nDoes it support variance reduction techniques, such as\nCommon random numbers\nantithetic variates\nimportance sampling\ncontrol variates?\nDoes it maintain accuracy for extreme distribution parameters or extreme draws?\n\nAnswers to these questions come from understanding how samplers are built. A modern description of samplers is in Marchetti [Marchetti:2019].","category":"section"},{"location":"samplers/#Series-of-choices","page":"Understanding Samplers","title":"Series of choices","text":"","category":"section"},{"location":"samplers/#Split-into-marginal-and-conditional","page":"Understanding Samplers","title":"Split into marginal and conditional","text":"CompetingClocks supports sampling from generalized semi-Markov processes (GSMP). Every sampler of GSMP is sampling a joint space of which clock event is next, E, and which time is next, T. The clock event is a discrete choice, and the time is a continuous choice. The first step to making a GSMP sampler is to split that joint distribution into marginals and conditionals.\n\nThe reason to split the joint distribution is that, to sample any joint distribution, the usual method is to sample from the marginal of one random variable and then, given that value, sample the conditional of the other random variable. There are three ways to split a GSMP's joint distribution.\n\nbeginaligned\nPET  = PEPTE \n = PETPT \n = min(PT_i)quad forall i\nendaligned\n\nThe first split is rarely, if ever, used because we specify GSMP simulations by the probability in time that each clock will have an event. It takes some work to calculate the marginal over events. If we use notation where lambda is the hazard, S is the survival, and t_0 is the current simulation time, then the equation an integral over a product including all enabled survivals.\n\nPE = int_t_0^infty lambda_i(t)prod_i S_i(t) dt\n\nInstead, the second split is used all of the time for Exponential distributions. It's the choice that leads to the class of Direct methods. That's because the marginal over time is easy to calculate for exponentials.\n\nPT = 1 - expleft(-sum_i int_t_0^t lambda_i(s)dsright)\n\nFor exponential distributions, the hazard is constant, which makes the integral trivial. But note that Gillespie's first two papers on exact stochastic simulation included a derivation of this direct method for non-exponential distributions. As with the Exponential distribution, this can be done analytically for the Weibull distribution. For general distributions, the code just has to integrate the right-hand side of the above equation. This is the kind of operation GPUs love.\n\nThe third split is a  way to sample the joint distribution by sampling from the conditional distribution of every enabled clock, which we call competing clocks. Define a random variate that is the minimum of those clocks, which defines the time to fire. This split matches our instinct that clocks are competing to fire next, and the first one wins.","category":"section"},{"location":"samplers/#Sampling-strategy","page":"Understanding Samplers","title":"Sampling strategy","text":"Now that we've chosen what random variables to sample, in what order, we choose a sampling strategy. By strategy, I mean one of\n\nsampling by inversion, also known as inverse transform sampling\nsampling by rejection, also known as an acceptance-rejection method\n\nThese are broad methods for sampling, each of which has specific variants for particular distributions or, in the case of GSMP, for random variables defined by sets of competing distributions.","category":"section"},{"location":"samplers/#Specialize-for-the-distribution","page":"Understanding Samplers","title":"Specialize for the distribution","text":"Here, we would specialize, for instance, for having all Exponential distributions or all Weibull distributions. Stochastic simulation also introduces another wrinkle in sampling univariate distributions.\n\nIn a simulation, it is often the case that a clock is disabled and enabled again, or that a clock that was enabled with one rate is re-enabled with a different rate because it depends on the state of the system, and that state has changed. As a result, we frequently sample clocks that are shifted left. A clock is shifted left when the traditional zero-time for the distribution is in the past. In this case, we have options for how we modify sampling the distribution.\n\nWe could use a rejection method, where we sample the distribution and reject samples that are times in the past. We could sample by inversion and select random variates that correspond only to future times. We could sample by rejection and choose a known distribution whose hazard always exceeds that of the shifted distribution. There are lots of options, but none are built into the Julia Distributions package as ways to sample shifted distributions. It's a small complication that applies to stochastic simulation, and we handle it in the code.","category":"section"},{"location":"samplers/#Data-structures-and-algorithms","page":"Understanding Samplers","title":"Data structures and algorithms","text":"The next concern is how to express these sampling methods in code. Many of the well-known exact stochastic simulation (SSA) algorithms for chemical simulation are variations, not on how to sample the distribution, but on what data structures and algorithms to use for accelerating that sampling method.\n\nFor instance, if we are sampling a simulation using only Exponential distributions, then the Direct method has many named variants. The first step for the Direct method is to sample a time. The time comes from inverting the survival of the system. Here, we denote a random variate between [0,1] by U.\n\nU = expleft(-sum_i lambda_i tright)\n\nThe simulation is more effecient if we can maintain sum_i lambda_i as a partial sum, so that we can index into it with log U. Further, every time there is a next event in the simulation, the list of enabled hazards changes, so we want to modify that list after each event, while maintaining the sum. For this purpose, there have been many data structures proposed. The general problem is known, in computer science as the prefix sum or prefix scan. An early attempt was an interesting structure called a Fenwick tree. The state of the art for this class of approaches was the optimized direct method, which is really just one of the prefix scan algorithms applied to the Direct method.","category":"section"},{"location":"samplers/#Examples","page":"Understanding Samplers","title":"Examples","text":"","category":"section"},{"location":"samplers/#First-to-fire","page":"Understanding Samplers","title":"First to fire","text":"The simplest way to sample a GSMP is to sample each clock the moment it's enabled. I don't know that there is a common name for this, so I'm calling it \"first to fire.\" This is a competing clocks split of the joint distribution. For each clock, it can ask the Julia library to sample that clock's distribution in whatever way it sees fit. This is helpful for both speed and accuracy because distributions have methods that are specialized for that distribution and, often, for particular ranges of distribution parameters. For example, it seems easy to sample an exponential using inversion. Here, U is a uniform variate between [0,1], and t is the sample time.\n\nt = (1lambda) log U\n\nHowever, every mathematical library uses the Ziggurat method because it is at least twice as fast. There might be a downside if you want to use automatic differentiation on the code.","category":"section"},{"location":"samplers/#Next-reaction-method","page":"Understanding Samplers","title":"Next reaction method","text":"The next reaction method also samples each clock, but it samples in such a way that it reduces usage of random number generation. Random number generation used to be slow, but it is now no longer a concern. (There's a funny paper about this that I'm having trouble finding.) Nevertheless, there are some reasons to use this method.\n\nWhen a clock is first enabled, the next reaction method samples a uniform variate in [0,1], and then it finds a putative next event time for that clock using inversion. The original random variate is considered the total survival for this clock. The interesting move is that, if that same clock is disabled, this method saves some measure of how far the clock has gotten. That is, it measures the survival of the clock and subtracts that survival from the total survival. If the clock is ever enabled again, its new firing time is determined by the remaining survival.\n\nIs that allowed? The authors of the Next Reaction sort of prove it in \"Efficient Exact Stochastic Simulation of Chemical Systems with Many Species and Many Channels\", but they can fortunately can rely on the work of Kurtz [Kurtz:1970], which I don't quite see in their references. Nevertheless, Anderson and Kurtz amended this work with \"Continuous time markov chain models for chemical reaction methods\".\n\nIn Anderson and Kurtz, they take the same approach as the next reaction method. It's still split by the conditional firing times. It's still sampling by inversion, but they change to a log-space for the sampling of individual distributions. That's the whole change. Instead of storing the total survival, U, they store the log of that quantity, which turns out to be much more efficient for exponentials and Weibulls, which are used most frequently.\n\nIn CompetingClocks, you'll see a single sampler that uses a combination of the next reaction method (Gibson and Bruck) and the modified next reaction method (Anderson and Kurtz). Based on the particular univariate distribution, the code uses a lookup into a performance table to choose either a linear space or log space. It's the best of both worlds, and it's just a matter of changing data structures a little bit.\n\nWhy do people like the next reaction method when the first to fire is much less fussy and will use the appropriate sampler for the distribution, every time? It's about features. The next reaction method stores data that helps calculate importance samples. It also makes it easy to implement common random numbers. Finally, the next reaction method always samples from U=01 or from an exponential distribution, and then it transforms that value into the sample of the particular clock's distribution. This is called pathwise sampling, and it enables a simple method for taking derivatives of distributions.","category":"section"},{"location":"samplers/#Direct-method-for-exponentials","page":"Understanding Samplers","title":"Direct method for exponentials","text":"The Direct method is really quite solved, as described above. However, there is one complication that has to do with clock keys. Literature about prefix scans assumes that there are integer indices into an ordered, fixed list of integers. That is, you will use the integers 1-100 for the whole simulation. It seems so useful to have clock keys that can be strings, tuples, or other immutable types, so CompetingClocks uses a prefix scan that maintains a dictionary of keys.\n\nIf the prefix scan has a dictionary of keys, then it could remember the keys forever or it could forget them. If you have a long-running simulation that uses an ever-growing number of event keys, then it's important to remove keys that are no longer in use. If you have a simulation that uses a fixed set of keys, it's easier to keep them in the dictionary.\n\nIt would be interesting to ask whether we could create a data structure that is a keyed prefix sum, instead of using a dictionary that indexes into a prefix sum.","category":"section"},{"location":"samplers/#References","page":"Understanding Samplers","title":"References","text":"[Kurtz:1970] Kurtz, Thomas G. \"Solutions of ordinary differential equations as limits of pure jump Markov processes.\" Journal of applied Probability 7.1 (1970): 49-58.\n\n[Marchetti:2019] Marchetti, Luca, Corrado Priami, and Vo Hong Thanh. Simulation algorithms for computational systems biology. Vol. 1. Berlin, Germany, 2019.","category":"section"}]
}
