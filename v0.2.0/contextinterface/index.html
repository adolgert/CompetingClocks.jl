<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Context Interface · CompetingClocks.jl Documentation</title><meta name="title" content="Context Interface · CompetingClocks.jl Documentation"/><meta property="og:title" content="Context Interface · CompetingClocks.jl Documentation"/><meta property="twitter:title" content="Context Interface · CompetingClocks.jl Documentation"/><meta name="description" content="Documentation for CompetingClocks.jl Documentation."/><meta property="og:description" content="Documentation for CompetingClocks.jl Documentation."/><meta property="twitter:description" content="Documentation for CompetingClocks.jl Documentation."/><meta property="og:url" content="https://adolgert.github.io/CompetingClocks.jl/contextinterface/"/><meta property="twitter:url" content="https://adolgert.github.io/CompetingClocks.jl/contextinterface/"/><link rel="canonical" href="https://adolgert.github.io/CompetingClocks.jl/contextinterface/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CompetingClocks.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../quickstart/">Quickstart</a></li><li><a class="tocitem" href="../mainloop/">Sample Main Loop</a></li><li><a class="tocitem" href="../choosing_sampler/">Choosing a Sampler</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../integration-guide/">Integration Guide</a></li><li><a class="tocitem" href="../low_level_interface/">Low-level Sampler Interface</a></li><li><a class="tocitem" href="../samplers/">Understanding Samplers</a></li><li><a class="tocitem" href="../delayed/">Delayed Clocks</a></li><li><a class="tocitem" href="../guide/">Competing Clocks</a></li><li><a class="tocitem" href="../distributions/">Non-exponential Simulation</a></li><li><a class="tocitem" href="../hierarchical/">Hierarchical Samplers</a></li><li><a class="tocitem" href="../debugging/">Debugging a Simulation that Uses CompetingClocks</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../reliability/">Reliability</a></li><li><a class="tocitem" href="../sir/">SIR Model</a></li><li><a class="tocitem" href="../constant_birth/">Birth-death Process</a></li><li><a class="tocitem" href="../memory/">Transitions with Memory</a></li><li><a class="tocitem" href="../gene_expression/">Gene Expression</a></li></ul></li><li><span class="tocitem">Statistical Methods</span><ul><li><a class="tocitem" href="../commonrandom/">Common Random Numbers</a></li><li><a class="tocitem" href="../importance_skills/">Importance Sampling for Simulation</a></li><li><a class="tocitem" href="../hamiltonianmontecarlo/">Hamiltonian Monte Carlo</a></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">Gen.jl Integration</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../gen/overview/">Gen.jl and CompetingClocks.jl</a></li><li><a class="tocitem" href="../gen/distribution/">CompetingClocks as a Gen Distribution</a></li><li><a class="tocitem" href="../gen/generative_function/">CompetingClocks as a Gen Generative Function</a></li><li><a class="tocitem" href="../gen/observation_likelihood/">Observation Likelihood for Event Data</a></li><li><a class="tocitem" href="../gen/importance_mixture/">Importance Sampling with Mixture Proposals</a></li><li><a class="tocitem" href="../gen/hmc_paths/">HMC over Event Paths with Gen.jl</a></li></ul></li><li><a class="tocitem" href="../gen/turing_dist/">Bayesian Inference with Turing.jl</a></li><li><a class="tocitem" href="../gen/survival_snippet/">Integration with Survival.jl</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li class="is-active"><a class="tocitem" href>Context Interface</a><ul class="internal"><li><a class="tocitem" href="#Building-a-Context"><span>Building a Context</span></a></li><li><a class="tocitem" href="#Choosing-Sampler-Methods"><span>Choosing Sampler Methods</span></a></li><li><a class="tocitem" href="#Using-a-Context"><span>Using a Context</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Samplers</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Context Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Context Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/adolgert/CompetingClocks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/adolgert/CompetingClocks.jl/blob/main/docs/src/contextinterface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Context-Interface"><a class="docs-heading-anchor" href="#Context-Interface">Context Interface</a><a id="Context-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Context-Interface" title="Permalink"></a></h1><h2 id="Building-a-Context"><a class="docs-heading-anchor" href="#Building-a-Context">Building a Context</a><a id="Building-a-Context-1"></a><a class="docs-heading-anchor-permalink" href="#Building-a-Context" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="CompetingClocks.SamplingContext-Union{Tuple{R}, Tuple{T}, Tuple{K}, Tuple{Type{K}, Type{T}, R}} where {K, T, R&lt;:AbstractRNG}"><a class="docstring-binding" href="#CompetingClocks.SamplingContext-Union{Tuple{R}, Tuple{T}, Tuple{K}, Tuple{Type{K}, Type{T}, R}} where {K, T, R&lt;:AbstractRNG}"><code>CompetingClocks.SamplingContext</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SamplingContext(::Type{K}, ::Type{T}, rng::AbstractRNG; kwargs...)</code></pre><p>Convenience wrapper that allocates a <code>SamplerBuilder</code> then builds a <code>SamplingContext</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L73-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.SamplingContext-Union{Tuple{R}, Tuple{SamplerBuilder, R}} where R&lt;:AbstractRNG"><a class="docstring-binding" href="#CompetingClocks.SamplingContext-Union{Tuple{R}, Tuple{SamplerBuilder, R}} where R&lt;:AbstractRNG"><code>CompetingClocks.SamplingContext</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SamplingContext(builder::SamplerBuilder, rng)</code></pre><p>Uses the <a href="#CompetingClocks.SamplerBuilder"><code>SamplerBuilder</code></a> to make a SamplingContext.</p><p><code>K</code> is always the <em>user</em> key type (<code>builder.clock_type</code>). The sampler and middleware use an internal key type <code>K_int</code> which is equal to <code>K</code> for regular contexts and <code>Tuple{K,Symbol}</code> when <code>builder.support_delayed == true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L19-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.SamplerBuilder"><a class="docstring-binding" href="#CompetingClocks.SamplerBuilder"><code>CompetingClocks.SamplerBuilder</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SamplerBuilder(::Type{K}, ::Type{T};
    step_likelihood=false,
    path_likelihood=false,
    debug=false,
    recording=false,
    common_random=false,
    method=nothing,
    start_time::T,
    likelihood_cnt::Int,
    support_delayed=false,
    )</code></pre><p>A SamplerBuilder is responsible for recording a user&#39;s requirements and building an initial sampler.</p><ul><li><code>K</code> and <code>T</code> are the clock type and time type.</li><li><code>step_likelihood</code> - whether you will call <code>steploglikelihood</code> before each <code>fire!</code></li><li><code>path_likelihood</code> - whether you will call <code>pathloglikelihood</code>  at the end of a simulation run.</li><li><code>debug</code> - Print log messages at the debug level.</li><li><code>recording</code> - Store every enable and disable for later examination.</li><li><code>common_random</code> - Use common random numbers during sampling.</li><li><code>method</code> - If you want a single, particular sampler, put its <code>SamplerSpec</code> here. It will create a group called <code>:all</code> that has this sampling method.</li><li><code>start_time</code> - Sometimes a simulation shouldn&#39;t start at zero.</li><li><code>likelihood_cnt</code> - The number of likelihoods to compute, corresponds to number of distributions in <code>enable!</code> calls. This turns on <code>path_likelihood</code>.</li><li><code>support_delayed</code> - If <code>true</code>, the internal sampler key type becomes <code>Tuple{K,Symbol}</code> to distinguish regular, initiation, and completion phases.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sampler_builder.jl#L37-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.add_group!"><a class="docstring-binding" href="#CompetingClocks.add_group!"><code>CompetingClocks.add_group!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>The <code>selector</code> defines the group of clocks that go to this sampler using an inclusion rule, so it&#39;s a function from a clock key and distribution to a Bool.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sampler_builder.jl#L93-L96">source</a></section></details></article><h2 id="Choosing-Sampler-Methods"><a class="docs-heading-anchor" href="#Choosing-Sampler-Methods">Choosing Sampler Methods</a><a id="Choosing-Sampler-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-Sampler-Methods" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="CompetingClocks.NextReactionMethod"><a class="docstring-binding" href="#CompetingClocks.NextReactionMethod"><code>CompetingClocks.NextReactionMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NextReactionMethod()</code></pre><p>Uses Anderson&#39;s Modified Next Reaction method for distributions in an Exponential class (Exponential, Weibull, Erlang) and the Next Reaction method for other distributions. Yes, these two methods are mixed into one sampler because Julia&#39;s holy traits pattern makes it efficient to use the fastest sampler on a distribution-by-distribution basis. Because it reuses draws, this is the best choice if you want to do variance reduction with Common Random Numbers.</p><p>See <a href="../low_level_interface/#CompetingClocks.CombinedNextReaction"><code>CombinedNextReaction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/samplerspec.jl#L12-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.DirectMethod"><a class="docstring-binding" href="#CompetingClocks.DirectMethod"><code>CompetingClocks.DirectMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DirectMethod()
DirectMethod(memory::Symbol, search::Symbol)
DirectMethod(:keep, :scan)
DirectMethod(:keep, :tree)
DirectMethod(:remove, :scan)
DirectMethod(:remove, :tree)</code></pre><p>Use this to specify any Direct method for Exponential distributions. Defaults to <code>memory=:remove</code> so it limits memory growth over time but <code>memory=:keep</code> will be faster if the space of clock keys is limited. Defaults to <code>search=:tree</code> for best performance for many enabled clocks but <code>search=:scan</code> is faster for small numbers of clocks. The different kinds of methods, like &quot;Optimized Direct Methods&quot; amount to using different computer science techniques for scanning sums of hazard rates, and that&#39;s what the <code>search</code> algorithm lets you choose.</p><p>See <a href="../low_level_interface/#CompetingClocks.DirectCall"><code>DirectCall</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/samplerspec.jl#L28-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.FirstReactionMethod"><a class="docstring-binding" href="#CompetingClocks.FirstReactionMethod"><code>CompetingClocks.FirstReactionMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FirstReactionMethod()</code></pre><p>The classic sampler that draws every clock at every time step. Very fast for very small numbers of enabled clocks and returns a new <code>next()</code> every time it is called which helps when resampling paths. Other samplers return the same value every time you call <code>next()</code> unless you <code>jitter!</code> them, which is expensive.</p><p>See <a href="../low_level_interface/#CompetingClocks.FirstReaction"><code>FirstReaction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/samplerspec.jl#L78-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.FirstToFireMethod"><a class="docstring-binding" href="#CompetingClocks.FirstToFireMethod"><code>CompetingClocks.FirstToFireMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FirstToFireMethod()</code></pre><p>The simplest and fastest sampler. When you <code>enable!()</code> a clock, this draws the firing time and saves it in a queue.</p><p>See <a href="../low_level_interface/#CompetingClocks.FirstToFire"><code>FirstToFire</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/samplerspec.jl#L92-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.PartialPropensityMethod"><a class="docstring-binding" href="#CompetingClocks.PartialPropensityMethod"><code>CompetingClocks.PartialPropensityMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PartialPropensityMethod()</code></pre><p>Exact, continuous-time sampler using composition-rejection over groups. Only for exponential distributions. This variant of partial-propensity composition-rejection implements the sampler but not the reaction network. The reaction-network can be implemented outside of the sampler.</p><p>See <a href="../low_level_interface/#CompetingClocks.PSSACR"><code>PSSACR</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/samplerspec.jl#L121-L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.PetriMethod"><a class="docstring-binding" href="#CompetingClocks.PetriMethod"><code>CompetingClocks.PetriMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PetriMethod()
PetriMethod(dt)</code></pre><p>Samples by picking at random ignoring distributions. Good for testing rare cases in simulations. Increments time <code>dt=1.0</code> by default. It&#39;s called &quot;Petri&quot; because a Petri net model always chooses the next event at random.</p><p>See <a href="../low_level_interface/#CompetingClocks.Petri"><code>Petri</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/samplerspec.jl#L138-L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.RejectionMethod"><a class="docstring-binding" href="#CompetingClocks.RejectionMethod"><code>CompetingClocks.RejectionMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RejectionMethod(bound_factor=1.05)</code></pre><p>A rejection-based algorithm. Only for exponential distributions, this may be the fastest for large simulations. The <code>bound_factor&gt;= 1.0</code> controls the default upper bounds. Set to 1.0 for no rejections, which reduces this to the direct method.</p><p>See <a href="../low_level_interface/#CompetingClocks.RSSA"><code>RSSA</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/samplerspec.jl#L104-L113">source</a></section></details></article><h2 id="Using-a-Context"><a class="docs-heading-anchor" href="#Using-a-Context">Using a Context</a><a id="Using-a-Context-1"></a><a class="docs-heading-anchor-permalink" href="#Using-a-Context" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="CompetingClocks.enable!"><a class="docstring-binding" href="#CompetingClocks.enable!"><code>CompetingClocks.enable!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">enable!(sampler, clock, distribution, enablingtime, currenttime, RNG)</code></pre><p>Tell the sampler to start a clock.</p><ul><li><code>sampler::SSA{KeyType,TimeType}</code> - The sampler to tell.</li><li><code>clock::KeyType</code> - The ID of the clock. Can be a string, integer, tuple, etc.</li><li><code>distribution::Distributions.UnivariateDistribution</code></li><li><code>enablingtime::TimeType</code> - The zero time for the clock&#39;s distribution, in absolute time. Usually equal to <code>when</code>.</li><li><code>when::TimeType</code> - The current time of the simulation.</li><li><code>rng::AbstractRNG</code> - A random number generator.</li></ul><p>These times are <strong>absolute</strong> since the start of the simulation. The current time should be <code>when</code>. If you want to shift the distribution so that this event cannot happen for a little while then choose <code>enablingtime &gt; when</code>. If you want to modify the distribution by shifting it left, then choose <code>enablingtime &lt; when</code>. Usually, <code>enablingtime == when</code>. It is also possible to always use <code>enablingtime == when</code> and use the <code>truncated()</code> function to modify distributions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L22-L40">source</a></section><section><div><pre><code class="language-julia hljs">enable!(dc::DirectCall, clock::T, distribution::Exponential, when, rng)</code></pre><p>Tell the <code>DirectCall</code> sampler to enable this clock. The <code>clock</code> argument is an identifier for the clock. The distribution is a univariate distribution in time. In Julia, distributions are always relative to time <code>t=0</code>, but ours start at some absolute enabling time, <span>$t_e$</span>, so we provide that here. The <code>when</code> argument is the time at which this clock is enabled, which may be later than when it was first enabled. The <code>rng</code> is a random number generator.</p><p>If a particular clock had one rate before an event and it has another rate after the event, call <code>enable!</code> to update the rate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/direct.jl#L82-L94">source</a></section><section><div><pre><code class="language-julia hljs">enable!(ctx, clock, dist, relative_te)</code></pre><p>Enable a regular clock in a non-delayed context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L167-L171">source</a></section><section><div><pre><code class="language-julia hljs">enable!(ctx::SamplingContext, clock::K, dist::Vector)</code></pre><p>Enabling when there is no shift in enabling time and no delayed distributions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L188-L192">source</a></section><section><div><pre><code class="language-julia hljs">enable!(ctx, clock, dist::Vector, relative_te)</code></pre><p>Vectorized enable in a non-delayed context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L199-L203">source</a></section><section><div><pre><code class="language-julia hljs">enable!(ctx::SamplingContext, clock::K, dist::Vector)</code></pre><p>Enabling for a vector of distributions (for importance sampling) when there is no shift in enabling time and no delayed distributions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L221-L226">source</a></section><section><div><pre><code class="language-julia hljs">enable!(ctx, clock, dist, relative_te)</code></pre><p>Regular (non-delayed) clock enable in a delayed-support context. User key <code>clock::K</code> is mapped to internal <code>(clock, :regular)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L237-L242">source</a></section><section><div><pre><code class="language-julia hljs">enable!(ctx::SamplingContext, clock::K, dist)</code></pre><p>Enabling when there is no shifted enabling time but there are delayed distributions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L260-L264">source</a></section><section><div><pre><code class="language-julia hljs">enable!(ctx, clock, dist::Vector, relative_te)</code></pre><p>Vectorized enable for regular clocks in a delayed context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L271-L275">source</a></section><section><div><pre><code class="language-julia hljs">enable!(ctx::SamplingContext, clock::K, dist::Vector)</code></pre><p>Enabling when there is a vector of distributions and no shifted enabling time for those distributions and there are delayed distributions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L294-L299">source</a></section><section><div><pre><code class="language-julia hljs">enable!(ctx, clock, delayed::Delayed, relative_te)</code></pre><p>Enable a delayed reaction. This:</p><ul><li>Stores the <strong>duration distribution</strong> <code>delayed.duration</code> in <code>ctx.delayed.durations[clock]</code>.</li><li>Enables an initiation event with internal key <code>(clock, :initiate)</code> and distribution <code>delayed.initiation</code>.</li></ul><p>The <code>relative_te</code> shift applies only to the initiation, not the completion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L310-L321">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.disable!"><a class="docstring-binding" href="#CompetingClocks.disable!"><code>CompetingClocks.disable!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">disable!(sampler, clock, when)</code></pre><p>Tell the sampler to forget a clock. We include the current simulation time because some Next Reaction methods use this to optimize sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L102-L107">source</a></section><section><div><pre><code class="language-julia hljs">disable!(dc::DirectCall, clock::T, when)</code></pre><p>Tell the <code>DirectCall</code> sampler to disable this clock. The <code>clock</code> argument is an identifier for the clock. The <code>when</code> argument is the time at which this clock is enabled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/direct.jl#L106-L112">source</a></section><section><div><pre><code class="language-julia hljs">disable!(ctx, clock)</code></pre><p>Non-delayed context: disable a single clock.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L353-L357">source</a></section><section><div><pre><code class="language-julia hljs">disable!(ctx, clock)</code></pre><p>Delayed context: disable all phases associated with <code>clock</code> and clear any stored duration distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L365-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.next"><a class="docstring-binding" href="#CompetingClocks.next"><code>CompetingClocks.next</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">next(sampler, when, rng)</code></pre><p>Ask the sampler for what happens next, in the form of <code>(when, which)::Tuple{TimeType,KeyType}</code>. <code>rng</code> is a random number generator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L112-L117">source</a></section><section><div><pre><code class="language-julia hljs">next(dc::DirectCall, when::TimeType, rng::AbstractRNG)</code></pre><p>Ask the sampler what clock will be the next to fire and at what time. This does not change the sampler. You can call this multiple times and get multiple answers. Each answer is a tuple of <code>(when, which clock)</code>. If there is no clock to fire, then the response will be <code>(Inf, nothing)</code>. That&#39;s a good sign the simulation is done.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/direct.jl#L125-L133">source</a></section><section><div><pre><code class="language-julia hljs">next(multiple_direct, when, rng)</code></pre><p>Selects the next transition to fire and when it fires.</p><p>There are two main algorithms for this selection. This implementation handles the case when there are a lot of clocks or when some clocks have much smaller hazards. It first draws a random number to choose which subset of hazards will be used, and then it asks that subset to draw a random number to choose which particular hazard is used. When there are many hazards, it is possible that a random number generator will <em>never</em> choose a particular value because there is no guarantee that a random number generator covers every combination of bits. Using more draws decreases the likelihood of this problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/multiple_direct.jl#L135-L149">source</a></section><section><div><p>For the first reaction sampler, you can call next() multiple times and get different, valid, answers. That isn&#39;t the case here. When you call next() on a CombinedNextReaction sampler, it returns the key associated with the clock that fires and marks that clock as fired. Calling next() again would return a nonsensical value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/combinednr.jl#L185-L191">source</a></section><section><div><pre><code class="language-julia hljs">next(ctx::SamplingContext)</code></pre><p>Return <code>(when, internal_key)</code> for the next event from the underlying sampler. For non-delayed contexts, <code>internal_key</code> is the user key. For delayed contexts it is the internal key, e.g. <code>(user_key, phase)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L392-L398">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.fire!"><a class="docstring-binding" href="#CompetingClocks.fire!"><code>CompetingClocks.fire!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fire!(ctx, clock, when)</code></pre><p>Non-delayed context: fire a regular event and advance time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L425-L429">source</a></section><section><div><pre><code class="language-julia hljs">fire!(ctx, clock, when)</code></pre><p>Delayed context: treat this as a regular (non-delayed) event with phase <code>:regular</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L438-L442">source</a></section><section><div><pre><code class="language-julia hljs">fire!(ctx, clock, phase, when)</code></pre><p>Delayed context: fire an event with phase information.</p><ul><li><code>phase == :regular</code>   : regular event</li><li><code>phase == :initiate</code>  : initiation of a delayed reaction; schedules completion</li><li><code>phase == :complete</code>  : completion of a delayed reaction; clears delayed state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L448-L456">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.reset!"><a class="docstring-binding" href="#CompetingClocks.reset!"><code>CompetingClocks.reset!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">reset!(sampler)</code></pre><p>After a sampler is used for a simulation run, it has internal state. This function resets that internal state to the initial value in preparation for another sample run.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L52-L58">source</a></section><section><div><p>Doesn&#39;t reset the stored clocks, does reset miss count.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/variance/with_common_random.jl#L63-L65">source</a></section><section><div><pre><code class="language-julia hljs">reset!(ds::DelayedState)</code></pre><p>Clear all stored duration distributions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/delayed_state.jl#L54-L58">source</a></section><section><div><pre><code class="language-julia hljs">reset!(sampling)</code></pre><p>Clear all enabled clocks (and delayed state if present) and reset time to the fixed start time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L507-L512">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.copy_clocks!"><a class="docstring-binding" href="#CompetingClocks.copy_clocks!"><code>CompetingClocks.copy_clocks!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">copy_clocks!(destination_sampler, source_sampler)</code></pre><p>This copies the state of the source sampler to the destination sampler, replacing the current state of the destination sampler. This is useful for splitting techniques where you make copies of a simulation and restart it with different random number generators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L64-L71">source</a></section><section><div><pre><code class="language-julia hljs">copy_clocks!(dst, src)</code></pre><p>Copy enabled clocks and delayed state from <code>src</code> into <code>dst</code>, jittering the destination sampler so it will generate different <code>next()</code> samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L524-L529">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.Libc.time-Tuple{SamplingContext}"><a class="docstring-binding" href="#Base.Libc.time-Tuple{SamplingContext}"><code>Base.Libc.time</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">time(sampling)</code></pre><p>Current simulation time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L107-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.sample_from_distribution!"><a class="docstring-binding" href="#CompetingClocks.sample_from_distribution!"><code>CompetingClocks.sample_from_distribution!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sample_from_distribution!(sampling, index)</code></pre><p>Choose which element of a vector-of-distributions to sample from when using path likelihoods (importance sampling).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L115-L120">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.clone"><a class="docstring-binding" href="#CompetingClocks.clone"><code>CompetingClocks.clone</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">clone(sampler)</code></pre><p>Given an existing sampler, make a copy that has the same type and same constructor options but has no data in it. Use this to initialize an array of samplers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L77-L83">source</a></section><section><div><pre><code class="language-julia hljs">clone(ds::DelayedState)</code></pre><p>Deep copy of a <code>DelayedState</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/delayed_state.jl#L64-L68">source</a></section><section><div><pre><code class="language-julia hljs">clone(sampling, rng)</code></pre><p>Clone a <code>SamplingContext</code> as though constructed again, using a new RNG. All subcomponents (sampler, likelihood, CRN, debug, delayed state) are cloned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L84-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.enabled"><a class="docstring-binding" href="#CompetingClocks.enabled"><code>CompetingClocks.enabled</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">enabled(sampler)</code></pre><p>Returns a read-only set of currently-enabled clocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L180-L184">source</a></section><section><div><pre><code class="language-julia hljs">enabled(sampling)</code></pre><p>Return the set of enabled clock keys. For delayed contexts this returns the <em>internal</em> keys, e.g. <code>(K, Symbol)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L563-L568">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.enabled_history"><a class="docstring-binding" href="#CompetingClocks.enabled_history"><code>CompetingClocks.enabled_history</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">enabled_history(ctx::SamplingContext)</code></pre><p>Returns a <code>Vector{EnablingEntry{K,T}}</code> that has every time a clock was enabled.</p><p>See <a href="#CompetingClocks.EnablingEntry"><code>CompetingClocks.EnablingEntry</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L664-L670">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.disabled_history"><a class="docstring-binding" href="#CompetingClocks.disabled_history"><code>CompetingClocks.disabled_history</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">disabled_history(ctx::SamplingContext)</code></pre><p>Returns a <code>Vector{DisablingEntry{K,T}}</code> that has every time a clock was disabled.</p><p>See <a href="#CompetingClocks.DisablingEntry"><code>CompetingClocks.DisablingEntry</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L679-L685">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.EnablingEntry"><a class="docstring-binding" href="#CompetingClocks.EnablingEntry"><code>CompetingClocks.EnablingEntry</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EnablingEntry{K,T}(clock::K, distribution, te::T, when::T)</code></pre><p>Records that <code>clock</code> is enabled at time <code>when</code> with an enabling time <code>te</code> (in absolute time) that sets the zero of the <code>distribution</code>.</p><p><strong>Fields</strong></p><ul><li><code>clock::K</code>: The key for the event/clock/transition.</li><li><code>distribution::Distributions.UnivariateDistribution</code>, a distribution of clock firing times.</li><li><code>te::T</code> - An absolute time to use as the zero-time for the distribution. Usually the same as <code>when</code>.</li><li><code>when::T</code> - The time this clock was enabled.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/trace/track.jl#L7-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.DisablingEntry"><a class="docstring-binding" href="#CompetingClocks.DisablingEntry"><code>CompetingClocks.DisablingEntry</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DisablingEntry{K,T}(clock::K, when::T)</code></pre><p>Records that <code>clock</code> is disabled at time <code>when</code>.</p><p><strong>Fields</strong></p><ul><li><code>clock::K</code>: The key for the event/clock/transition.</li><li><code>when::T</code> - The time this clock was enabled.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/trace/track.jl#L27-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.length-Tuple{SamplingContext}"><a class="docstring-binding" href="#Base.length-Tuple{SamplingContext}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.length(sampling)</code></pre><p>Total number of enabled clocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L575-L579">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.isenabled"><a class="docstring-binding" href="#CompetingClocks.isenabled"><code>CompetingClocks.isenabled</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isenabled(sampling, clock)</code></pre><p>Whether this user clock key is enabled. In delayed contexts this returns true if any phase (<code>:regular</code>, <code>:initiate</code>, <code>:complete</code>) is enabled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L586-L591">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.keytype-Tuple{SamplingContext}"><a class="docstring-binding" href="#Base.keytype-Tuple{SamplingContext}"><code>Base.keytype</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">keytype(sampler)</code></pre><p>Return the type of clock keys.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L154-L158">source</a></section><section><div><pre><code class="language-julia hljs">keytype(sampling)</code></pre><p>User clock key type <code>K</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L607-L611">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.timetype"><a class="docstring-binding" href="#CompetingClocks.timetype"><code>CompetingClocks.timetype</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timetype(sampler)</code></pre><p>Return the type of clock times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/sample/interface.jl#L162-L166">source</a></section><section><div><pre><code class="language-julia hljs">timetype(sampling)</code></pre><p>Time type <code>T</code>, usually <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L614-L618">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CompetingClocks.pathloglikelihood"><a class="docstring-binding" href="#CompetingClocks.pathloglikelihood"><code>CompetingClocks.pathloglikelihood</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pathloglikelihood(ctx, endtime)</code></pre><p>Path log-likelihood up to <code>endtime</code>, including the probability that no event fires after the last event before <code>endtime</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/CompetingClocks.jl/blob/504693648bb84a357fc0c04b82eaea2f9594201d/src/context.jl#L642-L647">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gen/survival_snippet/">« Integration with Survival.jl</a><a class="docs-footer-nextpage" href="../reference/">Samplers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 28 November 2025 21:11">Friday 28 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
